// A fast YAML 1.2 parser
// Written by Robert van Engelen
// Edited by Maxim Voloshin
//
// https://yaml.org/spec/1.2/spec.html
//
// YAML doesn't define a formal grammar but instead defines over 200 rules.
// YAML uses indent to define structure.  This RE/flex lexer and parser uses
//
// This YAML parser follows the specification but does not generate errors for
// invalid YAML syntax, just tries to make sense of it all (YAML is complex!).
//
// YAML tokens generated by the lexer:
// - 'S' YAML document start marker ---
// - 'E' YAML document end marker ...
// - '=' one or more empty or blank lines
// - '$' string (a YAML scalar, quoted scalar, or block scalar)
// - '-' sequence dash
// - '?' map complex key
// - ':' map colon
// - '[' flow sequence open bracket
// - ']' flow sequence close bracket
// - '{' flow sequence open brace
// - '}' flow sequence close brace
// - ',' flow sequence or map comma
//
// YAML test files:
// - https://www.genivia.com/files/yamltests.zip

%option lexer=LexerYaml
%option namespace=rf_yaml

%o fast freespace unicode noline noindent

%top{
  #include <cstdlib> // strtoul()
  #include <iostream> // std::cout etc.
  #include <iomanip>  // std::setw
  #include <vector>   // to store YAML containers

  #include "../position.h"
}

%class{
 public:
  LexerYaml(const char* input, size_t input_size) : LexerYaml(reflex::Input(input, input_size)){
  }

  er::Position get_position() {
    return er::Position{.column = columno(), .line_number = lineno()};
  }

  size_t get_border() {
    return border();
  }

  inline std::string& get_word() {
    return _word;
  }

  // count number of newlines matched
  size_t newlines()
  {
    return chr() == '\r' ? size()/2 : size();
  }

  // parse the indent value given after a '|' or '>', if present
  void parse_indent(size_t offset)
  {
    indent = strtoul(text() + offset, NULL, 10);
  }

  // clear the string scalar before accumulating a new scalar
  void clear() {
    _word.clear();
  }

  // add one or n chars c to the string
  void add(char c, size_t n = 1) {
    while (n-- > 0) {
      _word.push_back(c);
    }
  }

  void add_unicode(wchar_t c) {
    char* c_ptr = reinterpret_cast<char*>(&c);
    _word.push_back(c_ptr[1]);
    _word.push_back(c_ptr[0]);
  }

  // add sp spaces to the string
  void add_space() {
    _word.append(sp, ' ');
    sp = 0;
  }

  // chomp the string
  void chomp()
  {
    switch (mode)
    {
      case CLIP:
        while (!_word.empty() && _word.back() == '\n') {
          _word.pop_back();
        }
        _word.push_back('\n');
        break;
      case STRIP:
        while (!_word.empty() && _word.back() == '\n') {
          _word.pop_back();
        }
        break;
      case KEEP:
        break;
    }
  }

  unsigned long indent;            // block scalar indent value
  size_t sp;                       // insert spaces in folded block scalar
  bool nl;                         // insert newline in folded block scalar
  enum { CLIP, STRIP, KEEP } mode; // chomp mode

 private:
  std::string _word; // string to accumulate YAML scalars
}

// Lexer class initialization at construction
%init {
  indent = 0;
  nl = false;
  sp = 0;
  mode = CLIP;
}

%x APOS QUOT PBLK FBLK

direct  \h* % [^\n]* \n
comment \h* # [^\n]*
ic      [^-?:\\\[\]{},!&*#'"@`[:space:]]
rc      [^\\\[\]{}:,[:space:]]
rd      [^-\\\[\]{}:,[:space:]]
rh      [^#\\\[\]{}:,[:space:]]
scalar  ({ic} | [-:?] {rd} | --- {rc}) ({rc} | :+ {rc} | \h+ {rh})*
tag     [!&*] {rc}+
h2      [[:xdigit:]]{2}
h4      [[:xdigit:]]{4}
h8      [[:xdigit:]]{8}
nl      \h* (# [^\n]* | \r)? \n
lf      \r? \n
bl      {lf} (\h* {lf})+
br      \h+ | (\h* {lf})+

%%

{direct}        { /* ignore directive */ }
{comment}       { /* ignore comment */ }
\h* {lf}        { /* ignore new line */ }
\h* {bl}        { /* ignore new line */ }
\h+             { /* ignore spaces and tabs */ }
"---" {br}      { return 'S'; }
"..." {br}      { return 'E'; }
"-"             { return '-'; }
"?"             { return '?'; }
":"             { return ':'; }
","             { return ','; }
"["             { return '['; }
"]"             { return ']'; }
"{"             { return '{'; }
"}"             { return '}'; }
"'"             { clear(); start(APOS); }
\"              { clear(); start(QUOT); }
"|"  \d* {nl}   { clear(); parse_indent(1); mode = CLIP;  }
"|-" \d* {nl}   { clear(); parse_indent(2); mode = STRIP; }
"|+" \d* {nl}   { clear(); parse_indent(2); mode = KEEP;  }
">"  \d* {nl}   { clear(); parse_indent(1); mode = CLIP;  }
">-" \d* {nl}   { clear(); parse_indent(2); mode = STRIP; }
">+" \d* {nl}   { clear(); parse_indent(2); mode = KEEP;  }
{tag}           { _word = str(); return chr(); }
{scalar}        { _word = str(); return '$'; }

<APOS>{
'               { start(INITIAL); return '$'; }
''              { add('\''); }
}

<QUOT>{
\\ {lf}         { /* ignore \LF */ }
\"              { start(INITIAL); return '$'; }
\\ 0            { add('\0'); }
\\ a            { add('\a'); }
\\ b            { add('\b'); }
\\ t            { add('\t'); }
\\ n            { add('\n'); }
\\ v            { add('\v'); }
\\ f            { add('\f'); }
\\ r            { add('\r'); }
\\ e            { add(0x1b); }
\\ N            { add(0x85); }
\\ _            { add(0xa0); }
\\ L            { add_unicode(0x2028); }
\\ P            { add_unicode(0x2029); }
\\ x {h2}       { add(strtoul(text() + 2, NULL, 16)); }
\\ u {h4}       { add(strtoul(text() + 2, NULL, 16)); }
\\ U {h8}       { add(strtoul(text() + 2, NULL, 16)); }
\\ .            { add(str()[1]); }
}

<APOS,QUOT>{
\h* {lf}        { add(' '); }
{bl}            { add('\n', newlines() - 1); }
.               { add(chr()); }
}

<PBLK>{
{lf}            { add('\n'); }
{bl}            { add('\n', newlines()); }
.               { add(chr()); }
}

<FBLK>{
\h+ {lf}        { sp = size() - 1 - (*(matcher().end() - 2) == '\r'); }
{lf}            { sp = 1; }
{bl}            { add('\n', newlines() - 1); }
.               { add_space(); add(chr()); }
}

%%
