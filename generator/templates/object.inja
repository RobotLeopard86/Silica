#include "{{file_name}}.er.h"

// clang-format off
#include "er/reflection/the_great_table.h"
#include "er/types/common_actions.h"
#include "er/types/type_actions.h"

namespace er {

template <>
struct TypeActions<{{name}}> {
  static TypeInfo reflect(void* value, bool is_const) {
    auto* p = static_cast<{{name}}*>(value);

    static std::map<std::string_view, FieldDesc> fields {
      {% for item in fields_static -%}
        {"{{item.alias}}", FieldDesc::create_static(&{{name}}::{{item.name}}, FieldAttributes::{{item.access}})},
      {% endfor -%}
      {% for item in fields -%}
        {"{{item.alias}}", FieldDesc::create_member(p, &p->{{item.name}}, FieldAttributes::{{item.access}})},
    {% if not loop.is_last %}  {% else %}};{% endif -%}
      {% endfor %}
    static std::map<std::string_view, MethodDesc> func {
      {% for item in func_static -%}
        {"{{item.alias}}", MethodDesc(&invoke_{{item.name}}, MethodAttributes::{{item.access}})},
      {% endfor -%}
      {% for item in func -%}
        {"{{item.alias}}", MethodDesc(&invoke_{{item.name}}, MethodAttributes::{{item.access}})},
    {% if not loop.is_last %}  {% else %}};{% endif -%}
      {% endfor %}
    };
    return Object(Var(p, is_const), &fields);
  }

{% for item in func_static -%}
  static Expected<None> invoke_{{item.name}}(void* res, void* obj, const std::vector<Var>& args) {
    if (args.size() != {{length(func_static)}}) {
      return Error("Number of arguments is not the same as in the callable");
    }

    {% for type in item.params -%}
    if (args[{{loop.index}}].type() != TypeId::get<{{type}}>()) {
      return Error(format("Type Expected: {{type}}, revceived: {}", reflection::type_name(args[{{loop.index}}].type())));
    }
    const {{type}}& a{{loop.index}} = *static_cast<const {{type}}*>(args[{{loop.index}}].raw());

    {% endfor -%}

    auto* p = static_cast<{{name}}*>(obj);

    {% if item.return -%}
    *reinterpret_cast<{{item.return}}*>(res) = //
    {% endif -%}
    std::invoke(&{{name}}::{{item.name}},
    {% for i in range(length(item.params)) -%}
      {% if not loop.is_last -%}
        a{{loop.index}},
      {% else %}
        a{{loop.index}});
      {% endif %}
    {% endfor %}

    return None();
  }
{% endfor %}
{% for item in func -%}
  static Expected<None> invoke_{{item.name}}(void* res, void* obj, const std::vector<Var>& args) {
    if (args.size() != {{length(func_static)}}) {
      return Error("Number of arguments is not the same as in the callable");
    }

    {% for type in item.params -%}
    if (args[{{loop.index}}].type() != TypeId::get<{{type}}>()) {
      return Error(format("Type Expected: {{type}}, revceived: {}", reflection::type_name(args[{{loop.index}}].type())));
    }
    const {{type}}& a{{loop.index}} = *static_cast<const {{type}}*>(args[{{loop.index}}].raw());

    {% endfor %}

    auto* p = static_cast<{{name}}*>(obj);

    {% if item.return %}
    *reinterpret_cast<{{item.return}}*>(res) = //
    {% endif %}
    std::invoke(&{{name}}::{{item.name}}, p,
    {% for i in range(length(item.params)) -%}
      {% if not loop.is_last -%}
        a{{loop.index}},
      {%- else -%}
        a{{loop.index}});
      {%- endif %}
    {% endfor -%}

    return None();
  }
{% endfor %}
};

template <>
TypeId TypeId::get({{name}}* /*unused*/) {
  static TypeId id(TheGreatTable::record(Actions(&TypeActions<{{name}}>::reflect,        //
                                                 &CommonActions<{{name}}>::type_name,    //
                                                 &CommonActions<{{name}}>::type_size,    //
                                                 &CommonActions<{{name}}>::call_new,     //
                                                 &CommonActions<{{name}}>::call_delete,  //
                                                 &CommonActions<{{name}}>::copy,         //
                                                 &CommonActions<{{name}}>::move)));
  return id;
}

}  // namespace er

// clang-format on
