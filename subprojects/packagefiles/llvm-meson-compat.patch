diff --git a/clang/cmake/modules/AddClang.cmake b/clang/cmake/modules/AddClang.cmake
index cdc8bd5cd503..14af7860e25a 100644
--- a/clang/cmake/modules/AddClang.cmake
+++ b/clang/cmake/modules/AddClang.cmake
@@ -96,14 +96,6 @@ macro(add_clang_library name)
     else()
       set(LIBTYPE STATIC)
     endif()
-    if(NOT XCODE AND NOT MSVC_IDE)
-      # The Xcode generator doesn't handle object libraries correctly.
-      # The Visual Studio CMake generator does handle object libraries
-      # correctly, but it is preferable to list the libraries with their
-      # source files (instead of the object files and the source files in
-      # a separate target in the "Object Libraries" folder)
-      list(APPEND LIBTYPE OBJECT)
-    endif()
     set_property(GLOBAL APPEND PROPERTY CLANG_STATIC_LIBS ${name})
   endif()
   llvm_add_library(${name} ${LIBTYPE} ${ARG_UNPARSED_ARGUMENTS} ${srcs})
diff --git a/clang/include/clang/AST/ASTFwd.h b/clang/include/clang/AST/ASTFwd.h
index 8823663386ea..6dc1be56ff8d 100644
--- a/clang/include/clang/AST/ASTFwd.h
+++ b/clang/include/clang/AST/ASTFwd.h
@@ -18,13 +18,13 @@ namespace clang {
 
 class Decl;
 #define DECL(DERIVED, BASE) class DERIVED##Decl;
-#include "clang/AST/DeclNodes.inc"
+#include "DeclNodes.inc"
 class Stmt;
 #define STMT(DERIVED, BASE) class DERIVED;
-#include "clang/AST/StmtNodes.inc"
+#include "StmtNodes.inc"
 class Type;
 #define TYPE(DERIVED, BASE) class DERIVED##Type;
-#include "clang/AST/TypeNodes.inc"
+#include "TypeNodes.inc"
 class CXXCtorInitializer;
 class OMPClause;
 #define GEN_CLANG_CLAUSE_CLASS
@@ -32,7 +32,7 @@ class OMPClause;
 #include "llvm/Frontend/OpenMP/OMP.inc"
 class Attr;
 #define ATTR(A) class A##Attr;
-#include "clang/Basic/AttrList.inc"
+#include "AttrList.inc"
 class ObjCProtocolLoc;
 class ConceptReference;
 
diff --git a/clang/include/clang/AST/ASTNodeTraverser.h b/clang/include/clang/AST/ASTNodeTraverser.h
index 3bc0bdff2bdd..24e361c2e773 100644
--- a/clang/include/clang/AST/ASTNodeTraverser.h
+++ b/clang/include/clang/AST/ASTNodeTraverser.h
@@ -988,7 +988,7 @@ public:
   }
 
   // Implements Visit methods for Attrs.
-#include "clang/AST/AttrNodeTraverse.inc"
+#include "AttrNodeTraverse.inc"
 };
 
 } // namespace clang
diff --git a/clang/include/clang/AST/ASTTypeTraits.h b/clang/include/clang/AST/ASTTypeTraits.h
index 3988a15971db..ed44419087f0 100644
--- a/clang/include/clang/AST/ASTTypeTraits.h
+++ b/clang/include/clang/AST/ASTTypeTraits.h
@@ -148,20 +148,20 @@ private:
     NKI_NestedNameSpecifier,
     NKI_Decl,
 #define DECL(DERIVED, BASE) NKI_##DERIVED##Decl,
-#include "clang/AST/DeclNodes.inc"
+#include "DeclNodes.inc"
     NKI_Stmt,
 #define STMT(DERIVED, BASE) NKI_##DERIVED,
-#include "clang/AST/StmtNodes.inc"
+#include "StmtNodes.inc"
     NKI_Type,
 #define TYPE(DERIVED, BASE) NKI_##DERIVED##Type,
-#include "clang/AST/TypeNodes.inc"
+#include "TypeNodes.inc"
     NKI_OMPClause,
 #define GEN_CLANG_CLAUSE_CLASS
 #define CLAUSE_CLASS(Enum, Str, Class) NKI_##Class,
 #include "llvm/Frontend/OpenMP/OMP.inc"
     NKI_Attr,
 #define ATTR(A) NKI_##A##Attr,
-#include "clang/Basic/AttrList.inc"
+#include "AttrList.inc"
     NKI_ObjCProtocolLoc,
     NKI_ConceptReference,
     NKI_NumberOfKinds
@@ -225,16 +225,16 @@ KIND_TO_KIND_ID(ObjCProtocolLoc)
 KIND_TO_KIND_ID(CXXBaseSpecifier)
 KIND_TO_KIND_ID(ConceptReference)
 #define DECL(DERIVED, BASE) KIND_TO_KIND_ID(DERIVED##Decl)
-#include "clang/AST/DeclNodes.inc"
+#include "DeclNodes.inc"
 #define STMT(DERIVED, BASE) KIND_TO_KIND_ID(DERIVED)
-#include "clang/AST/StmtNodes.inc"
+#include "StmtNodes.inc"
 #define TYPE(DERIVED, BASE) KIND_TO_KIND_ID(DERIVED##Type)
-#include "clang/AST/TypeNodes.inc"
+#include "TypeNodes.inc"
 #define GEN_CLANG_CLAUSE_CLASS
 #define CLAUSE_CLASS(Enum, Str, Class) KIND_TO_KIND_ID(Class)
 #include "llvm/Frontend/OpenMP/OMP.inc"
 #define ATTR(A) KIND_TO_KIND_ID(A##Attr)
-#include "clang/Basic/AttrList.inc"
+#include "AttrList.inc"
 #undef KIND_TO_KIND_ID
 
 inline raw_ostream &operator<<(raw_ostream &OS, ASTNodeKind K) {
diff --git a/clang/include/clang/AST/AbstractBasicReader.h b/clang/include/clang/AST/AbstractBasicReader.h
index 4b627c65e276..c56c32c211a9 100644
--- a/clang/include/clang/AST/AbstractBasicReader.h
+++ b/clang/include/clang/AST/AbstractBasicReader.h
@@ -98,7 +98,7 @@ template <class T> inline T *makePointerFromOptional(std::optional<T *> value) {
 // };
 
 // The actual classes are auto-generated; see ClangASTPropertiesEmitter.cpp.
-#include "clang/AST/AbstractBasicReader.inc"
+#include "AbstractBasicReader.inc"
 
 /// DataStreamBasicReader provides convenience implementations for many
 /// BasicReader methods based on the assumption that the
diff --git a/clang/include/clang/AST/AbstractBasicWriter.h b/clang/include/clang/AST/AbstractBasicWriter.h
index b941add8bde8..da7114c11d50 100644
--- a/clang/include/clang/AST/AbstractBasicWriter.h
+++ b/clang/include/clang/AST/AbstractBasicWriter.h
@@ -95,7 +95,7 @@ template <class T> inline std::optional<T *> makeOptionalFromPointer(T *value) {
 // };
 
 // The actual classes are auto-generated; see ClangASTPropertiesEmitter.cpp.
-#include "clang/AST/AbstractBasicWriter.inc"
+#include "AbstractBasicWriter.inc"
 
 /// DataStreamBasicWriter provides convenience implementations for many
 /// BasicWriter methods based on the assumption that the
diff --git a/clang/include/clang/AST/AbstractTypeReader.h b/clang/include/clang/AST/AbstractTypeReader.h
index e44bbf61c0ed..d61eef738e33 100644
--- a/clang/include/clang/AST/AbstractTypeReader.h
+++ b/clang/include/clang/AST/AbstractTypeReader.h
@@ -24,7 +24,7 @@ namespace serialization {
 // };
 //
 // The actual class is auto-generated; see ClangASTPropertiesEmitter.cpp.
-#include "clang/AST/AbstractTypeReader.inc"
+#include "AbstractTypeReader.inc"
 
 } // end namespace serialization
 } // end namespace clang
diff --git a/clang/include/clang/AST/AbstractTypeWriter.h b/clang/include/clang/AST/AbstractTypeWriter.h
index 62006ef0f26e..1aa9eb8f6976 100644
--- a/clang/include/clang/AST/AbstractTypeWriter.h
+++ b/clang/include/clang/AST/AbstractTypeWriter.h
@@ -24,7 +24,7 @@ namespace serialization {
 // };
 //
 // The actual class is auto-generated; see ClangASTPropertiesEmitter.cpp.
-#include "clang/AST/AbstractTypeWriter.inc"
+#include "AbstractTypeWriter.inc"
 
 } // end namespace serialization
 } // end namespace clang
diff --git a/clang/include/clang/AST/Attr.h b/clang/include/clang/AST/Attr.h
index 3365ebe4d901..1fcea18134fc 100644
--- a/clang/include/clang/AST/Attr.h
+++ b/clang/include/clang/AST/Attr.h
@@ -247,7 +247,7 @@ public:
   static bool classof(const Attr *A) {
     return A->getKind() >= attr::FirstParameterABIAttr &&
            A->getKind() <= attr::LastParameterABIAttr;
-   }
+  }
 };
 
 /// A single parameter index whose accessors require each use to make explicit
@@ -261,8 +261,7 @@ class ParamIdx {
   unsigned IsValid : 1;
 
   void assertComparable(const ParamIdx &I) const {
-    assert(isValid() && I.isValid() &&
-           "ParamIdx must be valid to be compared");
+    assert(isValid() && I.isValid() && "ParamIdx must be valid to be compared");
     // It's possible to compare indices from separate functions, but so far
     // it's not proven useful.  Moreover, it might be confusing because a
     // comparison on the results of getASTIndex might be inconsistent with a
@@ -377,7 +376,7 @@ public:
 static_assert(sizeof(ParamIdx) == sizeof(ParamIdx::SerialType),
               "ParamIdx does not fit its serialization type");
 
-#include "clang/AST/Attrs.inc" // IWYU pragma: export
+#include "Attrs.inc"
 
 inline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,
                                              const Attr *At) {
@@ -407,6 +406,6 @@ inline ParameterABI ParameterABIAttr::getABI() const {
     llvm_unreachable("bad parameter ABI attribute kind");
   }
 }
-}  // end namespace clang
+} // end namespace clang
 
 #endif
diff --git a/clang/include/clang/AST/AttrVisitor.h b/clang/include/clang/AST/AttrVisitor.h
index d271db010ed1..89ae72fc05f0 100644
--- a/clang/include/clang/AST/AttrVisitor.h
+++ b/clang/include/clang/AST/AttrVisitor.h
@@ -34,7 +34,7 @@ public:
 #define ATTR(NAME)                                                             \
   case attr::NAME:                                                             \
     DISPATCH(NAME##Attr);
-#include "clang/Basic/AttrList.inc"
+#include "AttrList.inc"
     }
     llvm_unreachable("Attr that isn't part of AttrList.inc!");
   }
@@ -43,7 +43,7 @@ public:
   // method, fall back to the parent.
 #define ATTR(NAME)                                                             \
   RetTy Visit##NAME##Attr(PTR(NAME##Attr) A) { DISPATCH(Attr); }
-#include "clang/Basic/AttrList.inc"
+#include "AttrList.inc"
 
   RetTy VisitAttr(PTR(Attr)) { return RetTy(); }
 
diff --git a/clang/include/clang/AST/Comment.h b/clang/include/clang/AST/Comment.h
index dd9906727293..0a60bbc76bbd 100644
--- a/clang/include/clang/AST/Comment.h
+++ b/clang/include/clang/AST/Comment.h
@@ -57,7 +57,7 @@ enum class CommentKind {
 #define LAST_COMMENT_RANGE(BASE, FIRST, LAST)                                  \
   First##BASE##Constant = FIRST, Last##BASE##Constant = LAST
 #define ABSTRACT_COMMENT(COMMENT)
-#include "clang/AST/CommentNodes.inc"
+#include "CommentNodes.inc"
 };
 
 /// Any part of the comment.
diff --git a/clang/include/clang/AST/CommentCommandTraits.h b/clang/include/clang/AST/CommentCommandTraits.h
index 78c484fff3ae..fbf6c7b5b34a 100644
--- a/clang/include/clang/AST/CommentCommandTraits.h
+++ b/clang/include/clang/AST/CommentCommandTraits.h
@@ -150,7 +150,7 @@ class CommandTraits {
 public:
   enum KnownCommandIDs {
 #define COMMENT_COMMAND(NAME) KCI_##NAME,
-#include "clang/AST/CommentCommandList.inc"
+#include "CommentCommandList.inc"
 #undef COMMENT_COMMAND
     KCI_Last
   };
diff --git a/clang/include/clang/AST/CommentVisitor.h b/clang/include/clang/AST/CommentVisitor.h
index bbb624a23e68..c09a569a06c7 100644
--- a/clang/include/clang/AST/CommentVisitor.h
+++ b/clang/include/clang/AST/CommentVisitor.h
@@ -34,7 +34,7 @@ public:
 #define COMMENT(CLASS, PARENT)                                                 \
   case CommentKind::CLASS:                                                     \
     DISPATCH(CLASS, CLASS);
-#include "clang/AST/CommentNodes.inc"
+#include "CommentNodes.inc"
 #undef ABSTRACT_COMMENT
 #undef COMMENT
     }
@@ -45,7 +45,7 @@ public:
 #define ABSTRACT_COMMENT(COMMENT) COMMENT
 #define COMMENT(CLASS, PARENT)                                                 \
   RetTy visit##CLASS(PTR(CLASS) C, ParamTys... P) { DISPATCH(PARENT, PARENT); }
-#include "clang/AST/CommentNodes.inc"
+#include "CommentNodes.inc"
 #undef ABSTRACT_COMMENT
 #undef COMMENT
 
diff --git a/clang/include/clang/AST/DeclBase.h b/clang/include/clang/AST/DeclBase.h
index 648dae2838e0..088e8b20ca91 100644
--- a/clang/include/clang/AST/DeclBase.h
+++ b/clang/include/clang/AST/DeclBase.h
@@ -93,7 +93,7 @@ public:
         first##BASE = START, last##BASE = END,
 #define LAST_DECL_RANGE(BASE, START, END) \
         first##BASE = START, last##BASE = END
-#include "clang/AST/DeclNodes.inc"
+#include "DeclNodes.inc"
   };
 
   /// A placeholder type used to construct an empty shell of a
diff --git a/clang/include/clang/AST/DeclVisitor.h b/clang/include/clang/AST/DeclVisitor.h
index 8690cdda4bb7..80b293b0137c 100644
--- a/clang/include/clang/AST/DeclVisitor.h
+++ b/clang/include/clang/AST/DeclVisitor.h
@@ -39,7 +39,7 @@ public:
 #define DECL(DERIVED, BASE) \
       case Decl::DERIVED: DISPATCH(DERIVED##Decl, DERIVED##Decl);
 #define ABSTRACT_DECL(DECL)
-#include "clang/AST/DeclNodes.inc"
+#include "DeclNodes.inc"
     }
     llvm_unreachable("Decl that isn't part of DeclNodes.inc!");
   }
@@ -48,7 +48,7 @@ public:
   // method, fall back to the parent.
 #define DECL(DERIVED, BASE) \
   RetTy Visit##DERIVED##Decl(PTR(DERIVED##Decl) D) { DISPATCH(BASE, BASE); }
-#include "clang/AST/DeclNodes.inc"
+#include "DeclNodes.inc"
 
   RetTy VisitDecl(PTR(Decl) D) { return RetTy(); }
 
diff --git a/clang/include/clang/AST/DynamicRecursiveASTVisitor.h b/clang/include/clang/AST/DynamicRecursiveASTVisitor.h
index 4382d2099082..3676d590738a 100644
--- a/clang/include/clang/AST/DynamicRecursiveASTVisitor.h
+++ b/clang/include/clang/AST/DynamicRecursiveASTVisitor.h
@@ -233,32 +233,32 @@ public:
   // Decls.
 #define ABSTRACT_DECL(DECL)
 #define DECL(CLASS, BASE) virtual bool Traverse##CLASS##Decl(CLASS##Decl *D);
-#include "clang/AST/DeclNodes.inc"
+#include "DeclNodes.inc"
 
 #define DECL(CLASS, BASE)                                                      \
   bool WalkUpFrom##CLASS##Decl(CLASS##Decl *D);                                \
   virtual bool Visit##CLASS##Decl(CLASS##Decl *D) { return true; }
-#include "clang/AST/DeclNodes.inc"
+#include "DeclNodes.inc"
 
   // Stmts.
 #define ABSTRACT_STMT(STMT)
 #define STMT(CLASS, PARENT) virtual bool Traverse##CLASS(CLASS *S);
-#include "clang/AST/StmtNodes.inc"
+#include "StmtNodes.inc"
 
 #define STMT(CLASS, PARENT)                                                    \
   bool WalkUpFrom##CLASS(CLASS *S);                                            \
   virtual bool Visit##CLASS(CLASS *S) { return true; }
-#include "clang/AST/StmtNodes.inc"
+#include "StmtNodes.inc"
 
   // Types.
 #define ABSTRACT_TYPE(CLASS, BASE)
 #define TYPE(CLASS, BASE) virtual bool Traverse##CLASS##Type(CLASS##Type *T);
-#include "clang/AST/TypeNodes.inc"
+#include "TypeNodes.inc"
 
 #define TYPE(CLASS, BASE)                                                      \
   bool WalkUpFrom##CLASS##Type(CLASS##Type *T);                                \
   virtual bool Visit##CLASS##Type(CLASS##Type *T) { return true; }
-#include "clang/AST/TypeNodes.inc"
+#include "TypeNodes.inc"
 
   // TypeLocs.
 #define ABSTRACT_TYPELOC(CLASS, BASE)
diff --git a/clang/include/clang/AST/Expr.h b/clang/include/clang/AST/Expr.h
index 7be402264932..698b52c204d4 100644
--- a/clang/include/clang/AST/Expr.h
+++ b/clang/include/clang/AST/Expr.h
@@ -6680,7 +6680,7 @@ public:
   enum AtomicOp {
 #define BUILTIN(ID, TYPE, ATTRS)
 #define ATOMIC_BUILTIN(ID, TYPE, ATTRS) AO ## ID,
-#include "clang/Basic/Builtins.inc"
+#include "Builtins.inc"
     // Avoid trailing comma
     BI_First = 0
   };
@@ -6746,7 +6746,7 @@ public:
 #define ATOMIC_BUILTIN(ID, TYPE, ATTRS)                                        \
   case AO##ID:                                                                 \
     return #ID;
-#include "clang/Basic/Builtins.inc"
+#include "Builtins.inc"
     }
     llvm_unreachable("not an atomic operator?");
   }
diff --git a/clang/include/clang/AST/RecursiveASTVisitor.h b/clang/include/clang/AST/RecursiveASTVisitor.h
index c4a1d03f1b3d..573650413c85 100644
--- a/clang/include/clang/AST/RecursiveASTVisitor.h
+++ b/clang/include/clang/AST/RecursiveASTVisitor.h
@@ -329,7 +329,7 @@ public:
 
 // Declare Traverse* and empty Visit* for all Attr classes.
 #define ATTR_VISITOR_DECLS_ONLY
-#include "clang/AST/AttrVisitor.inc"
+#include "AttrVisitor.inc"
 #undef ATTR_VISITOR_DECLS_ONLY
 
 // ---- Methods on Stmts ----
@@ -368,7 +368,7 @@ public:
 #define ABSTRACT_STMT(STMT)
 #define STMT(CLASS, PARENT) \
   bool Traverse##CLASS(CLASS *S, DataRecursionQueue *Queue = nullptr);
-#include "clang/AST/StmtNodes.inc"
+#include "StmtNodes.inc"
   // The above header #undefs ABSTRACT_STMT and STMT upon exit.
 
   // Define WalkUpFrom*() and empty Visit*() for all Stmt classes.
@@ -381,7 +381,7 @@ public:
     return true;                                                               \
   }                                                                            \
   bool Visit##CLASS(CLASS *S) { return true; }
-#include "clang/AST/StmtNodes.inc"
+#include "StmtNodes.inc"
 
 // ---- Methods on Types ----
 // FIXME: revamp to take TypeLoc's rather than Types.
@@ -389,7 +389,7 @@ public:
 // Declare Traverse*() for all concrete Type classes.
 #define ABSTRACT_TYPE(CLASS, BASE)
 #define TYPE(CLASS, BASE) bool Traverse##CLASS##Type(CLASS##Type *T);
-#include "clang/AST/TypeNodes.inc"
+#include "TypeNodes.inc"
   // The above header #undefs ABSTRACT_TYPE and TYPE upon exit.
 
   // Define WalkUpFrom*() and empty Visit*() for all Type classes.
@@ -402,7 +402,7 @@ public:
     return true;                                                               \
   }                                                                            \
   bool Visit##CLASS##Type(CLASS##Type *T) { return true; }
-#include "clang/AST/TypeNodes.inc"
+#include "TypeNodes.inc"
 
 // ---- Methods on TypeLocs ----
 // FIXME: this currently just calls the matching Type methods
@@ -436,14 +436,14 @@ public:
     return true;                                                               \
   }                                                                            \
   bool Visit##CLASS##TypeLoc(CLASS##TypeLoc TL) { return true; }
-#include "clang/AST/TypeNodes.inc"
+#include "TypeNodes.inc"
 
 // ---- Methods on Decls ----
 
 // Declare Traverse*() for all concrete Decl classes.
 #define ABSTRACT_DECL(DECL)
 #define DECL(CLASS, BASE) bool Traverse##CLASS##Decl(CLASS##Decl *D);
-#include "clang/AST/DeclNodes.inc"
+#include "DeclNodes.inc"
   // The above header #undefs ABSTRACT_DECL and DECL upon exit.
 
   // Define WalkUpFrom*() and empty Visit*() for all Decl classes.
@@ -456,7 +456,7 @@ public:
     return true;                                                               \
   }                                                                            \
   bool Visit##CLASS##Decl(CLASS##Decl *D) { return true; }
-#include "clang/AST/DeclNodes.inc"
+#include "DeclNodes.inc"
 
   bool canIgnoreChildDeclWhileTraversingDeclContext(const Decl *Child);
 
@@ -563,7 +563,7 @@ bool RecursiveASTVisitor<Derived>::dataTraverseNode(Stmt *S,
 #define STMT(CLASS, PARENT)                                                    \
   case Stmt::CLASS##Class:                                                     \
     return TRAVERSE_STMT_BASE(CLASS, CLASS, S, Queue);
-#include "clang/AST/StmtNodes.inc"
+#include "StmtNodes.inc"
   }
 
   return true;
@@ -645,7 +645,7 @@ bool RecursiveASTVisitor<Derived>::PostVisitStmt(Stmt *S) {
         TRY_TO(WalkUpFrom##CLASS(Sem));                                        \
     }                                                                          \
     break;
-#include "clang/AST/StmtNodes.inc"
+#include "StmtNodes.inc"
   }
 
   return true;
@@ -707,7 +707,7 @@ bool RecursiveASTVisitor<Derived>::TraverseType(QualType T) {
   case Type::CLASS:                                                            \
     return getDerived().Traverse##CLASS##Type(                                 \
         static_cast<CLASS##Type *>(const_cast<Type *>(T.getTypePtr())));
-#include "clang/AST/TypeNodes.inc"
+#include "TypeNodes.inc"
   }
 
   return true;
@@ -731,7 +731,7 @@ bool RecursiveASTVisitor<Derived>::TraverseTypeLoc(TypeLoc TL) {
 
 // Define the Traverse*Attr(Attr* A) methods
 #define VISITORCLASS RecursiveASTVisitor
-#include "clang/AST/AttrVisitor.inc"
+#include "AttrVisitor.inc"
 #undef VISITORCLASS
 
 template <typename Derived>
@@ -771,7 +771,7 @@ bool RecursiveASTVisitor<Derived>::TraverseDecl(Decl *D) {
     if (!getDerived().Traverse##CLASS##Decl(static_cast<CLASS##Decl *>(D)))    \
       return false;                                                            \
     break;
-#include "clang/AST/DeclNodes.inc"
+#include "DeclNodes.inc"
   }
   return true;
 }
diff --git a/clang/include/clang/AST/Stmt.h b/clang/include/clang/AST/Stmt.h
index 405c6166adb1..f9fa7205df58 100644
--- a/clang/include/clang/AST/Stmt.h
+++ b/clang/include/clang/AST/Stmt.h
@@ -91,7 +91,7 @@ public:
 #define LAST_STMT_RANGE(BASE, FIRST, LAST) \
         first##BASE##Constant=FIRST##Class, last##BASE##Constant=LAST##Class
 #define ABSTRACT_STMT(STMT)
-#include "clang/AST/StmtNodes.inc"
+#include "StmtNodes.inc"
   };
 
   // Make vanilla 'new' and 'delete' illegal for Stmts.
diff --git a/clang/include/clang/AST/StmtVisitor.h b/clang/include/clang/AST/StmtVisitor.h
index 8b7b728deaff..ea2a3fe33de9 100644
--- a/clang/include/clang/AST/StmtVisitor.h
+++ b/clang/include/clang/AST/StmtVisitor.h
@@ -109,7 +109,7 @@ public:
 #define ABSTRACT_STMT(STMT)
 #define STMT(CLASS, PARENT)                              \
     case Stmt::CLASS ## Class: DISPATCH(CLASS, CLASS);
-#include "clang/AST/StmtNodes.inc"
+#include "StmtNodes.inc"
     }
   }
 
@@ -117,7 +117,7 @@ public:
   // back on VisitExpr or whatever else is the superclass.
 #define STMT(CLASS, PARENT)                                   \
   RetTy Visit ## CLASS(PTR(CLASS) S, ParamTys... P) { DISPATCH(PARENT, PARENT); }
-#include "clang/AST/StmtNodes.inc"
+#include "StmtNodes.inc"
 
   // If the implementation doesn't implement binary operator methods, fall back
   // on VisitBinaryOperator.
diff --git a/clang/include/clang/AST/TextNodeDumper.h b/clang/include/clang/AST/TextNodeDumper.h
index 4aaae48ba8b4..3a913771115d 100644
--- a/clang/include/clang/AST/TextNodeDumper.h
+++ b/clang/include/clang/AST/TextNodeDumper.h
@@ -242,7 +242,7 @@ public:
                                 const comments::FullComment *);
 
 // Implements Visit methods for Attrs.
-#include "clang/AST/AttrTextNodeDump.inc"
+#include "AttrTextNodeDump.inc"
 
   void VisitNullTemplateArgument(const TemplateArgument &TA);
   void VisitTypeTemplateArgument(const TemplateArgument &TA);
diff --git a/clang/include/clang/AST/Type.h b/clang/include/clang/AST/Type.h
index 1d9743520654..2c4b1c71bf7a 100644
--- a/clang/include/clang/AST/Type.h
+++ b/clang/include/clang/AST/Type.h
@@ -71,43 +71,37 @@ class TemplateParameterList;
 class Type;
 class Attr;
 
-enum {
-  TypeAlignmentInBits = 4,
-  TypeAlignment = 1 << TypeAlignmentInBits
-};
+enum { TypeAlignmentInBits = 4, TypeAlignment = 1 << TypeAlignmentInBits };
 
 namespace serialization {
-  template <class T> class AbstractTypeReader;
-  template <class T> class AbstractTypeWriter;
-}
+template <class T> class AbstractTypeReader;
+template <class T> class AbstractTypeWriter;
+} // namespace serialization
 
 } // namespace clang
 
 namespace llvm {
 
-  template <typename T>
-  struct PointerLikeTypeTraits;
-  template<>
-  struct PointerLikeTypeTraits< ::clang::Type*> {
-    static inline void *getAsVoidPointer(::clang::Type *P) { return P; }
+template <typename T> struct PointerLikeTypeTraits;
+template <> struct PointerLikeTypeTraits<::clang::Type *> {
+  static inline void *getAsVoidPointer(::clang::Type *P) { return P; }
 
-    static inline ::clang::Type *getFromVoidPointer(void *P) {
-      return static_cast< ::clang::Type*>(P);
-    }
+  static inline ::clang::Type *getFromVoidPointer(void *P) {
+    return static_cast<::clang::Type *>(P);
+  }
 
-    static constexpr int NumLowBitsAvailable = clang::TypeAlignmentInBits;
-  };
+  static constexpr int NumLowBitsAvailable = clang::TypeAlignmentInBits;
+};
 
-  template<>
-  struct PointerLikeTypeTraits< ::clang::ExtQuals*> {
-    static inline void *getAsVoidPointer(::clang::ExtQuals *P) { return P; }
+template <> struct PointerLikeTypeTraits<::clang::ExtQuals *> {
+  static inline void *getAsVoidPointer(::clang::ExtQuals *P) { return P; }
 
-    static inline ::clang::ExtQuals *getFromVoidPointer(void *P) {
-      return static_cast< ::clang::ExtQuals*>(P);
-    }
+  static inline ::clang::ExtQuals *getFromVoidPointer(void *P) {
+    return static_cast<::clang::ExtQuals *>(P);
+  }
 
-    static constexpr int NumLowBitsAvailable = clang::TypeAlignmentInBits;
-  };
+  static constexpr int NumLowBitsAvailable = clang::TypeAlignmentInBits;
+};
 
 } // namespace llvm
 
@@ -145,7 +139,7 @@ using CanQualType = CanQual<Type>;
 
 // Provide forward declarations for all of the *Type classes.
 #define TYPE(Class, Base) class Class##Type;
-#include "clang/AST/TypeNodes.inc"
+#include "TypeNodes.inc"
 
 /// Pointer-authentication qualifiers.
 class PointerAuthQualifier {
@@ -332,11 +326,7 @@ public:
     CVRMask = Const | Volatile | Restrict
   };
 
-  enum GC {
-    GCNone = 0,
-    Weak,
-    Strong
-  };
+  enum GC { GCNone = 0, Weak, Strong };
 
   enum ObjCLifetime {
     /// There is no lifetime qualification on this type.
@@ -489,9 +479,7 @@ public:
     assert(!(mask & ~CVRMask) && "bitmask contains non-CVR bits");
     Mask &= ~static_cast<uint64_t>(mask);
   }
-  void removeCVRQualifiers() {
-    removeCVRQualifiers(CVRMask);
-  }
+  void removeCVRQualifiers() { removeCVRQualifiers(CVRMask); }
   void addCVRQualifiers(unsigned mask) {
     assert(!(mask & ~CVRMask) && "bitmask contains non-CVR bits");
     Mask |= mask;
@@ -502,9 +490,7 @@ public:
   }
 
   bool hasUnaligned() const { return Mask & UMask; }
-  void setUnaligned(bool flag) {
-    Mask = (Mask & ~UMask) | (flag ? UMask : 0);
-  }
+  void setUnaligned(bool flag) { Mask = (Mask & ~UMask) | (flag ? UMask : 0); }
   void removeUnaligned() { Mask &= ~UMask; }
   void addUnaligned() { Mask |= UMask; }
 
@@ -583,8 +569,8 @@ public:
   }
   void setAddressSpace(LangAS space) {
     assert((unsigned)space <= MaxAddressSpace);
-    Mask = (Mask & ~AddressSpaceMask)
-         | (((uint32_t) space) << AddressSpaceShift);
+    Mask =
+        (Mask & ~AddressSpaceMask) | (((uint32_t)space) << AddressSpaceShift);
   }
   void removeAddressSpace() { setAddressSpace(LangAS::Default); }
   void addAddressSpace(LangAS space) {
@@ -618,9 +604,7 @@ public:
     assert(!(mask & ~FastMask) && "bitmask contains non-fast qualifier bits");
     Mask &= ~static_cast<uint64_t>(mask);
   }
-  void removeFastQualifiers() {
-    removeFastQualifiers(FastMask);
-  }
+  void removeFastQualifiers() { removeFastQualifiers(FastMask); }
   void addFastQualifiers(unsigned mask) {
     assert(!(mask & ~FastMask) && "bitmask contains non-fast qualifier bits");
     Mask |= mask;
@@ -680,12 +664,12 @@ public:
   /// Add the qualifiers from the given set to this set, given that
   /// they don't conflict.
   void addConsistentQualifiers(Qualifiers qs) {
-    assert(getAddressSpace() == qs.getAddressSpace() ||
-           !hasAddressSpace() || !qs.hasAddressSpace());
-    assert(getObjCGCAttr() == qs.getObjCGCAttr() ||
-           !hasObjCGCAttr() || !qs.hasObjCGCAttr());
-    assert(getObjCLifetime() == qs.getObjCLifetime() ||
-           !hasObjCLifetime() || !qs.hasObjCLifetime());
+    assert(getAddressSpace() == qs.getAddressSpace() || !hasAddressSpace() ||
+           !qs.hasAddressSpace());
+    assert(getObjCGCAttr() == qs.getObjCGCAttr() || !hasObjCGCAttr() ||
+           !qs.hasObjCGCAttr());
+    assert(getObjCLifetime() == qs.getObjCLifetime() || !hasObjCLifetime() ||
+           !qs.hasObjCLifetime());
     assert(!hasPointerAuth() || !qs.hasPointerAuth() ||
            getPointerAuth() == qs.getPointerAuth());
     Mask |= qs.Mask;
@@ -872,7 +856,7 @@ struct SplitQualType {
   SplitQualType getSingleStepDesugaredType() const; // end of this file
 
   // Make std::tie work.
-  std::pair<const Type *,Qualifiers> asPair() const {
+  std::pair<const Type *, Qualifiers> asPair() const {
     return std::pair<const Type *, Qualifiers>(Ty, Quals);
   }
 
@@ -931,7 +915,8 @@ class QualType {
 
   // Thankfully, these are efficiently composable.
   llvm::PointerIntPair<llvm::PointerUnion<const Type *, const ExtQuals *>,
-                       Qualifiers::FastWidth> Value;
+                       Qualifiers::FastWidth>
+      Value;
 
   const ExtQuals *getExtQualsUnsafe() const {
     return cast<const ExtQuals *>(Value.getPointer());
@@ -945,7 +930,7 @@ class QualType {
     assert(!isNull() && "Cannot retrieve a NULL type pointer");
     auto CommonPtrVal = reinterpret_cast<uintptr_t>(Value.getOpaqueValue());
     CommonPtrVal &= ~(uintptr_t)((1 << TypeAlignmentInBits) - 1);
-    return reinterpret_cast<ExtQualsTypeCommonBase*>(CommonPtrVal);
+    return reinterpret_cast<ExtQualsTypeCommonBase *>(CommonPtrVal);
   }
 
 public:
@@ -977,25 +962,19 @@ public:
 
   static QualType getFromOpaquePtr(const void *Ptr) {
     QualType T;
-    T.Value.setFromOpaqueValue(const_cast<void*>(Ptr));
+    T.Value.setFromOpaqueValue(const_cast<void *>(Ptr));
     return T;
   }
 
-  const Type &operator*() const {
-    return *getTypePtr();
-  }
+  const Type &operator*() const { return *getTypePtr(); }
 
-  const Type *operator->() const {
-    return getTypePtr();
-  }
+  const Type *operator->() const { return getTypePtr(); }
 
   bool isCanonical() const;
   bool isCanonicalAsParam() const;
 
   /// Return true if this QualType doesn't point to a type yet.
-  bool isNull() const {
-    return Value.getPointer().isNull();
-  }
+  bool isNull() const { return Value.getPointer().isNull(); }
 
   // Determines if a type can form `T&`.
   bool isReferenceable() const;
@@ -1078,15 +1057,13 @@ public:
   /// Retrieve the set of CVR (const-volatile-restrict) qualifiers
   /// local to this particular QualType instance, not including any qualifiers
   /// acquired through typedefs or other sugar.
-  unsigned getLocalCVRQualifiers() const {
-    return getLocalFastQualifiers();
-  }
+  unsigned getLocalCVRQualifiers() const { return getLocalFastQualifiers(); }
 
   /// Retrieve the set of CVR (const-volatile-restrict) qualifiers
   /// applied to this type.
   unsigned getCVRQualifiers() const;
 
-  bool isConstant(const ASTContext& Ctx) const {
+  bool isConstant(const ASTContext &Ctx) const {
     return QualType::isConstant(*this, Ctx);
   }
 
@@ -1148,25 +1125,17 @@ public:
   // easily added.
 
   /// Add the `const` type qualifier to this QualType.
-  void addConst() {
-    addFastQualifiers(Qualifiers::Const);
-  }
-  QualType withConst() const {
-    return withFastQualifiers(Qualifiers::Const);
-  }
+  void addConst() { addFastQualifiers(Qualifiers::Const); }
+  QualType withConst() const { return withFastQualifiers(Qualifiers::Const); }
 
   /// Add the `volatile` type qualifier to this QualType.
-  void addVolatile() {
-    addFastQualifiers(Qualifiers::Volatile);
-  }
+  void addVolatile() { addFastQualifiers(Qualifiers::Volatile); }
   QualType withVolatile() const {
     return withFastQualifiers(Qualifiers::Volatile);
   }
 
   /// Add the `restrict` qualifier to this QualType.
-  void addRestrict() {
-    addFastQualifiers(Qualifiers::Restrict);
-  }
+  void addRestrict() { addFastQualifiers(Qualifiers::Restrict); }
   QualType withRestrict() const {
     return withFastQualifiers(Qualifiers::Restrict);
   }
@@ -1176,8 +1145,8 @@ public:
   }
 
   void addFastQualifiers(unsigned TQs) {
-    assert(!(TQs & ~Qualifiers::FastMask)
-           && "non-fast qualifier bits set in mask!");
+    assert(!(TQs & ~Qualifiers::FastMask) &&
+           "non-fast qualifier bits set in mask!");
     Value.setInt(Value.getInt() | TQs);
   }
 
@@ -1344,9 +1313,8 @@ public:
     return print(split.Ty, split.Quals, OS, policy, PlaceHolder, Indentation);
   }
 
-  static void print(const Type *ty, Qualifiers qs,
-                    raw_ostream &OS, const PrintingPolicy &policy,
-                    const Twine &PlaceHolder,
+  static void print(const Type *ty, Qualifiers qs, raw_ostream &OS,
+                    const PrintingPolicy &policy, const Twine &PlaceHolder,
                     unsigned Indentation = 0);
 
   void getAsStringInternal(std::string &Str,
@@ -1420,14 +1388,10 @@ public:
   inline Qualifiers::GC getObjCGCAttr() const;
 
   /// true when Type is objc's weak.
-  bool isObjCGCWeak() const {
-    return getObjCGCAttr() == Qualifiers::Weak;
-  }
+  bool isObjCGCWeak() const { return getObjCGCAttr() == Qualifiers::Weak; }
 
   /// true when Type is objc's strong.
-  bool isObjCGCStrong() const {
-    return getObjCGCAttr() == Qualifiers::Strong;
-  }
+  bool isObjCGCStrong() const { return getObjCGCAttr() == Qualifiers::Strong; }
 
   /// Returns lifetime attribute of this type.
   Qualifiers::ObjCLifetime getObjCLifetime() const {
@@ -1574,8 +1538,7 @@ public:
   /// \param context The context in which the subject type was written.
   ///
   /// \returns the resulting type.
-  QualType substObjCTypeArgs(ASTContext &ctx,
-                             ArrayRef<QualType> typeArgs,
+  QualType substObjCTypeArgs(ASTContext &ctx, ArrayRef<QualType> typeArgs,
                              ObjCSubstitutionContext context) const;
 
   /// Substitute type arguments from an object type for the Objective-C type
@@ -1598,8 +1561,7 @@ public:
   ///
   /// \returns the subject type after replacing all of the Objective-C type
   /// parameters with their corresponding arguments.
-  QualType substObjCMemberType(QualType objectType,
-                               const DeclContext *dc,
+  QualType substObjCMemberType(QualType objectType, const DeclContext *dc,
                                ObjCSubstitutionContext context) const;
 
   /// Strip Objective-C "__kindof" types from the given type.
@@ -1616,7 +1578,7 @@ private:
   // These methods are implemented in a separate translation unit;
   // "static"-ize them to avoid creating temporary QualTypes in the
   // caller.
-  static bool isConstant(QualType T, const ASTContext& Ctx);
+  static bool isConstant(QualType T, const ASTContext &Ctx);
   static QualType getDesugaredType(QualType T, const ASTContext &Context);
   static SplitQualType getSplitDesugaredType(QualType T);
   static SplitQualType getSplitUnqualifiedTypeImpl(QualType type);
@@ -1626,7 +1588,8 @@ private:
   static DestructionKind isDestructedTypeImpl(QualType type);
 
   /// Check if \param RD is or contains a non-trivial C union.
-  static bool hasNonTrivialToPrimitiveDefaultInitializeCUnion(const RecordDecl *RD);
+  static bool
+  hasNonTrivialToPrimitiveDefaultInitializeCUnion(const RecordDecl *RD);
   static bool hasNonTrivialToPrimitiveDestructCUnion(const RecordDecl *RD);
   static bool hasNonTrivialToPrimitiveCopyCUnion(const RecordDecl *RD);
 };
@@ -1639,7 +1602,7 @@ namespace llvm {
 
 /// Implement simplify_type for QualType, so that we can dyn_cast from QualType
 /// to a specific Type class.
-template<> struct simplify_type< ::clang::QualType> {
+template <> struct simplify_type<::clang::QualType> {
   using SimpleType = const ::clang::Type *;
 
   static SimpleType getSimplifiedValue(::clang::QualType Val) {
@@ -1648,8 +1611,7 @@ template<> struct simplify_type< ::clang::QualType> {
 };
 
 // Teach SmallPtrSet that QualType is "basically a pointer".
-template<>
-struct PointerLikeTypeTraits<clang::QualType> {
+template <> struct PointerLikeTypeTraits<clang::QualType> {
   static inline void *getAsVoidPointer(clang::QualType P) {
     return P.getAsOpaquePtr();
   }
@@ -1725,10 +1687,10 @@ public:
       : ExtQualsTypeCommonBase(baseType,
                                canon.isNull() ? QualType(this_(), 0) : canon),
         Quals(quals) {
-    assert(Quals.hasNonFastQualifiers()
-           && "ExtQuals created with no fast qualifiers");
-    assert(!Quals.hasFastQualifiers()
-           && "ExtQuals created with fast qualifiers");
+    assert(Quals.hasNonFastQualifiers() &&
+           "ExtQuals created with no fast qualifiers");
+    assert(!Quals.hasFastQualifiers() &&
+           "ExtQuals created with fast qualifiers");
   }
 
   Qualifiers getQualifiers() const { return Quals; }
@@ -1751,8 +1713,7 @@ public:
     Profile(ID, getBaseType(), Quals);
   }
 
-  static void Profile(llvm::FoldingSetNodeID &ID,
-                      const Type *BaseType,
+  static void Profile(llvm::FoldingSetNodeID &ID, const Type *BaseType,
                       Qualifiers Quals) {
     assert(!Quals.hasFastQualifiers() && "fast qualifiers in ExtQuals hash!");
     ID.AddPointer(BaseType);
@@ -1831,7 +1792,7 @@ public:
 #define TYPE(Class, Base) Class,
 #define LAST_TYPE(Class) TypeLast = Class
 #define ABSTRACT_TYPE(Class, Base)
-#include "clang/AST/TypeNodes.inc"
+#include "TypeNodes.inc"
   };
 
 private:
@@ -1865,9 +1826,7 @@ private:
     LLVM_PREFERRED_TYPE(bool)
     mutable unsigned FromAST : 1;
 
-    bool isCacheValid() const {
-      return CacheValid;
-    }
+    bool isCacheValid() const { return CacheValid; }
 
     Linkage getLinkage() const {
       assert(isCacheValid() && "getting linkage from invalid cache");
@@ -2286,7 +2245,7 @@ protected:
     SubstTemplateTypeParmPackTypeBitfields SubstTemplateTypeParmPackTypeBits;
     TemplateSpecializationTypeBitfields TemplateSpecializationTypeBits;
     DependentTemplateSpecializationTypeBitfields
-      DependentTemplateSpecializationTypeBits;
+        DependentTemplateSpecializationTypeBits;
     PackExpansionTypeBitfields PackExpansionTypeBits;
     CountAttributedTypeBitfields CountAttributedTypeBits;
   };
@@ -2295,9 +2254,7 @@ private:
   template <class T> friend class TypePropertyCache;
 
   /// Set whether this type comes from an AST file.
-  void setFromAST(bool V = true) const {
-    TypeBits.FromAST = V;
-  }
+  void setFromAST(bool V = true) const { TypeBits.FromAST = V; }
 
 protected:
   friend class ASTContext;
@@ -2438,9 +2395,7 @@ public:
 
   /// Return true if this is an incomplete or object
   /// type, in other words, not a function type.
-  bool isIncompleteOrObjectType() const {
-    return !isFunctionType();
-  }
+  bool isIncompleteOrObjectType() const { return !isFunctionType(); }
 
   /// Determine whether this type is an object type.
   bool isObjectType() const {
@@ -2485,7 +2440,7 @@ public:
 
   /// isIntegerType() does *not* include complex integers (a GCC extension).
   /// isComplexIntegerType() can be used to test for complex integers.
-  bool isIntegerType() const;     // C99 6.2.5p17 (int, char, bool, enum)
+  bool isIntegerType() const; // C99 6.2.5p17 (int, char, bool, enum)
   bool isEnumeralType() const;
 
   /// Determine whether this type is a scoped enumeration type.
@@ -2510,21 +2465,21 @@ public:
   bool isRealFloatingType() const; // C99 6.2.5p10 (float, double, long double)
   /// isComplexType() does *not* include complex integers (a GCC extension).
   /// isComplexIntegerType() can be used to test for complex integers.
-  bool isComplexType() const;      // C99 6.2.5p11 (complex)
-  bool isAnyComplexType() const;   // C99 6.2.5p11 (complex) + Complex Int.
-  bool isFloatingType() const;     // C99 6.2.5p11 (real floating + complex)
-  bool isHalfType() const;         // OpenCL 6.1.1.1, NEON (IEEE 754-2008 half)
-  bool isFloat16Type() const;      // C11 extension ISO/IEC TS 18661
+  bool isComplexType() const;    // C99 6.2.5p11 (complex)
+  bool isAnyComplexType() const; // C99 6.2.5p11 (complex) + Complex Int.
+  bool isFloatingType() const;   // C99 6.2.5p11 (real floating + complex)
+  bool isHalfType() const;       // OpenCL 6.1.1.1, NEON (IEEE 754-2008 half)
+  bool isFloat16Type() const;    // C11 extension ISO/IEC TS 18661
   bool isFloat32Type() const;
   bool isDoubleType() const;
   bool isBFloat16Type() const;
   bool isMFloat8Type() const;
   bool isFloat128Type() const;
   bool isIbm128Type() const;
-  bool isRealType() const;         // C99 6.2.5p17 (real floating + integer)
-  bool isArithmeticType() const;   // C99 6.2.5p18 (integer + floating)
-  bool isVoidType() const;         // C99 6.2.5p19
-  bool isScalarType() const;       // C99 6.2.5p21 (arithmetic + pointers)
+  bool isRealType() const;       // C99 6.2.5p17 (real floating + integer)
+  bool isArithmeticType() const; // C99 6.2.5p18 (integer + floating)
+  bool isVoidType() const;       // C99 6.2.5p19
+  bool isScalarType() const;     // C99 6.2.5p21 (arithmetic + pointers)
   bool isAggregateType() const;
   bool isFundamentalType() const;
   bool isCompoundType() const;
@@ -2537,7 +2492,7 @@ public:
   bool isPointerType() const;
   bool isPointerOrReferenceType() const;
   bool isSignableType() const;
-  bool isAnyPointerType() const;   // Any C pointer or ObjC object pointer
+  bool isAnyPointerType() const; // Any C pointer or ObjC object pointer
   bool isCountAttributedType() const;
   bool isBlockPointerType() const;
   bool isVoidPointerType() const;
@@ -2564,28 +2519,30 @@ public:
   bool isInterfaceType() const;
   bool isStructureOrClassType() const;
   bool isUnionType() const;
-  bool isComplexIntegerType() const;            // GCC _Complex integer type.
-  bool isVectorType() const;                    // GCC vector type.
-  bool isExtVectorType() const;                 // Extended vector type.
-  bool isExtVectorBoolType() const;             // Extended vector type with bool element.
+  bool isComplexIntegerType() const; // GCC _Complex integer type.
+  bool isVectorType() const;         // GCC vector type.
+  bool isExtVectorType() const;      // Extended vector type.
+  bool isExtVectorBoolType() const;  // Extended vector type with bool element.
   bool isSubscriptableVectorType() const;
-  bool isMatrixType() const;                    // Matrix type.
-  bool isConstantMatrixType() const;            // Constant matrix type.
-  bool isDependentAddressSpaceType() const;     // value-dependent address space qualifier
-  bool isObjCObjectPointerType() const;         // pointer to ObjC object
-  bool isObjCRetainableType() const;            // ObjC object or block pointer
-  bool isObjCLifetimeType() const;              // (array of)* retainable type
-  bool isObjCIndirectLifetimeType() const;      // (pointer to)* lifetime type
-  bool isObjCNSObjectType() const;              // __attribute__((NSObject))
-  bool isObjCIndependentClassType() const;      // __attribute__((objc_independent_class))
+  bool isMatrixType() const;         // Matrix type.
+  bool isConstantMatrixType() const; // Constant matrix type.
+  bool isDependentAddressSpaceType()
+      const; // value-dependent address space qualifier
+  bool isObjCObjectPointerType() const;    // pointer to ObjC object
+  bool isObjCRetainableType() const;       // ObjC object or block pointer
+  bool isObjCLifetimeType() const;         // (array of)* retainable type
+  bool isObjCIndirectLifetimeType() const; // (pointer to)* lifetime type
+  bool isObjCNSObjectType() const;         // __attribute__((NSObject))
+  bool
+  isObjCIndependentClassType() const; // __attribute__((objc_independent_class))
   // FIXME: change this to 'raw' interface type, so we can used 'interface' type
   // for the common case.
-  bool isObjCObjectType() const;                // NSString or typeof(*(id)0)
-  bool isObjCQualifiedInterfaceType() const;    // NSString<foo>
-  bool isObjCQualifiedIdType() const;           // id<foo>
-  bool isObjCQualifiedClassType() const;        // Class<foo>
+  bool isObjCObjectType() const;             // NSString or typeof(*(id)0)
+  bool isObjCQualifiedInterfaceType() const; // NSString<foo>
+  bool isObjCQualifiedIdType() const;        // id<foo>
+  bool isObjCQualifiedClassType() const;     // Class<foo>
   bool isObjCObjectOrInterfaceType() const;
-  bool isObjCIdType() const;                    // id
+  bool isObjCIdType() const; // id
   bool isDecltypeType() const;
   /// Was this type written with the special inert-in-ARC __unsafe_unretained
   /// qualifier?
@@ -2607,7 +2564,7 @@ public:
   bool isObjCIdOrObjectKindOfType(const ASTContext &ctx,
                                   const ObjCObjectType *&bound) const;
 
-  bool isObjCClassType() const;                 // Class
+  bool isObjCClassType() const; // Class
 
   /// Whether the type is Objective-C 'Class' or a __kindof type of an
   /// Class type, e.g., __kindof Class <NSCopying>.
@@ -2618,47 +2575,46 @@ public:
   bool isObjCClassOrClassKindOfType() const;
 
   bool isBlockCompatibleObjCPointerType(ASTContext &ctx) const;
-  bool isObjCSelType() const;                 // Class
-  bool isObjCBuiltinType() const;               // 'id' or 'Class'
+  bool isObjCSelType() const;     // Class
+  bool isObjCBuiltinType() const; // 'id' or 'Class'
   bool isObjCARCBridgableType() const;
   bool isCARCBridgableType() const;
-  bool isTemplateTypeParmType() const;          // C++ template type parameter
-  bool isNullPtrType() const;                   // C++11 std::nullptr_t or
-                                                // C23   nullptr_t
-  bool isNothrowT() const;                      // C++   std::nothrow_t
-  bool isAlignValT() const;                     // C++17 std::align_val_t
-  bool isStdByteType() const;                   // C++17 std::byte
-  bool isAtomicType() const;                    // C11 _Atomic()
-  bool isUndeducedAutoType() const;             // C++11 auto or
-                                                // C++14 decltype(auto)
-  bool isTypedefNameType() const;               // typedef or alias template
-
-#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  bool isTemplateTypeParmType() const; // C++ template type parameter
+  bool isNullPtrType() const;          // C++11 std::nullptr_t or
+                                       // C23   nullptr_t
+  bool isNothrowT() const;             // C++   std::nothrow_t
+  bool isAlignValT() const;            // C++17 std::align_val_t
+  bool isStdByteType() const;          // C++17 std::byte
+  bool isAtomicType() const;           // C11 _Atomic()
+  bool isUndeducedAutoType() const;    // C++11 auto or
+                                       // C++14 decltype(auto)
+  bool isTypedefNameType() const;      // typedef or alias template
+
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix)                   \
   bool is##Id##Type() const;
 #include "clang/Basic/OpenCLImageTypes.def"
 
-  bool isImageType() const;                     // Any OpenCL image type
+  bool isImageType() const; // Any OpenCL image type
 
-  bool isSamplerT() const;                      // OpenCL sampler_t
-  bool isEventT() const;                        // OpenCL event_t
-  bool isClkEventT() const;                     // OpenCL clk_event_t
-  bool isQueueT() const;                        // OpenCL queue_t
-  bool isReserveIDT() const;                    // OpenCL reserve_id_t
+  bool isSamplerT() const;   // OpenCL sampler_t
+  bool isEventT() const;     // OpenCL event_t
+  bool isClkEventT() const;  // OpenCL clk_event_t
+  bool isQueueT() const;     // OpenCL queue_t
+  bool isReserveIDT() const; // OpenCL reserve_id_t
 
-#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \
-  bool is##Id##Type() const;
+#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) bool is##Id##Type() const;
 #include "clang/Basic/OpenCLExtensionTypes.def"
   // Type defined in cl_intel_device_side_avc_motion_estimation OpenCL extension
   bool isOCLIntelSubgroupAVCType() const;
-  bool isOCLExtOpaqueType() const;              // Any OpenCL extension type
+  bool isOCLExtOpaqueType() const; // Any OpenCL extension type
 
-  bool isPipeType() const;                      // OpenCL pipe type
-  bool isBitIntType() const;                    // Bit-precise integer type
-  bool isOpenCLSpecificType() const;            // Any OpenCL specific type
+  bool isPipeType() const;           // OpenCL pipe type
+  bool isBitIntType() const;         // Bit-precise integer type
+  bool isOpenCLSpecificType() const; // Any OpenCL specific type
 
 #define HLSL_INTANGIBLE_TYPE(Name, Id, SingletonId) bool is##Id##Type() const;
 #include "clang/Basic/HLSLIntangibleTypes.def"
-  bool isHLSLSpecificType() const; // Any HLSL specific type
+  bool isHLSLSpecificType() const;          // Any HLSL specific type
   bool isHLSLBuiltinIntangibleType() const; // Any HLSL builtin intangible type
   bool isHLSLAttributedResourceType() const;
   bool isHLSLIntangibleType()
@@ -2987,9 +2943,7 @@ public:
 
   const char *getTypeClassName() const;
 
-  QualType getCanonicalTypeInternal() const {
-    return CanonicalType;
-  }
+  QualType getCanonicalTypeInternal() const { return CanonicalType; }
 
   CanQualType getCanonicalTypeUnqualified() const; // in CanonicalType.h
   void dump() const;
@@ -3021,14 +2975,14 @@ template <> const CountAttributedType *Type::getAs() const;
 // We can do canonical leaf types faster, because we don't have to
 // worry about preserving child type decoration.
 #define TYPE(Class, Base)
-#define LEAF_TYPE(Class) \
-template <> inline const Class##Type *Type::getAs() const { \
-  return dyn_cast<Class##Type>(CanonicalType); \
-} \
-template <> inline const Class##Type *Type::castAs() const { \
-  return cast<Class##Type>(CanonicalType); \
-}
-#include "clang/AST/TypeNodes.inc"
+#define LEAF_TYPE(Class)                                                       \
+  template <> inline const Class##Type *Type::getAs() const {                  \
+    return dyn_cast<Class##Type>(CanonicalType);                               \
+  }                                                                            \
+  template <> inline const Class##Type *Type::castAs() const {                 \
+    return cast<Class##Type>(CanonicalType);                                   \
+  }
+#include "TypeNodes.inc"
 
 /// This class is used for builtin types like 'int'.  Builtin
 /// types are always canonical and have a literal name field.
@@ -3093,9 +3047,7 @@ public:
   bool isSugared() const { return false; }
   QualType desugar() const { return QualType(this, 0); }
 
-  bool isInteger() const {
-    return getKind() >= Bool && getKind() <= Int128;
-  }
+  bool isInteger() const { return getKind() >= Bool && getKind() <= Int128; }
 
   bool isSignedInteger() const {
     return getKind() >= Char_S && getKind() <= Int128;
@@ -3114,16 +3066,12 @@ public:
   bool isSVECount() const { return getKind() == Kind::SveCount; }
 
   /// Determines whether the given kind corresponds to a placeholder type.
-  static bool isPlaceholderTypeKind(Kind K) {
-    return K >= Overload;
-  }
+  static bool isPlaceholderTypeKind(Kind K) { return K >= Overload; }
 
   /// Determines whether this type is a placeholder type, i.e. a type
   /// which cannot appear in arbitrary positions in a fully-formed
   /// expression.
-  bool isPlaceholderType() const {
-    return isPlaceholderTypeKind(getKind());
-  }
+  bool isPlaceholderType() const { return isPlaceholderTypeKind(getKind()); }
 
   /// Determines whether this type is a placeholder type other than
   /// Overload.  Most placeholder types require only syntactic
@@ -3134,9 +3082,7 @@ public:
   /// from their context, like whether the context expects a
   /// specific function-pointer type, and so frequently need
   /// special treatment.
-  bool isNonOverloadPlaceholderType() const {
-    return getKind() > Overload;
-  }
+  bool isNonOverloadPlaceholderType() const { return getKind() > Overload; }
 
   static bool classof(const Type *T) { return T->getTypeClass() == Builtin; }
 };
@@ -3158,9 +3104,7 @@ public:
   bool isSugared() const { return false; }
   QualType desugar() const { return QualType(this, 0); }
 
-  void Profile(llvm::FoldingSetNodeID &ID) {
-    Profile(ID, getElementType());
-  }
+  void Profile(llvm::FoldingSetNodeID &ID) { Profile(ID, getElementType()); }
 
   static void Profile(llvm::FoldingSetNodeID &ID, QualType Element) {
     ID.AddPointer(Element.getAsOpaquePtr());
@@ -3184,9 +3128,7 @@ public:
   bool isSugared() const { return true; }
   QualType desugar() const { return getInnerType(); }
 
-  void Profile(llvm::FoldingSetNodeID &ID) {
-    Profile(ID, getInnerType());
-  }
+  void Profile(llvm::FoldingSetNodeID &ID) { Profile(ID, getInnerType()); }
 
   static void Profile(llvm::FoldingSetNodeID &ID, QualType Inner) {
     Inner.Profile(ID);
@@ -3211,9 +3153,7 @@ public:
   bool isSugared() const { return false; }
   QualType desugar() const { return QualType(this, 0); }
 
-  void Profile(llvm::FoldingSetNodeID &ID) {
-    Profile(ID, getPointeeType());
-  }
+  void Profile(llvm::FoldingSetNodeID &ID) { Profile(ID, getPointeeType()); }
 
   static void Profile(llvm::FoldingSetNodeID &ID, QualType Pointee) {
     ID.AddPointer(Pointee.getAsOpaquePtr());
@@ -3392,8 +3332,8 @@ public:
 class DecayedType : public AdjustedType {
   friend class ASTContext; // ASTContext creates these.
 
-  inline
-  DecayedType(QualType OriginalType, QualType Decayed, QualType Canonical);
+  inline DecayedType(QualType OriginalType, QualType Decayed,
+                     QualType Canonical);
 
 public:
   QualType getDecayedType() const { return getAdjustedType(); }
@@ -3423,12 +3363,10 @@ public:
   bool isSugared() const { return false; }
   QualType desugar() const { return QualType(this, 0); }
 
-  void Profile(llvm::FoldingSetNodeID &ID) {
-      Profile(ID, getPointeeType());
-  }
+  void Profile(llvm::FoldingSetNodeID &ID) { Profile(ID, getPointeeType()); }
 
   static void Profile(llvm::FoldingSetNodeID &ID, QualType Pointee) {
-      ID.AddPointer(Pointee.getAsOpaquePtr());
+    ID.AddPointer(Pointee.getAsOpaquePtr());
   }
 
   static bool classof(const Type *T) {
@@ -3467,8 +3405,7 @@ public:
     Profile(ID, PointeeType, isSpelledAsLValue());
   }
 
-  static void Profile(llvm::FoldingSetNodeID &ID,
-                      QualType Referencee,
+  static void Profile(llvm::FoldingSetNodeID &ID, QualType Referencee,
                       bool SpelledAsLValue) {
     ID.AddPointer(Referencee.getAsOpaquePtr());
     ID.AddBoolean(SpelledAsLValue);
@@ -3503,7 +3440,7 @@ class RValueReferenceType : public ReferenceType {
   friend class ASTContext; // ASTContext creates these
 
   RValueReferenceType(QualType Referencee, QualType CanonicalRef)
-       : ReferenceType(RValueReference, Referencee, CanonicalRef, false) {}
+      : ReferenceType(RValueReference, Referencee, CanonicalRef, false) {}
 
 public:
   bool isSugared() const { return false; }
@@ -3765,8 +3702,8 @@ public:
 class IncompleteArrayType : public ArrayType {
   friend class ASTContext; // ASTContext creates these.
 
-  IncompleteArrayType(QualType et, QualType can,
-                      ArraySizeModifier sm, unsigned tq)
+  IncompleteArrayType(QualType et, QualType can, ArraySizeModifier sm,
+                      unsigned tq)
       : ArrayType(IncompleteArray, et, can, sm, tq) {}
 
 public:
@@ -3816,11 +3753,10 @@ class VariableArrayType : public ArrayType {
   /// The range spanned by the left and right array brackets.
   SourceRange Brackets;
 
-  VariableArrayType(QualType et, QualType can, Expr *e,
-                    ArraySizeModifier sm, unsigned tq,
-                    SourceRange brackets)
-      : ArrayType(VariableArray, et, can, sm, tq, e),
-        SizeExpr((Stmt*) e), Brackets(brackets) {}
+  VariableArrayType(QualType et, QualType can, Expr *e, ArraySizeModifier sm,
+                    unsigned tq, SourceRange brackets)
+      : ArrayType(VariableArray, et, can, sm, tq, e), SizeExpr((Stmt *)e),
+        Brackets(brackets) {}
 
 public:
   friend class StmtIteratorBase;
@@ -3828,7 +3764,7 @@ public:
   Expr *getSizeExpr() const {
     // We use C-style casts instead of cast<> here because we do not wish
     // to have a dependency of Type.h on Stmt.h/Expr.h.
-    return (Expr*) SizeExpr;
+    return (Expr *)SizeExpr;
   }
 
   SourceRange getBracketsRange() const { return Brackets; }
@@ -3883,7 +3819,7 @@ public:
   Expr *getSizeExpr() const {
     // We use C-style casts instead of cast<> here because we do not wish
     // to have a dependency of Type.h on Stmt.h/Expr.h.
-    return (Expr*) SizeExpr;
+    return (Expr *)SizeExpr;
   }
 
   SourceRange getBracketsRange() const { return Brackets; }
@@ -3898,8 +3834,8 @@ public:
   }
 
   void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context) {
-    Profile(ID, Context, getElementType(),
-            getSizeModifier(), getIndexTypeCVRQualifiers(), getSizeExpr());
+    Profile(ID, Context, getElementType(), getSizeModifier(),
+            getIndexTypeCVRQualifiers(), getSizeExpr());
   }
 
   static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,
@@ -3909,7 +3845,8 @@ public:
 
 /// Represents an extended address space qualifier where the input address space
 /// value is dependent. Non-dependent address spaces are not represented with a
-/// special Type subclass; they are stored on an ExtQuals node as part of a QualType.
+/// special Type subclass; they are stored on an ExtQuals node as part of a
+/// QualType.
 ///
 /// For example:
 /// \code
@@ -4057,8 +3994,8 @@ public:
   }
 
   void Profile(llvm::FoldingSetNodeID &ID) {
-    Profile(ID, getElementType(), getNumElements(),
-            getTypeClass(), getVectorKind());
+    Profile(ID, getElementType(), getNumElements(), getTypeClass(),
+            getVectorKind());
   }
 
   static void Profile(llvm::FoldingSetNodeID &ID, QualType ElementType,
@@ -4134,39 +4071,65 @@ class ExtVectorType : public VectorType {
 public:
   static int getPointAccessorIdx(char c) {
     switch (c) {
-    default: return -1;
-    case 'x': case 'r': return 0;
-    case 'y': case 'g': return 1;
-    case 'z': case 'b': return 2;
-    case 'w': case 'a': return 3;
+    default:
+      return -1;
+    case 'x':
+    case 'r':
+      return 0;
+    case 'y':
+    case 'g':
+      return 1;
+    case 'z':
+    case 'b':
+      return 2;
+    case 'w':
+    case 'a':
+      return 3;
     }
   }
 
   static int getNumericAccessorIdx(char c) {
     switch (c) {
-      default: return -1;
-      case '0': return 0;
-      case '1': return 1;
-      case '2': return 2;
-      case '3': return 3;
-      case '4': return 4;
-      case '5': return 5;
-      case '6': return 6;
-      case '7': return 7;
-      case '8': return 8;
-      case '9': return 9;
-      case 'A':
-      case 'a': return 10;
-      case 'B':
-      case 'b': return 11;
-      case 'C':
-      case 'c': return 12;
-      case 'D':
-      case 'd': return 13;
-      case 'E':
-      case 'e': return 14;
-      case 'F':
-      case 'f': return 15;
+    default:
+      return -1;
+    case '0':
+      return 0;
+    case '1':
+      return 1;
+    case '2':
+      return 2;
+    case '3':
+      return 3;
+    case '4':
+      return 4;
+    case '5':
+      return 5;
+    case '6':
+      return 6;
+    case '7':
+      return 7;
+    case '8':
+      return 8;
+    case '9':
+      return 9;
+    case 'A':
+    case 'a':
+      return 10;
+    case 'B':
+    case 'b':
+      return 11;
+    case 'C':
+    case 'c':
+      return 12;
+    case 'D':
+    case 'd':
+      return 13;
+    case 'E':
+    case 'e':
+      return 14;
+    case 'F':
+    case 'f':
+      return 15;
     }
   }
 
@@ -4178,17 +4141,15 @@ public:
   }
 
   bool isAccessorWithinNumElements(char c, bool isNumericAccessor) const {
-    if (int idx = getAccessorIdx(c, isNumericAccessor)+1)
-      return unsigned(idx-1) < getNumElements();
+    if (int idx = getAccessorIdx(c, isNumericAccessor) + 1)
+      return unsigned(idx - 1) < getNumElements();
     return false;
   }
 
   bool isSugared() const { return false; }
   QualType desugar() const { return QualType(this, 0); }
 
-  static bool classof(const Type *T) {
-    return T->getTypeClass() == ExtVector;
-  }
+  static bool classof(const Type *T) { return T->getTypeClass() == ExtVector; }
 };
 
 /// Represents a matrix type, as defined in the Matrix Types clang extensions.
@@ -4445,10 +4406,7 @@ public:
     enum { NoReturnMask = 0x20 };
     enum { ProducesResultMask = 0x40 };
     enum { NoCallerSavedRegsMask = 0x80 };
-    enum {
-      RegParmMask =  0x700,
-      RegParmOffset = 8
-    };
+    enum { RegParmMask = 0x700, RegParmOffset = 8 };
     enum { NoCfCheckMask = 0x800 };
     enum { CmseNSCallMask = 0x1000 };
     uint16_t Bits = CC_C;
@@ -4483,7 +4441,9 @@ public:
     bool getCmseNSCall() const { return Bits & CmseNSCallMask; }
     bool getNoCallerSavedRegs() const { return Bits & NoCallerSavedRegsMask; }
     bool getNoCfCheck() const { return Bits & NoCfCheckMask; }
-    bool getHasRegParm() const { return ((Bits & RegParmMask) >> RegParmOffset) != 0; }
+    bool getHasRegParm() const {
+      return ((Bits & RegParmMask) >> RegParmOffset) != 0;
+    }
 
     unsigned getRegParm() const {
       unsigned RegParm = (Bits & RegParmMask) >> RegParmOffset;
@@ -4494,12 +4454,8 @@ public:
 
     CallingConv getCC() const { return CallingConv(Bits & CallConvMask); }
 
-    bool operator==(ExtInfo Other) const {
-      return Bits == Other.Bits;
-    }
-    bool operator!=(ExtInfo Other) const {
-      return Bits != Other.Bits;
-    }
+    bool operator==(ExtInfo Other) const { return Bits == Other.Bits; }
+    bool operator!=(ExtInfo Other) const { return Bits != Other.Bits; }
 
     // Note that we don't have setters. That is by design, use
     // the following with methods instead of mutating these objects.
@@ -4541,23 +4497,22 @@ public:
 
     ExtInfo withRegParm(unsigned RegParm) const {
       assert(RegParm < 7 && "Invalid regparm value");
-      return ExtInfo((Bits & ~RegParmMask) |
-                     ((RegParm + 1) << RegParmOffset));
+      return ExtInfo((Bits & ~RegParmMask) | ((RegParm + 1) << RegParmOffset));
     }
 
     ExtInfo withCallingConv(CallingConv cc) const {
-      return ExtInfo((Bits & ~CallConvMask) | (unsigned) cc);
+      return ExtInfo((Bits & ~CallConvMask) | (unsigned)cc);
     }
 
-    void Profile(llvm::FoldingSetNodeID &ID) const {
-      ID.AddInteger(Bits);
-    }
+    void Profile(llvm::FoldingSetNodeID &ID) const { ID.AddInteger(Bits); }
   };
 
   /// A simple holder for a QualType representing a type in an
   /// exception specification. Unfortunately needed by FunctionProtoType
   /// because TrailingObjects cannot handle repeated types.
-  struct ExceptionType { QualType Type; };
+  struct ExceptionType {
+    QualType Type;
+  };
 
   /// A simple holder for various uncommon bits which do not fit in
   /// FunctionTypeBitfields. Aligned to alignof(void *) to maintain the
@@ -5344,7 +5299,6 @@ private:
             FunctionTypeBits.HasExtraBitfields) &&
            "ExtraBitfields are required for given ExceptionSpecType");
     return FunctionTypeBits.HasExtraBitfields;
-
   }
 
   bool hasArmTypeAttributes() const {
@@ -5353,9 +5307,7 @@ private:
                ->HasArmTypeAttributes;
   }
 
-  bool hasExtQualifiers() const {
-    return FunctionTypeBits.HasExtQuals;
-  }
+  bool hasExtQualifiers() const { return FunctionTypeBits.HasExtQuals; }
 
 public:
   unsigned getNumParams() const { return FunctionTypeBits.NumParams; }
@@ -5690,9 +5642,7 @@ public:
     return T->getTypeClass() == UnresolvedUsing;
   }
 
-  void Profile(llvm::FoldingSetNodeID &ID) {
-    return Profile(ID, Decl);
-  }
+  void Profile(llvm::FoldingSetNodeID &ID) { return Profile(ID, Decl); }
 
   static void Profile(llvm::FoldingSetNodeID &ID,
                       UnresolvedUsingTypenameDecl *D) {
@@ -6080,13 +6030,13 @@ protected:
   friend class ASTContext; // ASTContext creates these.
 
   explicit RecordType(const RecordDecl *D)
-      : TagType(Record, reinterpret_cast<const TagDecl*>(D), QualType()) {}
+      : TagType(Record, reinterpret_cast<const TagDecl *>(D), QualType()) {}
   explicit RecordType(TypeClass TC, RecordDecl *D)
-      : TagType(TC, reinterpret_cast<const TagDecl*>(D), QualType()) {}
+      : TagType(TC, reinterpret_cast<const TagDecl *>(D), QualType()) {}
 
 public:
   RecordDecl *getDecl() const {
-    return reinterpret_cast<RecordDecl*>(TagType::getDecl());
+    return reinterpret_cast<RecordDecl *>(TagType::getDecl());
   }
 
   /// Recursively check all fields in the record for const-ness. If any field
@@ -6105,11 +6055,11 @@ class EnumType : public TagType {
   friend class ASTContext; // ASTContext creates these.
 
   explicit EnumType(const EnumDecl *D)
-      : TagType(Enum, reinterpret_cast<const TagDecl*>(D), QualType()) {}
+      : TagType(Enum, reinterpret_cast<const TagDecl *>(D), QualType()) {}
 
 public:
   EnumDecl *getDecl() const {
-    return reinterpret_cast<EnumDecl*>(TagType::getDecl());
+    return reinterpret_cast<EnumDecl *>(TagType::getDecl());
   }
 
   bool isSugared() const { return false; }
@@ -6215,9 +6165,7 @@ public:
     ID.AddPointer(attr);
   }
 
-  static bool classof(const Type *T) {
-    return T->getTypeClass() == Attributed;
-  }
+  static bool classof(const Type *T) { return T->getTypeClass() == Attributed; }
 };
 
 class BTFTagAttributedType : public Type, public llvm::FoldingSetNode {
@@ -6578,9 +6526,7 @@ public:
     return TypeConstraintConcept;
   }
 
-  bool isConstrained() const {
-    return TypeConstraintConcept != nullptr;
-  }
+  bool isConstrained() const { return TypeConstraintConcept != nullptr; }
 
   bool isDecltypeAuto() const {
     return getKeyword() == AutoTypeKeyword::DecltypeAuto;
@@ -6600,9 +6546,7 @@ public:
                       bool IsDependent, ConceptDecl *CD,
                       ArrayRef<TemplateArgument> Arguments);
 
-  static bool classof(const Type *T) {
-    return T->getTypeClass() == Auto;
-  }
+  static bool classof(const Type *T) { return T->getTypeClass() == Auto; }
 };
 
 /// Represents a C++17 deduced template specialization type.
@@ -6626,7 +6570,7 @@ class DeducedTemplateSpecializationType : public DeducedType,
 
 public:
   /// Retrieve the name of the template that we are deducing.
-  TemplateName getTemplateName() const { return Template;}
+  TemplateName getTemplateName() const { return Template; }
 
   void Profile(llvm::FoldingSetNodeID &ID) const {
     Profile(ID, getTemplateName(), getDeducedType(), isDependentType());
@@ -6676,10 +6620,8 @@ class TemplateSpecializationType : public Type, public llvm::FoldingSetNode {
   /// replacement must, recursively, be one of these).
   TemplateName Template;
 
-  TemplateSpecializationType(TemplateName T,
-                             ArrayRef<TemplateArgument> Args,
-                             QualType Canon,
-                             QualType Aliased);
+  TemplateSpecializationType(TemplateName T, ArrayRef<TemplateArgument> Args,
+                             QualType Canon, QualType Aliased);
 
 public:
   /// Determine whether any of the given template arguments are dependent.
@@ -6757,8 +6699,7 @@ public:
 
 /// Print a template argument list, including the '<' and '>'
 /// enclosing the template arguments.
-void printTemplateArgumentList(raw_ostream &OS,
-                               ArrayRef<TemplateArgument> Args,
+void printTemplateArgumentList(raw_ostream &OS, ArrayRef<TemplateArgument> Args,
                                const PrintingPolicy &Policy,
                                const TemplateParameterList *TPL = nullptr);
 
@@ -7052,9 +6993,7 @@ public:
 
   /// Retrieve the identifier that terminates this type name.
   /// For example, "type" in "typename T::type".
-  const IdentifierInfo *getIdentifier() const {
-    return Name;
-  }
+  const IdentifierInfo *getIdentifier() const { return Name; }
 
   bool isSugared() const { return false; }
   QualType desugar() const { return QualType(this, 0); }
@@ -7110,8 +7049,7 @@ public:
     Profile(ID, Context, getKeyword(), NNS, Name, template_arguments());
   }
 
-  static void Profile(llvm::FoldingSetNodeID &ID,
-                      const ASTContext &Context,
+  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,
                       ElaboratedTypeKeyword Keyword,
                       NestedNameSpecifier *Qualifier,
                       const IdentifierInfo *Name,
@@ -7197,21 +7135,20 @@ public:
 
 /// This class wraps the list of protocol qualifiers. For types that can
 /// take ObjC protocol qualifers, they can subclass this class.
-template <class T>
-class ObjCProtocolQualifiers {
+template <class T> class ObjCProtocolQualifiers {
 protected:
   ObjCProtocolQualifiers() = default;
 
-  ObjCProtocolDecl * const *getProtocolStorage() const {
-    return const_cast<ObjCProtocolQualifiers*>(this)->getProtocolStorage();
+  ObjCProtocolDecl *const *getProtocolStorage() const {
+    return const_cast<ObjCProtocolQualifiers *>(this)->getProtocolStorage();
   }
 
   ObjCProtocolDecl **getProtocolStorage() {
-    return static_cast<T*>(this)->getProtocolStorageImpl();
+    return static_cast<T *>(this)->getProtocolStorageImpl();
   }
 
   void setNumProtocols(unsigned N) {
-    static_cast<T*>(this)->setNumProtocolsImpl(N);
+    static_cast<T *>(this)->setNumProtocolsImpl(N);
   }
 
   void initialize(ArrayRef<ObjCProtocolDecl *> protocols) {
@@ -7220,11 +7157,11 @@ protected:
            "bitfield overflow in protocol count");
     if (!protocols.empty())
       memcpy(getProtocolStorage(), protocols.data(),
-             protocols.size() * sizeof(ObjCProtocolDecl*));
+             protocols.size() * sizeof(ObjCProtocolDecl *));
   }
 
 public:
-  using qual_iterator = ObjCProtocolDecl * const *;
+  using qual_iterator = ObjCProtocolDecl *const *;
   using qual_range = llvm::iterator_range<qual_iterator>;
 
   qual_range quals() const { return qual_range(qual_begin(), qual_end()); }
@@ -7236,7 +7173,7 @@ public:
   /// Return the number of qualifying protocols in this type, or 0 if
   /// there are none.
   unsigned getNumProtocols() const {
-    return static_cast<const T*>(this)->getNumProtocolsImpl();
+    return static_cast<const T *>(this)->getNumProtocolsImpl();
   }
 
   /// Fetch a protocol by index.
@@ -7271,16 +7208,11 @@ class ObjCTypeParamType : public Type,
 
   /// Return the number of qualifying protocols in this interface type,
   /// or 0 if there are none.
-  unsigned getNumProtocolsImpl() const {
-    return NumProtocols;
-  }
+  unsigned getNumProtocolsImpl() const { return NumProtocols; }
 
-  void setNumProtocolsImpl(unsigned N) {
-    NumProtocols = N;
-  }
+  void setNumProtocolsImpl(unsigned N) { NumProtocols = N; }
 
-  ObjCTypeParamType(const ObjCTypeParamDecl *D,
-                    QualType can,
+  ObjCTypeParamType(const ObjCTypeParamDecl *D, QualType can,
                     ArrayRef<ObjCProtocolDecl *> protocols);
 
 public:
@@ -7293,8 +7225,7 @@ public:
 
   void Profile(llvm::FoldingSetNodeID &ID);
   static void Profile(llvm::FoldingSetNodeID &ID,
-                      const ObjCTypeParamDecl *OTPDecl,
-                      QualType CanonicalType,
+                      const ObjCTypeParamDecl *OTPDecl, QualType CanonicalType,
                       ArrayRef<ObjCProtocolDecl *> protocols);
 
   ObjCTypeParamDecl *getDecl() const { return OTPDecl; }
@@ -7349,7 +7280,7 @@ class ObjCObjectType : public Type,
 
   /// Cached superclass type.
   mutable llvm::PointerIntPair<const ObjCObjectType *, 1, bool>
-    CachedSuperClassType;
+      CachedSuperClassType;
 
   QualType *getTypeArgStorage();
   const QualType *getTypeArgStorage() const {
@@ -7362,17 +7293,13 @@ class ObjCObjectType : public Type,
   unsigned getNumProtocolsImpl() const {
     return ObjCObjectTypeBits.NumProtocols;
   }
-  void setNumProtocolsImpl(unsigned N) {
-    ObjCObjectTypeBits.NumProtocols = N;
-  }
+  void setNumProtocolsImpl(unsigned N) { ObjCObjectTypeBits.NumProtocols = N; }
 
 protected:
   enum Nonce_ObjCInterface { Nonce_ObjCInterface };
 
-  ObjCObjectType(QualType Canonical, QualType Base,
-                 ArrayRef<QualType> typeArgs,
-                 ArrayRef<ObjCProtocolDecl *> protocols,
-                 bool isKindOf);
+  ObjCObjectType(QualType Canonical, QualType Base, ArrayRef<QualType> typeArgs,
+                 ArrayRef<ObjCProtocolDecl *> protocols, bool isKindOf);
 
   ObjCObjectType(enum Nonce_ObjCInterface)
       : Type(ObjCInterface, QualType(), TypeDependence::None),
@@ -7404,7 +7331,8 @@ public:
   bool isObjCUnqualifiedId() const { return qual_empty() && isObjCId(); }
   bool isObjCUnqualifiedClass() const { return qual_empty() && isObjCClass(); }
   bool isObjCUnqualifiedIdOrClass() const {
-    if (!qual_empty()) return false;
+    if (!qual_empty())
+      return false;
     if (const BuiltinType *T = getBaseType()->getAs<BuiltinType>())
       return T->getKind() == BuiltinType::ObjCId ||
              T->getKind() == BuiltinType::ObjCClass;
@@ -7488,31 +7416,29 @@ class ObjCObjectTypeImpl : public ObjCObjectType, public llvm::FoldingSetNode {
 
   ObjCObjectTypeImpl(QualType Canonical, QualType Base,
                      ArrayRef<QualType> typeArgs,
-                     ArrayRef<ObjCProtocolDecl *> protocols,
-                     bool isKindOf)
+                     ArrayRef<ObjCProtocolDecl *> protocols, bool isKindOf)
       : ObjCObjectType(Canonical, Base, typeArgs, protocols, isKindOf) {}
 
 public:
   void Profile(llvm::FoldingSetNodeID &ID);
-  static void Profile(llvm::FoldingSetNodeID &ID,
-                      QualType Base,
+  static void Profile(llvm::FoldingSetNodeID &ID, QualType Base,
                       ArrayRef<QualType> typeArgs,
-                      ArrayRef<ObjCProtocolDecl *> protocols,
-                      bool isKindOf);
+                      ArrayRef<ObjCProtocolDecl *> protocols, bool isKindOf);
 };
 
 inline QualType *ObjCObjectType::getTypeArgStorage() {
-  return reinterpret_cast<QualType *>(static_cast<ObjCObjectTypeImpl*>(this)+1);
+  return reinterpret_cast<QualType *>(static_cast<ObjCObjectTypeImpl *>(this) +
+                                      1);
 }
 
 inline ObjCProtocolDecl **ObjCObjectType::getProtocolStorageImpl() {
-    return reinterpret_cast<ObjCProtocolDecl**>(
-             getTypeArgStorage() + ObjCObjectTypeBits.NumTypeArgs);
+  return reinterpret_cast<ObjCProtocolDecl **>(getTypeArgStorage() +
+                                               ObjCObjectTypeBits.NumTypeArgs);
 }
 
 inline ObjCProtocolDecl **ObjCTypeParamType::getProtocolStorageImpl() {
-    return reinterpret_cast<ObjCProtocolDecl**>(
-             static_cast<ObjCTypeParamType*>(this)+1);
+  return reinterpret_cast<ObjCProtocolDecl **>(
+      static_cast<ObjCTypeParamType *>(this) + 1);
 }
 
 /// Interfaces are the core concept in Objective-C for object oriented design.
@@ -7536,7 +7462,7 @@ class ObjCInterfaceType : public ObjCObjectType {
 
   ObjCInterfaceType(const ObjCInterfaceDecl *D)
       : ObjCObjectType(Nonce_ObjCInterface),
-        Decl(const_cast<ObjCInterfaceDecl*>(D)) {}
+        Decl(const_cast<ObjCInterfaceDecl *>(D)) {}
 
 public:
   /// Get the declaration of this interface.
@@ -7553,13 +7479,7 @@ public:
   // class.  People asking for protocols on an ObjCInterfaceType are
   // not going to get what they want: ObjCInterfaceTypes are
   // guaranteed to have no protocols.
-  enum {
-    qual_iterator,
-    qual_begin,
-    qual_end,
-    getNumProtocols,
-    getProtocol
-  };
+  enum { qual_iterator, qual_begin, qual_end, getNumProtocols, getProtocol };
 };
 
 inline ObjCInterfaceDecl *ObjCObjectType::getInterface() const {
@@ -7641,9 +7561,7 @@ public:
 
   /// True if this is equivalent to the 'id' type, i.e. if
   /// its object type is the primitive 'id' type with no protocols.
-  bool isObjCIdType() const {
-    return getObjectType()->isObjCUnqualifiedId();
-  }
+  bool isObjCIdType() const { return getObjectType()->isObjCUnqualifiedId(); }
 
   /// True if this is equivalent to the 'Class' type,
   /// i.e. if its object tive is the primitive 'Class' type with no protocols.
@@ -7704,13 +7622,9 @@ public:
 
   qual_range quals() const { return qual_range(qual_begin(), qual_end()); }
 
-  qual_iterator qual_begin() const {
-    return getObjectType()->qual_begin();
-  }
+  qual_iterator qual_begin() const { return getObjectType()->qual_begin(); }
 
-  qual_iterator qual_end() const {
-    return getObjectType()->qual_end();
-  }
+  qual_iterator qual_end() const { return getObjectType()->qual_end(); }
 
   bool qual_empty() const { return getObjectType()->qual_empty(); }
 
@@ -7737,12 +7651,10 @@ public:
 
   /// Strip off the Objective-C "kindof" type and (with it) any
   /// protocol qualifiers.
-  const ObjCObjectPointerType *stripObjCKindOfTypeAndQuals(
-                                 const ASTContext &ctx) const;
+  const ObjCObjectPointerType *
+  stripObjCKindOfTypeAndQuals(const ASTContext &ctx) const;
 
-  void Profile(llvm::FoldingSetNodeID &ID) {
-    Profile(ID, getPointeeType());
-  }
+  void Profile(llvm::FoldingSetNodeID &ID) { Profile(ID, getPointeeType()); }
 
   static void Profile(llvm::FoldingSetNodeID &ID, QualType T) {
     ID.AddPointer(T.getAsOpaquePtr());
@@ -7769,17 +7681,13 @@ public:
   bool isSugared() const { return false; }
   QualType desugar() const { return QualType(this, 0); }
 
-  void Profile(llvm::FoldingSetNodeID &ID) {
-    Profile(ID, getValueType());
-  }
+  void Profile(llvm::FoldingSetNodeID &ID) { Profile(ID, getValueType()); }
 
   static void Profile(llvm::FoldingSetNodeID &ID, QualType T) {
     ID.AddPointer(T.getAsOpaquePtr());
   }
 
-  static bool classof(const Type *T) {
-    return T->getTypeClass() == Atomic;
-  }
+  static bool classof(const Type *T) { return T->getTypeClass() == Atomic; }
 };
 
 /// PipeType - OpenCL20.
@@ -7809,9 +7717,7 @@ public:
     ID.AddBoolean(isRead);
   }
 
-  static bool classof(const Type *T) {
-    return T->getTypeClass() == Pipe;
-  }
+  static bool classof(const Type *T) { return T->getTypeClass() == Pipe; }
 
   bool isReadOnly() const { return isRead; }
 };
@@ -7849,7 +7755,7 @@ public:
 
 class DependentBitIntType final : public Type, public llvm::FoldingSetNode {
   friend class ASTContext;
-  llvm::PointerIntPair<Expr*, 1, bool> ExprAndUnsigned;
+  llvm::PointerIntPair<Expr *, 1, bool> ExprAndUnsigned;
 
 protected:
   DependentBitIntType(bool IsUnsigned, Expr *NumBits);
@@ -7895,7 +7801,7 @@ public:
   QualType apply(const ASTContext &Context, QualType QT) const;
 
   /// Apply the collected qualifiers to the given type.
-  QualType apply(const ASTContext &Context, const Type* T) const;
+  QualType apply(const ASTContext &Context, const Type *T) const;
 };
 
 /// A container of type source information.
@@ -7929,7 +7835,7 @@ public:
 
 inline SplitQualType SplitQualType::getSingleStepDesugaredType() const {
   SplitQualType desugar =
-    Ty->getLocallyUnqualifiedSingleStepDesugaredType().split();
+      Ty->getLocallyUnqualifiedSingleStepDesugaredType().split();
   desugar.Quals.addConsistentQualifiers(Quals);
   return desugar;
 }
@@ -7996,8 +7902,10 @@ inline bool QualType::isCanonical() const {
 }
 
 inline bool QualType::isCanonicalAsParam() const {
-  if (!isCanonical()) return false;
-  if (hasLocalQualifiers()) return false;
+  if (!isCanonical())
+    return false;
+  if (hasLocalQualifiers())
+    return false;
 
   const Type *T = getTypePtr();
   if (T->isVariablyModifiedType() && T->hasSizedVLAType())
@@ -8017,7 +7925,6 @@ inline bool QualType::isRestrictQualified() const {
          getCommonPtr()->CanonicalType.isLocalRestrictQualified();
 }
 
-
 inline bool QualType::isVolatileQualified() const {
   return isLocalVolatileQualified() ||
          getCommonPtr()->CanonicalType.isLocalVolatileQualified();
@@ -8153,8 +8060,7 @@ inline bool QualType::isCForbiddenLValueType() const {
 ///
 /// \returns True for types specified in C++0x [basic.fundamental].
 inline bool Type::isFundamentalType() const {
-  return isVoidType() ||
-         isNullPtrType() ||
+  return isVoidType() || isNullPtrType() ||
          // FIXME: It's really annoying that we don't have an
          // 'isArithmeticType()' which agrees with the standard definition.
          (isArithmeticType() && !isEnumeralType());
@@ -8168,20 +8074,23 @@ inline bool Type::isCompoundType() const {
   //   Compound types can be constructed in the following ways:
   //    -- arrays of objects of a given type [...];
   return isArrayType() ||
-  //    -- functions, which have parameters of given types [...];
+         //    -- functions, which have parameters of given types [...];
          isFunctionType() ||
-  //    -- pointers to void or objects or functions [...];
+         //    -- pointers to void or objects or functions [...];
          isPointerType() ||
-  //    -- references to objects or functions of a given type. [...]
+         //    -- references to objects or functions of a given type. [...]
          isReferenceType() ||
-  //    -- classes containing a sequence of objects of various types, [...];
+         //    -- classes containing a sequence of objects of various types,
+         //    [...];
          isRecordType() ||
-  //    -- unions, which are classes capable of containing objects of different
-  //               types at different times;
+         //    -- unions, which are classes capable of containing objects of
+         //    different
+         //               types at different times;
          isUnionType() ||
-  //    -- enumerations, which comprise a set of named constant values. [...];
+         //    -- enumerations, which comprise a set of named constant values.
+         //    [...];
          isEnumeralType() ||
-  //    -- pointers to non-static class members, [...].
+         //    -- pointers to non-static class members, [...].
          isMemberPointerType();
 }
 
@@ -8261,9 +8170,7 @@ inline bool Type::isMemberDataPointerType() const {
     return false;
 }
 
-inline bool Type::isArrayType() const {
-  return isa<ArrayType>(CanonicalType);
-}
+inline bool Type::isArrayType() const { return isa<ArrayType>(CanonicalType); }
 
 inline bool Type::isConstantArrayType() const {
   return isa<ConstantArrayType>(CanonicalType);
@@ -8341,7 +8248,7 @@ inline bool Type::isObjCObjectType() const {
 
 inline bool Type::isObjCObjectOrInterfaceType() const {
   return isa<ObjCInterfaceType>(CanonicalType) ||
-    isa<ObjCObjectType>(CanonicalType);
+         isa<ObjCObjectType>(CanonicalType);
 }
 
 inline bool Type::isAtomicType() const {
@@ -8386,13 +8293,11 @@ inline bool Type::isObjCBuiltinType() const {
   return isObjCIdType() || isObjCClassType() || isObjCSelType();
 }
 
-inline bool Type::isDecltypeType() const {
-  return isa<DecltypeType>(this);
-}
+inline bool Type::isDecltypeType() const { return isa<DecltypeType>(this); }
 
-#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
-  inline bool Type::is##Id##Type() const { \
-    return isSpecificBuiltinType(BuiltinType::Id); \
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix)                   \
+  inline bool Type::is##Id##Type() const {                                     \
+    return isSpecificBuiltinType(BuiltinType::Id);                             \
   }
 #include "clang/Basic/OpenCLImageTypes.def"
 
@@ -8423,33 +8328,31 @@ inline bool Type::isImageType() const {
       false; // end boolean or operation
 }
 
-inline bool Type::isPipeType() const {
-  return isa<PipeType>(CanonicalType);
-}
+inline bool Type::isPipeType() const { return isa<PipeType>(CanonicalType); }
 
 inline bool Type::isBitIntType() const {
   return isa<BitIntType>(CanonicalType);
 }
 
-#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \
-  inline bool Type::is##Id##Type() const { \
-    return isSpecificBuiltinType(BuiltinType::Id); \
+#define EXT_OPAQUE_TYPE(ExtType, Id, Ext)                                      \
+  inline bool Type::is##Id##Type() const {                                     \
+    return isSpecificBuiltinType(BuiltinType::Id);                             \
   }
 #include "clang/Basic/OpenCLExtensionTypes.def"
 
 inline bool Type::isOCLIntelSubgroupAVCType() const {
-#define INTEL_SUBGROUP_AVC_TYPE(ExtType, Id) \
+#define INTEL_SUBGROUP_AVC_TYPE(ExtType, Id)                                   \
   isOCLIntelSubgroupAVC##Id##Type() ||
   return
 #include "clang/Basic/OpenCLExtensionTypes.def"
-    false; // end of boolean or operation
+      false; // end of boolean or operation
 }
 
 inline bool Type::isOCLExtOpaqueType() const {
 #define EXT_OPAQUE_TYPE(ExtType, Id, Ext) is##Id##Type() ||
   return
 #include "clang/Basic/OpenCLExtensionTypes.def"
-    false; // end of boolean or operation
+      false; // end of boolean or operation
 }
 
 inline bool Type::isOpenCLSpecificType() const {
@@ -8503,7 +8406,7 @@ inline const BuiltinType *Type::getAsPlaceholderType() const {
 }
 
 inline bool Type::isSpecificPlaceholderType(unsigned K) const {
-  assert(BuiltinType::isPlaceholderTypeKind((BuiltinType::Kind) K));
+  assert(BuiltinType::isPlaceholderTypeKind((BuiltinType::Kind)K));
   return isSpecificBuiltinType(K);
 }
 
@@ -8565,7 +8468,7 @@ inline bool Type::isIntegerType() const {
     // Incomplete enum types are not treated as integer types.
     // FIXME: In C++, enum types are never integer types.
     return IsEnumDeclComplete(ET->getDecl()) &&
-      !IsEnumDeclScoped(ET->getDecl());
+           !IsEnumDeclScoped(ET->getDecl());
   }
   return isBitIntType();
 }
@@ -8628,8 +8531,7 @@ inline bool Type::isScalarType() const {
          isa<BlockPointerType>(CanonicalType) ||
          isa<MemberPointerType>(CanonicalType) ||
          isa<ComplexType>(CanonicalType) ||
-         isa<ObjCObjectPointerType>(CanonicalType) ||
-         isBitIntType();
+         isa<ObjCObjectPointerType>(CanonicalType) || isBitIntType();
 }
 
 inline bool Type::isIntegralOrEnumerationType() const {
@@ -8756,7 +8658,8 @@ template <typename T> const T *Type::getAs() const {
 }
 
 template <typename T> const T *Type::getAsAdjusted() const {
-  static_assert(!TypeIsArrayType<T>::value, "ArrayType cannot be used with getAsAdjusted!");
+  static_assert(!TypeIsArrayType<T>::value,
+                "ArrayType cannot be used with getAsAdjusted!");
 
   // If this is directly a T type, return it.
   if (const auto *Ty = dyn_cast<T>(this))
@@ -8811,14 +8714,16 @@ template <typename T> const T *Type::castAs() const {
   static_assert(!TypeIsArrayType<T>::value,
                 "ArrayType cannot be used with castAs!");
 
-  if (const auto *ty = dyn_cast<T>(this)) return ty;
+  if (const auto *ty = dyn_cast<T>(this))
+    return ty;
   assert(isa<T>(CanonicalType));
   return cast<T>(getUnqualifiedDesugaredType());
 }
 
 inline const ArrayType *Type::castAsArrayTypeUnsafe() const {
   assert(isa<ArrayType>(CanonicalType));
-  if (const auto *arr = dyn_cast<ArrayType>(this)) return arr;
+  if (const auto *arr = dyn_cast<ArrayType>(this))
+    return arr;
   return cast<ArrayType>(getUnqualifiedDesugaredType());
 }
 
diff --git a/clang/include/clang/AST/TypeLoc.h b/clang/include/clang/AST/TypeLoc.h
index a55a38335ef6..04a2cb140b29 100644
--- a/clang/include/clang/AST/TypeLoc.h
+++ b/clang/include/clang/AST/TypeLoc.h
@@ -109,7 +109,7 @@ public:
 #define ABSTRACT_TYPE(Class, Base)
 #define TYPE(Class, Base) \
     Class = Type::Class,
-#include "clang/AST/TypeNodes.inc"
+#include "TypeNodes.inc"
     Qualified
   };
 
diff --git a/clang/include/clang/AST/TypeLocNodes.def b/clang/include/clang/AST/TypeLocNodes.def
index 81448c7e7ce5..69a48df0b2c3 100644
--- a/clang/include/clang/AST/TypeLocNodes.def
+++ b/clang/include/clang/AST/TypeLocNodes.def
@@ -31,7 +31,7 @@
 TYPELOC(Qualified, TypeLoc)
 #define TYPE(Class, Base) UNQUAL_TYPELOC(Class, Base##Loc)
 #define ABSTRACT_TYPE(Class, Base) ABSTRACT_TYPELOC(Class, Base##Loc)
-#include "clang/AST/TypeNodes.inc"
+#include "TypeNodes.inc"
 
 #undef DECLARATOR_TYPELOC
 #undef TYPESPEC_TYPELOC
diff --git a/clang/include/clang/AST/TypeVisitor.h b/clang/include/clang/AST/TypeVisitor.h
index 17301835fb18..e0aea24b7693 100644
--- a/clang/include/clang/AST/TypeVisitor.h
+++ b/clang/include/clang/AST/TypeVisitor.h
@@ -70,7 +70,7 @@ public:
     switch (T->getTypeClass()) {
 #define ABSTRACT_TYPE(CLASS, PARENT)
 #define TYPE(CLASS, PARENT) case Type::CLASS: DISPATCH(CLASS##Type);
-#include "clang/AST/TypeNodes.inc"
+#include "TypeNodes.inc"
     }
     llvm_unreachable("Unknown type class!");
   }
@@ -80,7 +80,7 @@ public:
 #define TYPE(CLASS, PARENT) RetTy Visit##CLASS##Type(const CLASS##Type *T) { \
   DISPATCH(PARENT);                                                          \
 }
-#include "clang/AST/TypeNodes.inc"
+#include "TypeNodes.inc"
 
   /// Method called if \c ImpClass doesn't provide specific handler
   /// for some type class.
diff --git a/clang/include/clang/Basic/Attr.td b/clang/include/clang/Basic/Attr.td
index 2a3a29bd2ee1..02a58bed25e6 100644
--- a/clang/include/clang/Basic/Attr.td
+++ b/clang/include/clang/Basic/Attr.td
@@ -4972,3 +4972,25 @@ def NoTrivialAutoVarInit: InheritableAttr {
   let Documentation = [NoTrivialAutoVarInitDocs];
   let SimpleHandler = 1;
 }
+
+def ErReflect : InheritableAttr {
+  let Spellings = [CXX11<"er", "reflect", 1>];
+  let Subjects = SubjectList<[CXXRecord, Enum]>;
+  let Args = [VariadicEnumArgument<"Options", "Option", 1,
+              ["all", "base", "nonPublic", "data", "func"],
+              ["All", "Base", "NonPublic", "Data", "Func"]>];
+  let Documentation = [ErReflectDocs];
+}
+
+def ErAlias : InheritableAttr {
+  let Spellings = [CXX11<"er", "alias", 1>];
+  let Subjects = SubjectList<[Field, Function, CXXRecord]>;
+  let Args = [StringArgument<"Name">];
+  let Documentation = [ErAliasDocs];
+}
+
+def ErIgnore : InheritableAttr {
+  let Spellings = [CXX11<"er", "ignore", 1>];
+  let Subjects = SubjectList<[Field, Function, CXXRecord]>;
+  let Documentation = [ErIgnoreDocs];
+}
diff --git a/clang/include/clang/Basic/AttrDocs.td b/clang/include/clang/Basic/AttrDocs.td
index a8b588169725..ca9b181a695e 100644
--- a/clang/include/clang/Basic/AttrDocs.td
+++ b/clang/include/clang/Basic/AttrDocs.td
@@ -9026,3 +9026,31 @@ Declares that a function potentially allocates heap memory, and prevents any pot
 of ``nonallocating`` by the compiler.
   }];
 }
+
+def ErReflectDocs : Documentation {
+  let Category = DocCatFunction;
+  let Content = [{
+The attribute marks an object for later analysis and code generation. It accepts
+optional arguments with the following settings:
+
+* ``Base``      - includes entities from the base class
+* ``NonPublic`` - includes protected and private members
+* ``Data``      - includes fields and static member variables
+* ``Func``      - includes methods
+* ``All``       - a combination of all the options above, the same as an empty argument
+  }];
+}
+
+def ErAliasDocs : Documentation {
+  let Category = DocCatFunction;
+  let Content = [{
+Set alias for an entity as ``[[er::alias("new_name")]]``
+  }];
+}
+
+def ErIgnoreDocs : Documentation {
+  let Category = DocCatFunction;
+  let Content = [{
+The attribute prevents the generation of reflection code for the marked entity.
+  }];
+}
diff --git a/clang/include/clang/Basic/AttrKinds.h b/clang/include/clang/Basic/AttrKinds.h
index ec0052dfea35..023f4ded5d47 100644
--- a/clang/include/clang/Basic/AttrKinds.h
+++ b/clang/include/clang/Basic/AttrKinds.h
@@ -24,7 +24,7 @@ enum Kind {
 #define ATTR_RANGE(CLASS, FIRST_NAME, LAST_NAME) \
   First##CLASS = FIRST_NAME,                    \
   Last##CLASS = LAST_NAME,
-#include "clang/Basic/AttrList.inc"
+#include "AttrList.inc"
 };
 
 } // end namespace attr
diff --git a/clang/include/clang/Basic/AttrSubjectMatchRules.h b/clang/include/clang/Basic/AttrSubjectMatchRules.h
index bec8122ea930..3cd778346869 100644
--- a/clang/include/clang/Basic/AttrSubjectMatchRules.h
+++ b/clang/include/clang/Basic/AttrSubjectMatchRules.h
@@ -20,10 +20,10 @@ namespace attr {
 /// A list of all the recognized kinds of attributes.
 enum SubjectMatchRule {
 #define ATTR_MATCH_RULE(X, Spelling, IsAbstract) X,
-#include "clang/Basic/AttrSubMatchRulesList.inc"
+#include "AttrSubMatchRulesList.inc"
   SubjectMatchRule_Last = -1
 #define ATTR_MATCH_RULE(X, Spelling, IsAbstract) +1
-#include "clang/Basic/AttrSubMatchRulesList.inc"
+#include "AttrSubMatchRulesList.inc"
 };
 
 const char *getSubjectMatchRuleSpelling(SubjectMatchRule Rule);
diff --git a/clang/include/clang/Basic/AttributeCommonInfo.h b/clang/include/clang/Basic/AttributeCommonInfo.h
index 4af5a8fd1852..8bb70523c741 100644
--- a/clang/include/clang/Basic/AttributeCommonInfo.h
+++ b/clang/include/clang/Basic/AttributeCommonInfo.h
@@ -61,7 +61,7 @@ public:
   };
   enum Kind {
 #define PARSED_ATTR(NAME) AT_##NAME,
-#include "clang/Basic/AttrParsedAttrList.inc"
+#include "AttrParsedAttrList.inc"
 #undef PARSED_ATTR
     NoSemaHandlerAttribute,
     IgnoredAttribute,
@@ -271,7 +271,7 @@ inline bool doesKeywordAttributeTakeArgs(tok::TokenKind Kind) {
 #define KEYWORD_ATTRIBUTE(NAME, HASARG, ...)                                   \
   case tok::kw_##NAME:                                                         \
     return HASARG;
-#include "clang/Basic/RegularKeywordAttrInfo.inc"
+#include "RegularKeywordAttrInfo.inc"
 #undef KEYWORD_ATTRIBUTE
   }
 }
diff --git a/clang/include/clang/Basic/Builtins.h b/clang/include/clang/Basic/Builtins.h
index 63559d977ce6..aac490f03f56 100644
--- a/clang/include/clang/Basic/Builtins.h
+++ b/clang/include/clang/Basic/Builtins.h
@@ -64,7 +64,7 @@ namespace Builtin {
 enum ID {
   NotBuiltin  = 0,      // This is not a builtin function.
 #define BUILTIN(ID, TYPE, ATTRS) BI##ID,
-#include "clang/Basic/Builtins.inc"
+#include "Builtins.inc"
   FirstTSBuiltin
 };
 
diff --git a/clang/include/clang/Basic/DiagnosticAST.h b/clang/include/clang/Basic/DiagnosticAST.h
index 4f82114b7406..2b198cf1e0a5 100644
--- a/clang/include/clang/Basic/DiagnosticAST.h
+++ b/clang/include/clang/Basic/DiagnosticAST.h
@@ -18,7 +18,7 @@ enum {
              SHOWINSYSHEADER, SHOWINSYSMACRO, DEFERRABLE, CATEGORY)            \
   ENUM,
 #define ASTSTART
-#include "clang/Basic/DiagnosticASTKinds.inc"
+#include "DiagnosticASTKinds.inc"
 #undef DIAG
   NUM_BUILTIN_AST_DIAGNOSTICS
 };
@@ -31,7 +31,7 @@ enum {
   }                                                                            \
   ;                                                                            \
   }
-#include "clang/Basic/DiagnosticASTEnums.inc"
+#include "DiagnosticASTEnums.inc"
 #undef DIAG_ENUM_END
 #undef DIAG_ENUM_ITEM
 #undef DIAG_ENUM
diff --git a/clang/include/clang/Basic/DiagnosticAnalysis.h b/clang/include/clang/Basic/DiagnosticAnalysis.h
index 1a49461bcd17..1e2c7c02cca4 100644
--- a/clang/include/clang/Basic/DiagnosticAnalysis.h
+++ b/clang/include/clang/Basic/DiagnosticAnalysis.h
@@ -18,7 +18,7 @@ enum {
              SHOWINSYSHEADER, SHOWINSYSMACRO, DEFERRABLE, CATEGORY)            \
   ENUM,
 #define ANALYSISSTART
-#include "clang/Basic/DiagnosticAnalysisKinds.inc"
+#include "DiagnosticAnalysisKinds.inc"
 #undef DIAG
   NUM_BUILTIN_ANALYSIS_DIAGNOSTICS
 };
@@ -30,7 +30,7 @@ enum {
   }                                                                            \
   ;                                                                            \
   }
-#include "clang/Basic/DiagnosticAnalysisEnums.inc"
+#include "DiagnosticAnalysisEnums.inc"
 #undef DIAG_ENUM_END
 #undef DIAG_ENUM_ITEM
 #undef DIAG_ENUM
diff --git a/clang/include/clang/Basic/DiagnosticCategories.h b/clang/include/clang/Basic/DiagnosticCategories.h
index 839f8dee3ca8..2e5925f36b61 100644
--- a/clang/include/clang/Basic/DiagnosticCategories.h
+++ b/clang/include/clang/Basic/DiagnosticCategories.h
@@ -14,7 +14,7 @@ namespace clang {
     enum {
 #define GET_CATEGORY_TABLE
 #define CATEGORY(X, ENUM) ENUM,
-#include "clang/Basic/DiagnosticGroups.inc"
+#include "DiagnosticGroups.inc"
 #undef CATEGORY
 #undef GET_CATEGORY_TABLE
       DiagCat_NUM_CATEGORIES
@@ -23,7 +23,7 @@ namespace clang {
     enum class Group {
 #define DIAG_ENTRY(GroupName, FlagNameOffset, Members, SubGroups, Docs)    \
       GroupName,
-#include "clang/Basic/DiagnosticGroups.inc"
+#include "DiagnosticGroups.inc"
 #undef CATEGORY
 #undef DIAG_ENTRY
       NUM_GROUPS
diff --git a/clang/include/clang/Basic/DiagnosticComment.h b/clang/include/clang/Basic/DiagnosticComment.h
index 53143ef132e4..73dba2a39ef1 100644
--- a/clang/include/clang/Basic/DiagnosticComment.h
+++ b/clang/include/clang/Basic/DiagnosticComment.h
@@ -18,7 +18,7 @@ enum {
              SHOWINSYSHEADER, SHOWINSYSMACRO, DEFERRABLE, CATEGORY)            \
   ENUM,
 #define COMMENTSTART
-#include "clang/Basic/DiagnosticCommentKinds.inc"
+#include "DiagnosticCommentKinds.inc"
 #undef DIAG
   NUM_BUILTIN_COMMENT_DIAGNOSTICS
 };
@@ -31,7 +31,7 @@ enum {
   }                                                                            \
   ;                                                                            \
   }
-#include "clang/Basic/DiagnosticCommentEnums.inc"
+#include "DiagnosticCommentEnums.inc"
 #undef DIAG_ENUM_END
 #undef DIAG_ENUM_ITEM
 #undef DIAG_ENUM
diff --git a/clang/include/clang/Basic/DiagnosticCrossTU.h b/clang/include/clang/Basic/DiagnosticCrossTU.h
index 428da9501102..549fe98ce60e 100644
--- a/clang/include/clang/Basic/DiagnosticCrossTU.h
+++ b/clang/include/clang/Basic/DiagnosticCrossTU.h
@@ -18,7 +18,7 @@ enum {
              SHOWINSYSHEADER, SHOWINSYSMACRO, DEFERRABLE, CATEGORY)            \
   ENUM,
 #define CROSSTUSTART
-#include "clang/Basic/DiagnosticCrossTUKinds.inc"
+#include "DiagnosticCrossTUKinds.inc"
 #undef DIAG
   NUM_BUILTIN_CROSSTU_DIAGNOSTICS
 };
@@ -31,7 +31,7 @@ enum {
   }                                                                            \
   ;                                                                            \
   }
-#include "clang/Basic/DiagnosticCrossTUEnums.inc"
+#include "DiagnosticCrossTUEnums.inc"
 #undef DIAG_ENUM_END
 #undef DIAG_ENUM_ITEM
 #undef DIAG_ENUM
diff --git a/clang/include/clang/Basic/DiagnosticDriver.h b/clang/include/clang/Basic/DiagnosticDriver.h
index c472afa3f6e9..e3d2108d02de 100644
--- a/clang/include/clang/Basic/DiagnosticDriver.h
+++ b/clang/include/clang/Basic/DiagnosticDriver.h
@@ -18,7 +18,7 @@ enum {
              SHOWINSYSHEADER, SHOWINSYSMACRO, DEFERRABLE, CATEGORY)            \
   ENUM,
 #define DRIVERSTART
-#include "clang/Basic/DiagnosticDriverKinds.inc"
+#include "DiagnosticDriverKinds.inc"
 #undef DIAG
   NUM_BUILTIN_DRIVER_DIAGNOSTICS
 };
@@ -31,7 +31,7 @@ enum {
   }                                                                            \
   ;                                                                            \
   }
-#include "clang/Basic/DiagnosticDriverEnums.inc"
+#include "DiagnosticDriverEnums.inc"
 #undef DIAG_ENUM_END
 #undef DIAG_ENUM_ITEM
 #undef DIAG_ENUM
diff --git a/clang/include/clang/Basic/DiagnosticFrontend.h b/clang/include/clang/Basic/DiagnosticFrontend.h
index 766cac3d655b..4697ad04658b 100644
--- a/clang/include/clang/Basic/DiagnosticFrontend.h
+++ b/clang/include/clang/Basic/DiagnosticFrontend.h
@@ -18,7 +18,7 @@ enum {
              SHOWINSYSHEADER, SHOWINSYSMACRO, DEFERRABLE, CATEGORY)            \
   ENUM,
 #define FRONTENDSTART
-#include "clang/Basic/DiagnosticFrontendKinds.inc"
+#include "DiagnosticFrontendKinds.inc"
 #undef DIAG
   NUM_BUILTIN_FRONTEND_DIAGNOSTICS
 };
@@ -31,7 +31,7 @@ enum {
   }                                                                            \
   ;                                                                            \
   }
-#include "clang/Basic/DiagnosticFrontendEnums.inc"
+#include "DiagnosticFrontendEnums.inc"
 #undef DIAG_ENUM_END
 #undef DIAG_ENUM_ITEM
 #undef DIAG_ENUM
diff --git a/clang/include/clang/Basic/DiagnosticIDs.h b/clang/include/clang/Basic/DiagnosticIDs.h
index b49185c3335d..8eed800c7edf 100644
--- a/clang/include/clang/Basic/DiagnosticIDs.h
+++ b/clang/include/clang/Basic/DiagnosticIDs.h
@@ -76,7 +76,7 @@ namespace clang {
              NOWERROR, SHOWINSYSHEADER, SHOWINSYSMACRO, DEFFERABLE)            \
   ENUM,
 #define COMMONSTART
-#include "clang/Basic/DiagnosticCommonKinds.inc"
+#include "DiagnosticCommonKinds.inc"
       NUM_BUILTIN_COMMON_DIAGNOSTICS
 #undef DIAG
     };
diff --git a/clang/include/clang/Basic/DiagnosticInstallAPI.h b/clang/include/clang/Basic/DiagnosticInstallAPI.h
index cbdb00362624..9b6c449bde1c 100644
--- a/clang/include/clang/Basic/DiagnosticInstallAPI.h
+++ b/clang/include/clang/Basic/DiagnosticInstallAPI.h
@@ -17,7 +17,7 @@ enum {
              SHOWINSYSHEADER, SHOWINSYSMACRO, DEFERRABLE, CATEGORY)            \
   ENUM,
 #define INSTALLAPISTART
-#include "clang/Basic/DiagnosticInstallAPIKinds.inc"
+#include "DiagnosticInstallAPIKinds.inc"
 #undef DIAG
   NUM_BUILTIN_INSTALLAPI_DIAGNOSTICS
 };
@@ -30,7 +30,7 @@ enum {
   }                                                                            \
   ;                                                                            \
   }
-#include "clang/Basic/DiagnosticInstallAPIEnums.inc"
+#include "DiagnosticInstallAPIEnums.inc"
 #undef DIAG_ENUM_END
 #undef DIAG_ENUM_ITEM
 #undef DIAG_ENUM
diff --git a/clang/include/clang/Basic/DiagnosticLex.h b/clang/include/clang/Basic/DiagnosticLex.h
index d14bf97e8642..77b6a1902d94 100644
--- a/clang/include/clang/Basic/DiagnosticLex.h
+++ b/clang/include/clang/Basic/DiagnosticLex.h
@@ -18,7 +18,7 @@ enum {
              SHOWINSYSHEADER, SHOWINSYSMACRO, DEFERRABLE, CATEGORY)            \
   ENUM,
 #define LEXSTART
-#include "clang/Basic/DiagnosticLexKinds.inc"
+#include "DiagnosticLexKinds.inc"
 #undef DIAG
   NUM_BUILTIN_LEX_DIAGNOSTICS
 };
@@ -30,7 +30,7 @@ enum {
   }                                                                            \
   ;                                                                            \
   }
-#include "clang/Basic/DiagnosticLexEnums.inc"
+#include "DiagnosticLexEnums.inc"
 #undef DIAG_ENUM_END
 #undef DIAG_ENUM_ITEM
 #undef DIAG_ENUM
diff --git a/clang/include/clang/Basic/DiagnosticParse.h b/clang/include/clang/Basic/DiagnosticParse.h
index 275e1a4c39b3..a79ab2a0c849 100644
--- a/clang/include/clang/Basic/DiagnosticParse.h
+++ b/clang/include/clang/Basic/DiagnosticParse.h
@@ -18,7 +18,7 @@ enum {
              SHOWINSYSHEADER, SHOWINSYSMACRO, DEFERRABLE, CATEGORY)            \
   ENUM,
 #define PARSESTART
-#include "clang/Basic/DiagnosticParseKinds.inc"
+#include "DiagnosticParseKinds.inc"
 #undef DIAG
   NUM_BUILTIN_PARSE_DIAGNOSTICS
 };
@@ -31,7 +31,7 @@ enum {
   }                                                                            \
   ;                                                                            \
   }
-#include "clang/Basic/DiagnosticParseEnums.inc"
+#include "DiagnosticParseEnums.inc"
 #undef DIAG_ENUM_END
 #undef DIAG_ENUM_ITEM
 #undef DIAG_ENUM
diff --git a/clang/include/clang/Basic/DiagnosticRefactoring.h b/clang/include/clang/Basic/DiagnosticRefactoring.h
index 59d4bc912733..56b9cb0fd729 100644
--- a/clang/include/clang/Basic/DiagnosticRefactoring.h
+++ b/clang/include/clang/Basic/DiagnosticRefactoring.h
@@ -18,7 +18,7 @@ enum {
              SHOWINSYSHEADER, SHOWINSYSMACRO, DEFERRABLE, CATEGORY)            \
   ENUM,
 #define REFACTORINGSTART
-#include "clang/Basic/DiagnosticRefactoringKinds.inc"
+#include "DiagnosticRefactoringKinds.inc"
 #undef DIAG
   NUM_BUILTIN_REFACTORING_DIAGNOSTICS
 };
@@ -31,7 +31,7 @@ enum {
   }                                                                            \
   ;                                                                            \
   }
-#include "clang/Basic/DiagnosticRefactoringEnums.inc"
+#include "DiagnosticRefactoringEnums.inc"
 #undef DIAG_ENUM_END
 #undef DIAG_ENUM_ITEM
 #undef DIAG_ENUM
diff --git a/clang/include/clang/Basic/DiagnosticSema.h b/clang/include/clang/Basic/DiagnosticSema.h
index 84986c7bccf7..518f9cc3fe9e 100644
--- a/clang/include/clang/Basic/DiagnosticSema.h
+++ b/clang/include/clang/Basic/DiagnosticSema.h
@@ -18,7 +18,7 @@ enum {
              SHOWINSYSHEADER, SHOWINSYSMACRO, DEFERRABLE, CATEGORY)            \
   ENUM,
 #define SEMASTART
-#include "clang/Basic/DiagnosticSemaKinds.inc"
+#include "DiagnosticSemaKinds.inc"
 #undef DIAG
   NUM_BUILTIN_SEMA_DIAGNOSTICS
 };
@@ -31,7 +31,7 @@ enum {
   }                                                                            \
   ;                                                                            \
   }
-#include "clang/Basic/DiagnosticSemaEnums.inc"
+#include "DiagnosticSemaEnums.inc"
 #undef DIAG_ENUM_END
 #undef DIAG_ENUM_ITEM
 #undef DIAG_ENUM
diff --git a/clang/include/clang/Basic/DiagnosticSerialization.h b/clang/include/clang/Basic/DiagnosticSerialization.h
index 6fb836dca1b0..2307ac630d0c 100644
--- a/clang/include/clang/Basic/DiagnosticSerialization.h
+++ b/clang/include/clang/Basic/DiagnosticSerialization.h
@@ -18,7 +18,7 @@ enum {
              SHOWINSYSHEADER, SHOWINSYSMACRO, DEFERRABLE, CATEGORY)            \
   ENUM,
 #define SERIALIZATIONSTART
-#include "clang/Basic/DiagnosticSerializationKinds.inc"
+#include "DiagnosticSerializationKinds.inc"
 #undef DIAG
   NUM_BUILTIN_SERIALIZATION_DIAGNOSTICS
 };
@@ -31,7 +31,7 @@ enum {
   }                                                                            \
   ;                                                                            \
   }
-#include "clang/Basic/DiagnosticSerializationEnums.inc"
+#include "DiagnosticSerializationEnums.inc"
 #undef DIAG_ENUM_END
 #undef DIAG_ENUM_ITEM
 #undef DIAG_ENUM
diff --git a/clang/include/clang/Basic/IdentifierTable.h b/clang/include/clang/Basic/IdentifierTable.h
index e5e6be3c9660..504e38222c6b 100644
--- a/clang/include/clang/Basic/IdentifierTable.h
+++ b/clang/include/clang/Basic/IdentifierTable.h
@@ -102,7 +102,7 @@ enum class InterestingIdentifier {
 
   NotBuiltin,
 #define BUILTIN(ID, TYPE, ATTRS) BI##ID,
-#include "clang/Basic/Builtins.inc"
+#include "Builtins.inc"
   FirstTSBuiltin,
 
   NotInterestingIdentifier = 65534
diff --git a/clang/include/clang/Basic/TargetBuiltins.h b/clang/include/clang/Basic/TargetBuiltins.h
index 95eb110bb9c2..c595082aeeaf 100644
--- a/clang/include/clang/Basic/TargetBuiltins.h
+++ b/clang/include/clang/Basic/TargetBuiltins.h
@@ -84,7 +84,7 @@ namespace clang {
   enum {
     LastTIBuiltin = clang::Builtin::FirstTSBuiltin - 1,
   #define BUILTIN(ID, TYPE, ATTRS) BI##ID,
-  #include "clang/Basic/BuiltinsBPF.inc"
+  #include "BuiltinsBPF.inc"
     LastTSBuiltin
   };
   }
@@ -104,7 +104,7 @@ namespace clang {
   enum {
     LastTIBuiltin = clang::Builtin::FirstTSBuiltin - 1,
 #define BUILTIN(ID, TYPE, ATTRS) BI##ID,
-#include "clang/Basic/BuiltinsNVPTX.inc"
+#include "BuiltinsNVPTX.inc"
     LastTSBuiltin
   };
   }
@@ -124,7 +124,7 @@ namespace clang {
   enum {
     LastTIBuiltin = clang::Builtin::FirstTSBuiltin - 1,
 #define BUILTIN(ID, TYPE, ATTRS) BI##ID,
-#include "clang/Basic/BuiltinsSPIRV.inc"
+#include "BuiltinsSPIRV.inc"
     LastTSBuiltin
   };
   } // namespace SPIRV
@@ -134,11 +134,11 @@ namespace clang {
   enum {
     LastTIBuiltin = clang::Builtin::FirstTSBuiltin - 1,
 #define BUILTIN(ID, TYPE, ATTRS) BI##ID,
-#include "clang/Basic/BuiltinsX86.inc"
+#include "BuiltinsX86.inc"
     FirstX86_64Builtin,
     LastX86CommonBuiltin = FirstX86_64Builtin - 1,
 #define BUILTIN(ID, TYPE, ATTRS) BI##ID,
-#include "clang/Basic/BuiltinsX86_64.inc"
+#include "BuiltinsX86_64.inc"
     LastTSBuiltin
   };
   }
@@ -169,7 +169,7 @@ namespace clang {
     FirstRVVBuiltin = clang::Builtin::FirstTSBuiltin,
     LastRVVBuiltin = RISCVVector::FirstTSBuiltin - 1,
 #define BUILTIN(ID, TYPE, ATTRS) BI##ID,
-#include "clang/Basic/BuiltinsRISCV.inc"
+#include "BuiltinsRISCV.inc"
     LastTSBuiltin
   };
   } // namespace RISCV
@@ -255,7 +255,7 @@ namespace clang {
   // Shared between SVE/SME and NEON
   enum ImmCheckType {
 #define LLVM_GET_ARM_INTRIN_IMMCHECKTYPES
-#include "clang/Basic/arm_immcheck_types.inc"
+#include "arm_immcheck_types.inc"
 #undef LLVM_GET_ARM_INTRIN_IMMCHECKTYPES
   };
 
@@ -269,24 +269,24 @@ namespace clang {
 
   public:
 #define LLVM_GET_SVE_TYPEFLAGS
-#include "clang/Basic/arm_sve_typeflags.inc"
+#include "arm_sve_typeflags.inc"
 #undef LLVM_GET_SVE_TYPEFLAGS
 
     enum EltType {
 #define LLVM_GET_SVE_ELTTYPES
-#include "clang/Basic/arm_sve_typeflags.inc"
+#include "arm_sve_typeflags.inc"
 #undef LLVM_GET_SVE_ELTTYPES
     };
 
     enum MemEltType {
 #define LLVM_GET_SVE_MEMELTTYPES
-#include "clang/Basic/arm_sve_typeflags.inc"
+#include "arm_sve_typeflags.inc"
 #undef LLVM_GET_SVE_MEMELTTYPES
     };
 
     enum MergeType {
 #define LLVM_GET_SVE_MERGETYPES
-#include "clang/Basic/arm_sve_typeflags.inc"
+#include "arm_sve_typeflags.inc"
 #undef LLVM_GET_SVE_MERGETYPES
     };
 
@@ -357,7 +357,7 @@ namespace clang {
   enum {
     LastTIBuiltin = clang::Builtin::FirstTSBuiltin - 1,
 #define BUILTIN(ID, TYPE, ATTRS) BI##ID,
-#include "clang/Basic/BuiltinsHexagon.inc"
+#include "BuiltinsHexagon.inc"
     LastTSBuiltin
   };
   }
diff --git a/clang/include/clang/Basic/TokenKinds.def b/clang/include/clang/Basic/TokenKinds.def
index 8902a20b07ff..8f61a5e42a8c 100644
--- a/clang/include/clang/Basic/TokenKinds.def
+++ b/clang/include/clang/Basic/TokenKinds.def
@@ -798,7 +798,7 @@ KEYWORD(__builtin_sycl_unique_stable_name, KEYSYCL)
 #ifndef KEYWORD_ATTRIBUTE
 #define KEYWORD_ATTRIBUTE(X, HASARG, EMPTY) KEYWORD(EMPTY ## X, KEYALL)
 #endif
-#include "clang/Basic/RegularKeywordAttrInfo.inc"
+#include "RegularKeywordAttrInfo.inc"
 
 // Clang-specific keywords enabled only in testing.
 TESTING_KEYWORD(__unknown_anytype , KEYALL)
diff --git a/clang/include/clang/Basic/TokenKinds.h b/clang/include/clang/Basic/TokenKinds.h
index 1b133dde8958..c8e00e303526 100644
--- a/clang/include/clang/Basic/TokenKinds.h
+++ b/clang/include/clang/Basic/TokenKinds.h
@@ -110,7 +110,7 @@ bool isPragmaAnnotation(TokenKind K);
 inline constexpr bool isRegularKeywordAttribute(TokenKind K) {
   return (false
 #define KEYWORD_ATTRIBUTE(X, ...) || (K == tok::kw_##X)
-#include "clang/Basic/RegularKeywordAttrInfo.inc"
+#include "RegularKeywordAttrInfo.inc"
   );
 }
 
diff --git a/clang/include/clang/CIR/Dialect/IR/CIRAttrs.h b/clang/include/clang/CIR/Dialect/IR/CIRAttrs.h
index 438fb7d09608..fdde67ee7f72 100644
--- a/clang/include/clang/CIR/Dialect/IR/CIRAttrs.h
+++ b/clang/include/clang/CIR/Dialect/IR/CIRAttrs.h
@@ -31,6 +31,6 @@ class RecordDecl;
 } // namespace clang
 
 #define GET_ATTRDEF_CLASSES
-#include "clang/CIR/Dialect/IR/CIROpsAttributes.h.inc"
+#include "CIROpsAttributes.h.inc"
 
 #endif // LLVM_CLANG_CIR_DIALECT_IR_CIRATTRS_H
diff --git a/clang/include/clang/CIR/Dialect/IR/CIRDialect.h b/clang/include/clang/CIR/Dialect/IR/CIRDialect.h
index 683176b139ca..ab9afc515911 100644
--- a/clang/include/clang/CIR/Dialect/IR/CIRDialect.h
+++ b/clang/include/clang/CIR/Dialect/IR/CIRDialect.h
@@ -27,12 +27,12 @@
 #include "mlir/Interfaces/SideEffectInterfaces.h"
 
 #include "clang/CIR/Dialect/IR/CIRAttrs.h"
-#include "clang/CIR/Dialect/IR/CIROpsDialect.h.inc"
+#include "CIROpsDialect.h.inc"
 
 // TableGen'erated files for MLIR dialects require that a macro be defined when
 // they are included.  GET_OP_CLASSES tells the file to define the classes for
 // the operations of that dialect.
 #define GET_OP_CLASSES
-#include "clang/CIR/Dialect/IR/CIROps.h.inc"
+#include "CIROps.h.inc"
 
 #endif // LLVM_CLANG_CIR_DIALECT_IR_CIRDIALECT_H
diff --git a/clang/include/clang/CIR/Dialect/IR/CIRTypes.h b/clang/include/clang/CIR/Dialect/IR/CIRTypes.h
index 5d1eb17e146d..075948d62b05 100644
--- a/clang/include/clang/CIR/Dialect/IR/CIRTypes.h
+++ b/clang/include/clang/CIR/Dialect/IR/CIRTypes.h
@@ -29,6 +29,6 @@ bool isAnyFloatingPointType(mlir::Type t);
 //===----------------------------------------------------------------------===//
 
 #define GET_TYPEDEF_CLASSES
-#include "clang/CIR/Dialect/IR/CIROpsTypes.h.inc"
+#include "CIROpsTypes.h.inc"
 
 #endif // MLIR_DIALECT_CIR_IR_CIRTYPES_H_
diff --git a/clang/include/clang/CIR/Interfaces/CIRFPTypeInterface.h b/clang/include/clang/CIR/Interfaces/CIRFPTypeInterface.h
index 40b85ef6cfb6..665db58c6bc0 100644
--- a/clang/include/clang/CIR/Interfaces/CIRFPTypeInterface.h
+++ b/clang/include/clang/CIR/Interfaces/CIRFPTypeInterface.h
@@ -17,6 +17,6 @@
 #include "llvm/ADT/APFloat.h"
 
 /// Include the tablegen'd interface declarations.
-#include "clang/CIR/Interfaces/CIRFPTypeInterface.h.inc"
+#include "CIRFPTypeInterface.h.inc"
 
 #endif // LLVM_CLANG_INCLUDE_CLANG_CIR_INTERFACES_CIRFPTYPEINTERFACE_H
diff --git a/clang/include/clang/Driver/Options.h b/clang/include/clang/Driver/Options.h
index 0797410e9940..d14417d2452b 100644
--- a/clang/include/clang/Driver/Options.h
+++ b/clang/include/clang/Driver/Options.h
@@ -44,7 +44,7 @@ enum ClangVisibility {
 enum ID {
     OPT_INVALID = 0, // This is not an option ID.
 #define OPTION(...) LLVM_MAKE_OPT_ID(__VA_ARGS__),
-#include "clang/Driver/Options.inc"
+#include "Options.inc"
     LastOption
 #undef OPTION
   };
diff --git a/clang/include/clang/Sema/Template.h b/clang/include/clang/Sema/Template.h
index 4206bd50b13d..9ec19dc0496b 100644
--- a/clang/include/clang/Sema/Template.h
+++ b/clang/include/clang/Sema/Template.h
@@ -635,7 +635,7 @@ enum class TemplateSubstitutionKind : char {
 #define CAPTURED(DERIVED, BASE)
 #define IMPLICITPARAM(DERIVED, BASE)
 
-#include "clang/AST/DeclNodes.inc"
+#include "DeclNodes.inc"
 
     enum class RewriteKind { None, RewriteSpaceshipAsEqualEqual };
 
diff --git a/clang/include/clang/StaticAnalyzer/Checkers/BuiltinCheckerRegistration.h b/clang/include/clang/StaticAnalyzer/Checkers/BuiltinCheckerRegistration.h
index bdfe3901c5b8..0dbe56b9163b 100644
--- a/clang/include/clang/StaticAnalyzer/Checkers/BuiltinCheckerRegistration.h
+++ b/clang/include/clang/StaticAnalyzer/Checkers/BuiltinCheckerRegistration.h
@@ -25,7 +25,7 @@ class CheckerManager;
 #define CHECKER(FULLNAME, CLASS, HELPTEXT, DOC_URI, IS_HIDDEN)                 \
   void register##CLASS(CheckerManager &mgr);                                   \
   bool shouldRegister##CLASS(const CheckerManager &mgr);
-#include "clang/StaticAnalyzer/Checkers/Checkers.inc"
+#include "Checkers.inc"
 #undef CHECKER
 #undef GET_CHECKERS
 
diff --git a/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h b/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h
index 2c970301879d..90d55952af40 100644
--- a/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h
+++ b/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h
@@ -432,7 +432,7 @@ AnalyzerOptions::getRegisteredCheckers(bool IncludeExperimental) {
 #define GET_CHECKERS
 #define CHECKER(FULLNAME, CLASS, HELPTEXT, DOC_URI, IS_HIDDEN)                 \
   llvm::StringLiteral(FULLNAME),
-#include "clang/StaticAnalyzer/Checkers/Checkers.inc"
+#include "Checkers.inc"
 #undef CHECKER
 #undef GET_CHECKERS
   };
@@ -450,7 +450,7 @@ AnalyzerOptions::getRegisteredPackages(bool IncludeExperimental) {
   static constexpr llvm::StringLiteral StaticAnalyzerPackageNames[] = {
 #define GET_PACKAGES
 #define PACKAGE(FULLNAME) llvm::StringLiteral(FULLNAME),
-#include "clang/StaticAnalyzer/Checkers/Checkers.inc"
+#include "Checkers.inc"
 #undef PACKAGE
 #undef GET_PACKAGES
   };
diff --git a/clang/include/clang/Tooling/Syntax/Nodes.h b/clang/include/clang/Tooling/Syntax/Nodes.h
index c4f31900d0ce..15c2b98ab2de 100644
--- a/clang/include/clang/Tooling/Syntax/Nodes.h
+++ b/clang/include/clang/Tooling/Syntax/Nodes.h
@@ -31,7 +31,7 @@ namespace syntax {
 /// of syntax::Node.
 enum class NodeKind : uint16_t {
 #define CONCRETE_NODE(Kind, Base) Kind,
-#include "clang/Tooling/Syntax/Nodes.inc"
+#include "Nodes.inc"
 };
 /// For debugging purposes.
 raw_ostream &operator<<(raw_ostream &OS, NodeKind K);
@@ -109,7 +109,7 @@ enum class NodeRole : uint8_t {
 /// For debugging purposes.
 raw_ostream &operator<<(raw_ostream &OS, NodeRole R);
 
-#include "clang/Tooling/Syntax/NodeClasses.inc"
+#include "NodeClasses.inc"
 
 /// Models a `nested-name-specifier`. C++ [expr.prim.id.qual]
 /// e.g. the `std::vector<int>::` in `std::vector<int>::size`.
@@ -583,7 +583,7 @@ public:
   inline bool Kind::classof(const Node *N) {                                   \
     return N->getKind() >= NodeKind::First && N->getKind() <= NodeKind::Last;  \
   }
-#include "clang/Tooling/Syntax/Nodes.inc"
+#include "Nodes.inc"
 
 } // namespace syntax
 } // namespace clang
diff --git a/clang/lib/Basic/CMakeLists.txt b/clang/lib/Basic/CMakeLists.txt
index 331dfbb3f4b6..83e85f90373b 100644
--- a/clang/lib/Basic/CMakeLists.txt
+++ b/clang/lib/Basic/CMakeLists.txt
@@ -47,7 +47,7 @@ add_custom_command(OUTPUT "${version_inc}"
 # Mark the generated header as being generated.
 set_source_files_properties("${version_inc}"
   PROPERTIES GENERATED TRUE
-             HEADER_FILE_ONLY TRUE)
+             HEADER_FILE_ONLY FALSE)
 
 if(CLANG_VENDOR)
   set_source_files_properties(Version.cpp
@@ -132,6 +132,7 @@ add_clang_library(clangBasic
   DEPENDS
   omp_gen
   ClangDriverOptions
+  ClangDiagnosticCommon
   # These generated headers are included transitively.
   ARMTargetParserTableGen
   AArch64TargetParserTableGen
diff --git a/clang/lib/Basic/Targets/BPF.cpp b/clang/lib/Basic/Targets/BPF.cpp
index f4684765b7ff..0eb5825e0e31 100644
--- a/clang/lib/Basic/Targets/BPF.cpp
+++ b/clang/lib/Basic/Targets/BPF.cpp
@@ -11,7 +11,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "BPF.h"
-#include "Targets.h"
+#include "../Targets.h"
 #include "clang/Basic/MacroBuilder.h"
 #include "clang/Basic/TargetBuiltins.h"
 #include "llvm/ADT/StringRef.h"
@@ -70,8 +70,8 @@ void BPFTargetInfo::getTargetDefines(const LangOptions &Opts,
   }
 }
 
-static constexpr llvm::StringLiteral ValidCPUNames[] = {"generic", "v1", "v2",
-                                                        "v3", "v4", "probe"};
+static constexpr llvm::StringLiteral ValidCPUNames[] = {
+    "generic", "v1", "v2", "v3", "v4", "probe"};
 
 bool BPFTargetInfo::isValidCPUName(StringRef Name) const {
   return llvm::is_contained(ValidCPUNames, Name);
diff --git a/clang/lib/Basic/Targets/DirectX.cpp b/clang/lib/Basic/Targets/DirectX.cpp
index 0dd27e6e93b3..479fd865fdb3 100644
--- a/clang/lib/Basic/Targets/DirectX.cpp
+++ b/clang/lib/Basic/Targets/DirectX.cpp
@@ -11,7 +11,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "DirectX.h"
-#include "Targets.h"
+#include "../Targets.h"
 
 using namespace clang;
 using namespace clang::targets;
diff --git a/clang/lib/Basic/Targets/Hexagon.cpp b/clang/lib/Basic/Targets/Hexagon.cpp
index 2e173e01ed8e..5e9431b58ffc 100644
--- a/clang/lib/Basic/Targets/Hexagon.cpp
+++ b/clang/lib/Basic/Targets/Hexagon.cpp
@@ -11,7 +11,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "Hexagon.h"
-#include "Targets.h"
+#include "../Targets.h"
 #include "clang/Basic/MacroBuilder.h"
 #include "clang/Basic/TargetBuiltins.h"
 #include "llvm/ADT/StringSwitch.h"
@@ -158,36 +158,195 @@ bool HexagonTargetInfo::handleTargetFeatures(std::vector<std::string> &Features,
 
 const char *const HexagonTargetInfo::GCCRegNames[] = {
     // Scalar registers:
-    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11",
-    "r12", "r13", "r14", "r15", "r16", "r17", "r18", "r19", "r20", "r21",
-    "r22", "r23", "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",
-    "r1:0", "r3:2", "r5:4", "r7:6", "r9:8", "r11:10", "r13:12", "r15:14",
-    "r17:16", "r19:18", "r21:20", "r23:22", "r25:24", "r27:26", "r29:28",
+    "r0",
+    "r1",
+    "r2",
+    "r3",
+    "r4",
+    "r5",
+    "r6",
+    "r7",
+    "r8",
+    "r9",
+    "r10",
+    "r11",
+    "r12",
+    "r13",
+    "r14",
+    "r15",
+    "r16",
+    "r17",
+    "r18",
+    "r19",
+    "r20",
+    "r21",
+    "r22",
+    "r23",
+    "r24",
+    "r25",
+    "r26",
+    "r27",
+    "r28",
+    "r29",
+    "r30",
+    "r31",
+    "r1:0",
+    "r3:2",
+    "r5:4",
+    "r7:6",
+    "r9:8",
+    "r11:10",
+    "r13:12",
+    "r15:14",
+    "r17:16",
+    "r19:18",
+    "r21:20",
+    "r23:22",
+    "r25:24",
+    "r27:26",
+    "r29:28",
     "r31:30",
     // Predicate registers:
-    "p0", "p1", "p2", "p3",
+    "p0",
+    "p1",
+    "p2",
+    "p3",
     // Control registers:
-    "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11",
-    "c12", "c13", "c14", "c15", "c16", "c17", "c18", "c19", "c20", "c21",
-    "c22", "c23", "c24", "c25", "c26", "c27", "c28", "c29", "c30", "c31",
-    "c1:0", "c3:2", "c5:4", "c7:6", "c9:8", "c11:10", "c13:12", "c15:14",
-    "c17:16", "c19:18", "c21:20", "c23:22", "c25:24", "c27:26", "c29:28",
+    "c0",
+    "c1",
+    "c2",
+    "c3",
+    "c4",
+    "c5",
+    "c6",
+    "c7",
+    "c8",
+    "c9",
+    "c10",
+    "c11",
+    "c12",
+    "c13",
+    "c14",
+    "c15",
+    "c16",
+    "c17",
+    "c18",
+    "c19",
+    "c20",
+    "c21",
+    "c22",
+    "c23",
+    "c24",
+    "c25",
+    "c26",
+    "c27",
+    "c28",
+    "c29",
+    "c30",
+    "c31",
+    "c1:0",
+    "c3:2",
+    "c5:4",
+    "c7:6",
+    "c9:8",
+    "c11:10",
+    "c13:12",
+    "c15:14",
+    "c17:16",
+    "c19:18",
+    "c21:20",
+    "c23:22",
+    "c25:24",
+    "c27:26",
+    "c29:28",
     "c31:30",
     // Control register aliases:
-    "sa0", "lc0", "sa1", "lc1", "p3:0", "m0",  "m1",  "usr", "pc", "ugp",
-    "gp", "cs0", "cs1", "upcyclelo", "upcyclehi", "framelimit", "framekey",
-    "pktcountlo", "pktcounthi", "utimerlo", "utimerhi",
-    "upcycle", "pktcount", "utimer",
+    "sa0",
+    "lc0",
+    "sa1",
+    "lc1",
+    "p3:0",
+    "m0",
+    "m1",
+    "usr",
+    "pc",
+    "ugp",
+    "gp",
+    "cs0",
+    "cs1",
+    "upcyclelo",
+    "upcyclehi",
+    "framelimit",
+    "framekey",
+    "pktcountlo",
+    "pktcounthi",
+    "utimerlo",
+    "utimerhi",
+    "upcycle",
+    "pktcount",
+    "utimer",
     // HVX vector registers:
-    "v0", "v1", "v2", "v3", "v4", "v5", "v6", "v7", "v8", "v9", "v10", "v11",
-    "v12", "v13", "v14", "v15", "v16", "v17", "v18", "v19", "v20", "v21",
-    "v22", "v23", "v24", "v25", "v26", "v27", "v28", "v29", "v30", "v31",
-    "v1:0", "v3:2", "v5:4", "v7:6", "v9:8", "v11:10", "v13:12", "v15:14",
-    "v17:16", "v19:18", "v21:20", "v23:22", "v25:24", "v27:26", "v29:28",
+    "v0",
+    "v1",
+    "v2",
+    "v3",
+    "v4",
+    "v5",
+    "v6",
+    "v7",
+    "v8",
+    "v9",
+    "v10",
+    "v11",
+    "v12",
+    "v13",
+    "v14",
+    "v15",
+    "v16",
+    "v17",
+    "v18",
+    "v19",
+    "v20",
+    "v21",
+    "v22",
+    "v23",
+    "v24",
+    "v25",
+    "v26",
+    "v27",
+    "v28",
+    "v29",
+    "v30",
+    "v31",
+    "v1:0",
+    "v3:2",
+    "v5:4",
+    "v7:6",
+    "v9:8",
+    "v11:10",
+    "v13:12",
+    "v15:14",
+    "v17:16",
+    "v19:18",
+    "v21:20",
+    "v23:22",
+    "v25:24",
+    "v27:26",
+    "v29:28",
     "v31:30",
-    "v3:0", "v7:4", "v11:8", "v15:12", "v19:16", "v23:20", "v27:24", "v31:28",
+    "v3:0",
+    "v7:4",
+    "v11:8",
+    "v15:12",
+    "v19:16",
+    "v23:20",
+    "v27:24",
+    "v31:28",
     // HVX vector predicates:
-    "q0", "q1", "q2", "q3",
+    "q0",
+    "q1",
+    "q2",
+    "q3",
 };
 
 ArrayRef<const char *> HexagonTargetInfo::getGCCRegNames() const {
diff --git a/clang/lib/Basic/Targets/Mips.cpp b/clang/lib/Basic/Targets/Mips.cpp
index d56995e3ccc4..9b6697290965 100644
--- a/clang/lib/Basic/Targets/Mips.cpp
+++ b/clang/lib/Basic/Targets/Mips.cpp
@@ -11,7 +11,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "Mips.h"
-#include "Targets.h"
+#include "../Targets.h"
 #include "clang/Basic/Diagnostic.h"
 #include "clang/Basic/MacroBuilder.h"
 #include "clang/Basic/TargetBuiltins.h"
@@ -47,7 +47,7 @@ static constexpr llvm::StringLiteral ValidCPUNames[] = {
     {"mips1"},  {"mips2"},    {"mips3"},    {"mips4"},    {"mips5"},
     {"mips32"}, {"mips32r2"}, {"mips32r3"}, {"mips32r5"}, {"mips32r6"},
     {"mips64"}, {"mips64r2"}, {"mips64r3"}, {"mips64r5"}, {"mips64r6"},
-    {"octeon"}, {"octeon+"}, {"p5600"}};
+    {"octeon"}, {"octeon+"},  {"p5600"}};
 
 bool MipsTargetInfo::isValidCPUName(StringRef Name) const {
   return llvm::is_contained(ValidCPUNames, Name);
@@ -60,12 +60,12 @@ void MipsTargetInfo::fillValidCPUList(
 
 unsigned MipsTargetInfo::getISARev() const {
   return llvm::StringSwitch<unsigned>(getCPU())
-             .Cases("mips32", "mips64", 1)
-             .Cases("mips32r2", "mips64r2", "octeon", "octeon+", 2)
-             .Cases("mips32r3", "mips64r3", 3)
-             .Cases("mips32r5", "mips64r5", 5)
-             .Cases("mips32r6", "mips64r6", 6)
-             .Default(0);
+      .Cases("mips32", "mips64", 1)
+      .Cases("mips32r2", "mips64r2", "octeon", "octeon+", 2)
+      .Cases("mips32r3", "mips64r3", 3)
+      .Cases("mips32r5", "mips64r5", 5)
+      .Cases("mips32r6", "mips64r6", 6)
+      .Default(0);
 }
 
 void MipsTargetInfo::getTargetDefines(const LangOptions &Opts,
@@ -143,7 +143,7 @@ void MipsTargetInfo::getTargetDefines(const LangOptions &Opts,
   case FP64:
     Builder.defineMacro("__mips_fpr", Twine(64));
     break;
-}
+  }
 
   if (FPMode == FP64 || IsSingleFloat)
     Builder.defineMacro("_MIPS_FPSET", Twine(32));
@@ -262,14 +262,14 @@ bool MipsTargetInfo::validateTarget(DiagnosticsEngine &Diags) const {
     return false;
   }
   // Mips revision 6 and -mfp32 are incompatible
-  if (FPMode != FP64 && FPMode != FPXX && (CPU == "mips32r6" ||
-      CPU == "mips64r6")) {
+  if (FPMode != FP64 && FPMode != FPXX &&
+      (CPU == "mips32r6" || CPU == "mips64r6")) {
     Diags.Report(diag::err_opt_not_valid_with_opt) << "-mfp32" << CPU;
     return false;
   }
   // Option -mfp64 permitted on Mips32 iff revision 2 or higher is present
-  if (FPMode == FP64 && (CPU == "mips1" || CPU == "mips2" ||
-      getISARev() < 2) && ABI == "o32") {
+  if (FPMode == FP64 && (CPU == "mips1" || CPU == "mips2" || getISARev() < 2) &&
+      ABI == "o32") {
     Diags.Report(diag::err_mips_fp64_req) << "-mfp64";
     return false;
   }
diff --git a/clang/lib/Basic/Targets/NVPTX.cpp b/clang/lib/Basic/Targets/NVPTX.cpp
index 9be12cbe7ac1..67a6519a2792 100644
--- a/clang/lib/Basic/Targets/NVPTX.cpp
+++ b/clang/lib/Basic/Targets/NVPTX.cpp
@@ -11,7 +11,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "NVPTX.h"
-#include "Targets.h"
+#include "../Targets.h"
 #include "clang/Basic/Builtins.h"
 #include "clang/Basic/MacroBuilder.h"
 #include "clang/Basic/TargetBuiltins.h"
@@ -285,24 +285,25 @@ void NVPTXTargetInfo::getTargetDefines(const LangOptions &Opts,
         return "1000";
       case OffloadArch::SM_101:
       case OffloadArch::SM_101a:
-         return "1010";
+        return "1010";
       case OffloadArch::SM_120:
       case OffloadArch::SM_120a:
-         return "1200";
+        return "1200";
       }
       llvm_unreachable("unhandled OffloadArch");
     }();
     Builder.defineMacro("__CUDA_ARCH__", CUDAArchCode);
-    switch(GPU) {
-      case OffloadArch::SM_90a:
-      case OffloadArch::SM_100a:
-      case OffloadArch::SM_101a:
-      case OffloadArch::SM_120a:
-        Builder.defineMacro("__CUDA_ARCH_FEAT_SM" + CUDAArchCode.drop_back() + "_ALL", "1");
-        break;
-      default:
-        // Do nothing if this is not an enhanced architecture.
-        break;
+    switch (GPU) {
+    case OffloadArch::SM_90a:
+    case OffloadArch::SM_100a:
+    case OffloadArch::SM_101a:
+    case OffloadArch::SM_120a:
+      Builder.defineMacro(
+          "__CUDA_ARCH_FEAT_SM" + CUDAArchCode.drop_back() + "_ALL", "1");
+      break;
+    default:
+      // Do nothing if this is not an enhanced architecture.
+      break;
     }
   }
 }
diff --git a/clang/lib/Basic/Targets/OSTargets.h b/clang/lib/Basic/Targets/OSTargets.h
index 991efd2bde01..1e0e03596c4a 100644
--- a/clang/lib/Basic/Targets/OSTargets.h
+++ b/clang/lib/Basic/Targets/OSTargets.h
@@ -12,7 +12,7 @@
 #ifndef LLVM_CLANG_LIB_BASIC_TARGETS_OSTARGETS_H
 #define LLVM_CLANG_LIB_BASIC_TARGETS_OSTARGETS_H
 
-#include "Targets.h"
+#include "../Targets.h"
 
 namespace clang {
 namespace targets {
@@ -326,6 +326,7 @@ protected:
     if (Opts.CPlusPlus)
       Builder.defineMacro("_GNU_SOURCE");
   }
+
 public:
   using OSTargetInfo<Target>::OSTargetInfo;
 };
@@ -351,7 +352,7 @@ protected:
         Builder.defineMacro("__ANDROID_API__", "__ANDROID_MIN_SDK_VERSION__");
       }
     } else {
-        Builder.defineMacro("__gnu_linux__");
+      Builder.defineMacro("__gnu_linux__");
     }
     if (Opts.POSIXThreads)
       Builder.defineMacro("_REENTRANT");
@@ -660,8 +661,7 @@ public:
 };
 
 // AIX Target
-template <typename Target>
-class AIXTargetInfo : public OSTargetInfo<Target> {
+template <typename Target> class AIXTargetInfo : public OSTargetInfo<Target> {
 protected:
   void getOSDefines(const LangOptions &Opts, const llvm::Triple &Triple,
                     MacroBuilder &Builder) const override {
diff --git a/clang/lib/Basic/Targets/SPIR.cpp b/clang/lib/Basic/Targets/SPIR.cpp
index f242fedc1ad6..e223b90a54a8 100644
--- a/clang/lib/Basic/Targets/SPIR.cpp
+++ b/clang/lib/Basic/Targets/SPIR.cpp
@@ -11,8 +11,8 @@
 //===----------------------------------------------------------------------===//
 
 #include "SPIR.h"
+#include "../Targets.h"
 #include "AMDGPU.h"
-#include "Targets.h"
 #include "clang/Basic/MacroBuilder.h"
 #include "clang/Basic/TargetBuiltins.h"
 #include "llvm/TargetParser/TargetParser.h"
diff --git a/clang/lib/Basic/Targets/SPIR.h b/clang/lib/Basic/Targets/SPIR.h
index c0849b69dcdb..2d99b2e55a71 100644
--- a/clang/lib/Basic/Targets/SPIR.h
+++ b/clang/lib/Basic/Targets/SPIR.h
@@ -13,7 +13,7 @@
 #ifndef LLVM_CLANG_LIB_BASIC_TARGETS_SPIR_H
 #define LLVM_CLANG_LIB_BASIC_TARGETS_SPIR_H
 
-#include "Targets.h"
+#include "../Targets.h"
 #include "clang/Basic/TargetInfo.h"
 #include "clang/Basic/TargetOptions.h"
 #include "llvm/Support/Compiler.h"
@@ -190,9 +190,7 @@ public:
                                                             : CCCR_Warning;
   }
 
-  CallingConv getDefaultCallingConv() const override {
-    return CC_SpirFunction;
-  }
+  CallingConv getDefaultCallingConv() const override { return CC_SpirFunction; }
 
   void setAddressSpaceMap(bool DefaultIsGeneric) {
     AddrSpaceMap = DefaultIsGeneric ? &SPIRDefIsGenMap : &SPIRDefIsPrivMap;
diff --git a/clang/lib/Basic/Targets/Sparc.cpp b/clang/lib/Basic/Targets/Sparc.cpp
index d1a891092b0f..b62e12a4a98f 100644
--- a/clang/lib/Basic/Targets/Sparc.cpp
+++ b/clang/lib/Basic/Targets/Sparc.cpp
@@ -11,7 +11,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "Sparc.h"
-#include "Targets.h"
+#include "../Targets.h"
 #include "clang/Basic/MacroBuilder.h"
 #include "llvm/ADT/StringSwitch.h"
 
@@ -20,16 +20,88 @@ using namespace clang::targets;
 
 const char *const SparcTargetInfo::GCCRegNames[] = {
     // Integer registers
-    "r0",  "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7",  "r8",  "r9",  "r10",
-    "r11", "r12", "r13", "r14", "r15", "r16", "r17", "r18", "r19", "r20", "r21",
-    "r22", "r23", "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",
+    "r0",
+    "r1",
+    "r2",
+    "r3",
+    "r4",
+    "r5",
+    "r6",
+    "r7",
+    "r8",
+    "r9",
+    "r10",
+    "r11",
+    "r12",
+    "r13",
+    "r14",
+    "r15",
+    "r16",
+    "r17",
+    "r18",
+    "r19",
+    "r20",
+    "r21",
+    "r22",
+    "r23",
+    "r24",
+    "r25",
+    "r26",
+    "r27",
+    "r28",
+    "r29",
+    "r30",
+    "r31",
 
     // Floating-point registers
-    "f0",  "f1",  "f2",  "f3",  "f4",  "f5",  "f6",  "f7",  "f8",  "f9",  "f10",
-    "f11", "f12", "f13", "f14", "f15", "f16", "f17", "f18", "f19", "f20", "f21",
-    "f22", "f23", "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31", "f32",
-    "f34", "f36", "f38", "f40", "f42", "f44", "f46", "f48", "f50", "f52", "f54",
-    "f56", "f58", "f60", "f62",
+    "f0",
+    "f1",
+    "f2",
+    "f3",
+    "f4",
+    "f5",
+    "f6",
+    "f7",
+    "f8",
+    "f9",
+    "f10",
+    "f11",
+    "f12",
+    "f13",
+    "f14",
+    "f15",
+    "f16",
+    "f17",
+    "f18",
+    "f19",
+    "f20",
+    "f21",
+    "f22",
+    "f23",
+    "f24",
+    "f25",
+    "f26",
+    "f27",
+    "f28",
+    "f29",
+    "f30",
+    "f31",
+    "f32",
+    "f34",
+    "f36",
+    "f38",
+    "f40",
+    "f42",
+    "f44",
+    "f46",
+    "f48",
+    "f50",
+    "f52",
+    "f54",
+    "f56",
+    "f58",
+    "f60",
+    "f62",
 };
 
 ArrayRef<const char *> SparcTargetInfo::getGCCRegNames() const {
diff --git a/clang/lib/Basic/Targets/TCE.cpp b/clang/lib/Basic/Targets/TCE.cpp
index 91194b568a09..a9be4d16a578 100644
--- a/clang/lib/Basic/Targets/TCE.cpp
+++ b/clang/lib/Basic/Targets/TCE.cpp
@@ -11,7 +11,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "TCE.h"
-#include "Targets.h"
+#include "../Targets.h"
 #include "clang/Basic/MacroBuilder.h"
 
 using namespace clang;
diff --git a/clang/lib/Basic/Targets/WebAssembly.cpp b/clang/lib/Basic/Targets/WebAssembly.cpp
index 7b0fd0c841ba..8851d75e4a7b 100644
--- a/clang/lib/Basic/Targets/WebAssembly.cpp
+++ b/clang/lib/Basic/Targets/WebAssembly.cpp
@@ -11,7 +11,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "WebAssembly.h"
-#include "Targets.h"
+#include "../Targets.h"
 #include "clang/Basic/Builtins.h"
 #include "clang/Basic/Diagnostic.h"
 #include "clang/Basic/TargetBuiltins.h"
diff --git a/clang/lib/CodeGen/CMakeLists.txt b/clang/lib/CodeGen/CMakeLists.txt
index 868ec847b963..ea3f1ae2d9f0 100644
--- a/clang/lib/CodeGen/CMakeLists.txt
+++ b/clang/lib/CodeGen/CMakeLists.txt
@@ -147,6 +147,7 @@ add_clang_library(clangCodeGen
   vt_gen
   intrinsics_gen
   ClangDriverOptions
+  ClangDiagnosticCommon
   # These generated headers are included transitively.
   ARMTargetParserTableGen
   AArch64TargetParserTableGen
diff --git a/clang/lib/CodeGen/Targets/AArch64.cpp b/clang/lib/CodeGen/Targets/AArch64.cpp
index 170ce1640367..36856e3ba9e5 100644
--- a/clang/lib/CodeGen/Targets/AArch64.cpp
+++ b/clang/lib/CodeGen/Targets/AArch64.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 #include "clang/AST/Decl.h"
 #include "clang/Basic/DiagnosticFrontend.h"
 #include "llvm/TargetParser/AArch64TargetParser.h"
@@ -222,7 +222,7 @@ void WindowsAArch64TargetCodeGenInfo::setTargetAttributes(
     return;
   addStackProbeTargetAttributes(D, GV, CGM);
 }
-}
+} // namespace
 
 llvm::Type *
 AArch64ABIInfo::convertFixedToScalableVectorType(const VectorType *VT) const {
@@ -412,7 +412,7 @@ ABIArgInfo AArch64ABIInfo::classifyArgumentType(QualType Ty, bool IsVariadicFn,
   // copy constructor are always indirect.
   if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI())) {
     return getNaturalAlignIndirect(Ty, /*ByVal=*/RAA ==
-                                     CGCXXABI::RAA_DirectInMemory);
+                                           CGCXXABI::RAA_DirectInMemory);
   }
 
   // Empty records are always ignored on Darwin, but actually passed in C++ mode
@@ -973,8 +973,8 @@ RValue AArch64ABIInfo::EmitAAPCSVAArg(Address VAListAddr, QualType Ty,
     auto BaseTyInfo = getContext().getTypeInfoInChars(QualType(Base, 0));
     llvm::Type *BaseTy = CGF.ConvertType(QualType(Base, 0));
     llvm::Type *HFATy = llvm::ArrayType::get(BaseTy, NumMembers);
-    Address Tmp = CGF.CreateTempAlloca(HFATy,
-                                       std::max(TyAlign, BaseTyInfo.Align));
+    Address Tmp =
+        CGF.CreateTempAlloca(HFATy, std::max(TyAlign, BaseTyInfo.Align));
 
     // On big-endian platforms, the value will be right-aligned in its slot.
     int Offset = 0;
@@ -985,7 +985,7 @@ RValue AArch64ABIInfo::EmitAAPCSVAArg(Address VAListAddr, QualType Ty,
     for (unsigned i = 0; i < NumMembers; ++i) {
       CharUnits BaseOffset = CharUnits::fromQuantity(16 * i + Offset);
       Address LoadAddr =
-        CGF.Builder.CreateConstInBoundsByteGEP(BaseAddr, BaseOffset);
+          CGF.Builder.CreateConstInBoundsByteGEP(BaseAddr, BaseOffset);
       LoadAddr = LoadAddr.withElementType(BaseTy);
 
       Address StoreAddr = CGF.Builder.CreateConstArrayGEP(Tmp, i);
@@ -1001,8 +1001,7 @@ RValue AArch64ABIInfo::EmitAAPCSVAArg(Address VAListAddr, QualType Ty,
     // It might be right-aligned in its slot.
     CharUnits SlotSize = BaseAddr.getAlignment();
     if (CGF.CGM.getDataLayout().isBigEndian() && !IsIndirect &&
-        (IsHFA || !isAggregateTypeForABI(Ty)) &&
-        TySize < SlotSize) {
+        (IsHFA || !isAggregateTypeForABI(Ty)) && TySize < SlotSize) {
       CharUnits Offset = SlotSize - TySize;
       BaseAddr = CGF.Builder.CreateConstInBoundsByteGEP(BaseAddr, Offset);
     }
diff --git a/clang/lib/CodeGen/Targets/AMDGPU.cpp b/clang/lib/CodeGen/Targets/AMDGPU.cpp
index 788eac5f2823..faca92533ef2 100644
--- a/clang/lib/CodeGen/Targets/AMDGPU.cpp
+++ b/clang/lib/CodeGen/Targets/AMDGPU.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 #include "clang/Basic/TargetOptions.h"
 #include "llvm/Support/AMDGPUAddrSpace.h"
 
@@ -41,8 +41,7 @@ private:
   }
 
 public:
-  explicit AMDGPUABIInfo(CodeGen::CodeGenTypes &CGT) :
-    DefaultABIInfo(CGT) {}
+  explicit AMDGPUABIInfo(CodeGen::CodeGenTypes &CGT) : DefaultABIInfo(CGT) {}
 
   ABIArgInfo classifyReturnType(QualType RetTy) const;
   ABIArgInfo classifyKernelArgumentType(QualType Ty) const;
@@ -69,8 +68,8 @@ bool AMDGPUABIInfo::isHomogeneousAggregateBaseType(QualType Ty) const {
   return true;
 }
 
-bool AMDGPUABIInfo::isHomogeneousAggregateSmallEnough(
-  const Type *Base, uint64_t Members) const {
+bool AMDGPUABIInfo::isHomogeneousAggregateSmallEnough(const Type *Base,
+                                                      uint64_t Members) const {
   uint32_t NumRegs = (getContext().getTypeSize(Base) + 31) / 32;
 
   // Homogeneous Aggregates may occupy at most 16 registers.
@@ -311,7 +310,8 @@ public:
   unsigned getOpenCLKernelCallingConv() const override;
 
   llvm::Constant *getNullPointer(const CodeGen::CodeGenModule &CGM,
-      llvm::PointerType *T, QualType QT) const override;
+                                 llvm::PointerType *T,
+                                 QualType QT) const override;
 
   LangAS getASTAllocaAddressSpace() const override {
     return getLangASFromTargetAS(
@@ -333,7 +333,7 @@ public:
   bool shouldEmitDWARFBitFieldSeparators() const override;
   void setCUDAKernelCallingConvention(const FunctionType *&FT) const override;
 };
-}
+} // namespace
 
 static bool requiresAMDGPUProtectedVisibility(const Decl *D,
                                               llvm::GlobalValue *GV) {
@@ -419,7 +419,8 @@ void AMDGPUTargetCodeGenInfo::emitTargetGlobals(
     CodeGen::CodeGenModule &CGM) const {
   StringRef Name = "__oclc_ABI_version";
   llvm::GlobalVariable *OriginalGV = CGM.getModule().getNamedGlobal(Name);
-  if (OriginalGV && !llvm::GlobalVariable::isExternalLinkage(OriginalGV->getLinkage()))
+  if (OriginalGV &&
+      !llvm::GlobalVariable::isExternalLinkage(OriginalGV->getLinkage()))
     return;
 
   if (CGM.getTarget().getTargetOpts().CodeObjectVersion ==
@@ -478,9 +479,10 @@ unsigned AMDGPUTargetCodeGenInfo::getOpenCLKernelCallingConv() const {
 // emitting null pointers in private and local address spaces, a null
 // pointer in generic address space is emitted which is casted to a
 // pointer in local or private address space.
-llvm::Constant *AMDGPUTargetCodeGenInfo::getNullPointer(
-    const CodeGen::CodeGenModule &CGM, llvm::PointerType *PT,
-    QualType QT) const {
+llvm::Constant *
+AMDGPUTargetCodeGenInfo::getNullPointer(const CodeGen::CodeGenModule &CGM,
+                                        llvm::PointerType *PT,
+                                        QualType QT) const {
   if (CGM.getContext().getTargetNullPointerValue(QT) == 0)
     return llvm::ConstantPointerNull::get(PT);
 
@@ -515,11 +517,9 @@ AMDGPUTargetCodeGenInfo::getGlobalVarAddressSpace(CodeGenModule &CGM,
   return DefaultGlobalAS;
 }
 
-llvm::SyncScope::ID
-AMDGPUTargetCodeGenInfo::getLLVMSyncScopeID(const LangOptions &LangOpts,
-                                            SyncScope Scope,
-                                            llvm::AtomicOrdering Ordering,
-                                            llvm::LLVMContext &Ctx) const {
+llvm::SyncScope::ID AMDGPUTargetCodeGenInfo::getLLVMSyncScopeID(
+    const LangOptions &LangOpts, SyncScope Scope, llvm::AtomicOrdering Ordering,
+    llvm::LLVMContext &Ctx) const {
   std::string Name;
   switch (Scope) {
   case SyncScope::HIPSingleThread:
diff --git a/clang/lib/CodeGen/Targets/ARC.cpp b/clang/lib/CodeGen/Targets/ARC.cpp
index 1904e8fdb388..59d48cc9b9a1 100644
--- a/clang/lib/CodeGen/Targets/ARC.cpp
+++ b/clang/lib/CodeGen/Targets/ARC.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
@@ -67,10 +67,9 @@ public:
       : TargetCodeGenInfo(std::make_unique<ARCABIInfo>(CGT)) {}
 };
 
-
 ABIArgInfo ARCABIInfo::getIndirectByRef(QualType Ty, bool HasFreeRegs) const {
-  return HasFreeRegs ? getNaturalAlignIndirectInReg(Ty) :
-                       getNaturalAlignIndirect(Ty, false);
+  return HasFreeRegs ? getNaturalAlignIndirectInReg(Ty)
+                     : getNaturalAlignIndirect(Ty, false);
 }
 
 ABIArgInfo ARCABIInfo::getIndirectByValue(QualType Ty) const {
@@ -122,9 +121,9 @@ ABIArgInfo ARCABIInfo::classifyArgumentType(QualType Ty,
     SmallVector<llvm::Type *, 3> Elements(SizeInRegs, Int32);
     llvm::Type *Result = llvm::StructType::get(LLVMContext, Elements);
 
-    return FreeRegs >= SizeInRegs ?
-        ABIArgInfo::getDirectInReg(Result) :
-        ABIArgInfo::getDirect(Result, 0, nullptr, false);
+    return FreeRegs >= SizeInRegs
+               ? ABIArgInfo::getDirectInReg(Result)
+               : ABIArgInfo::getDirect(Result, 0, nullptr, false);
   }
 
   if (const auto *EIT = Ty->getAs<BitIntType>())
diff --git a/clang/lib/CodeGen/Targets/ARM.cpp b/clang/lib/CodeGen/Targets/ARM.cpp
index 77641ce10e3d..057486c0cb84 100644
--- a/clang/lib/CodeGen/Targets/ARM.cpp
+++ b/clang/lib/CodeGen/Targets/ARM.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
@@ -26,7 +26,7 @@ public:
   ARMABIInfo(CodeGenTypes &CGT, ARMABIKind Kind) : ABIInfo(CGT), Kind(Kind) {
     setCCs();
     IsFloatABISoftFP = CGT.getCodeGenOpts().FloatABI == "softfp" ||
-        CGT.getCodeGenOpts().FloatABI == ""; // default
+                       CGT.getCodeGenOpts().FloatABI == ""; // default
   }
 
   bool isEABI() const {
@@ -180,12 +180,24 @@ public:
 
     const char *Kind;
     switch (Attr->getInterrupt()) {
-    case ARMInterruptAttr::Generic: Kind = ""; break;
-    case ARMInterruptAttr::IRQ:     Kind = "IRQ"; break;
-    case ARMInterruptAttr::FIQ:     Kind = "FIQ"; break;
-    case ARMInterruptAttr::SWI:     Kind = "SWI"; break;
-    case ARMInterruptAttr::ABORT:   Kind = "ABORT"; break;
-    case ARMInterruptAttr::UNDEF:   Kind = "UNDEF"; break;
+    case ARMInterruptAttr::Generic:
+      Kind = "";
+      break;
+    case ARMInterruptAttr::IRQ:
+      Kind = "IRQ";
+      break;
+    case ARMInterruptAttr::FIQ:
+      Kind = "FIQ";
+      break;
+    case ARMInterruptAttr::SWI:
+      Kind = "SWI";
+      break;
+    case ARMInterruptAttr::ABORT:
+      Kind = "ABORT";
+      break;
+    case ARMInterruptAttr::UNDEF:
+      Kind = "UNDEF";
+      break;
     }
 
     Fn->addFnAttr("interrupt", Kind);
@@ -229,7 +241,7 @@ void WindowsARMTargetCodeGenInfo::setTargetAttributes(
     return;
   addStackProbeTargetAttributes(D, GV, CGM);
 }
-}
+} // namespace
 
 void ARMABIInfo::computeInfo(CGFunctionInfo &FI) const {
   if (!::classifyReturnType(getCXXABI(), FI, *this))
@@ -240,7 +252,6 @@ void ARMABIInfo::computeInfo(CGFunctionInfo &FI) const {
     I.info = classifyArgumentType(I.type, FI.isVariadic(),
                                   FI.getCallingConvention());
 
-
   // Always honor user-specified calling convention.
   if (FI.getCallingConvention() != llvm::CallingConv::C)
     return;
@@ -290,8 +301,7 @@ void ARMABIInfo::setCCs() {
 ABIArgInfo ARMABIInfo::coerceIllegalVector(QualType Ty) const {
   uint64_t Size = getContext().getTypeSize(Ty);
   if (Size <= 32) {
-    llvm::Type *ResType =
-        llvm::Type::getInt32Ty(getVMContext());
+    llvm::Type *ResType = llvm::Type::getInt32Ty(getVMContext());
     return ABIArgInfo::getDirect(ResType);
   }
   if (Size == 64 || Size == 128) {
@@ -364,8 +374,8 @@ ABIArgInfo ARMABIInfo::classifyArgumentType(QualType Ty, bool isVariadic,
   //   64-bit containerized vectors or 128-bit containerized vectors with one
   //   to four Elements.
   // Variadic functions should always marshal to the base standard.
-  bool IsAAPCS_VFP =
-      !isVariadic && isEffectivelyAAPCS_VFP(functionCallConv, /* AAPCS16 */ false);
+  bool IsAAPCS_VFP = !isVariadic && isEffectivelyAAPCS_VFP(functionCallConv,
+                                                           /* AAPCS16 */ false);
 
   Ty = useFirstFieldIfTransparentUnion(Ty);
 
@@ -418,7 +428,7 @@ ABIArgInfo ARMABIInfo::classifyArgumentType(QualType Ty, bool isVariadic,
     if (isHomogeneousAggregate(Ty, Base, Members)) {
       assert(Base && Members <= 4 && "unexpected homogeneous aggregate");
       llvm::Type *Ty =
-        llvm::ArrayType::get(CGT.ConvertType(QualType(Base, 0)), Members);
+          llvm::ArrayType::get(CGT.ConvertType(QualType(Base, 0)), Members);
       return ABIArgInfo::getDirect(Ty, 0, nullptr, false);
     }
   }
@@ -453,7 +463,7 @@ ABIArgInfo ARMABIInfo::classifyArgumentType(QualType Ty, bool isVariadic,
   }
 
   // Otherwise, pass by coercing to a structure of the appropriate size.
-  llvm::Type* ElemTy;
+  llvm::Type *ElemTy;
   unsigned SizeRegs;
   // FIXME: Try to match the types of the arguments more accurately where
   // we can.
@@ -501,7 +511,8 @@ static bool isIntegerLikeType(QualType Ty, ASTContext &Context,
 
   // Otherwise, it must be a record type.
   const RecordType *RT = Ty->getAs<RecordType>();
-  if (!RT) return false;
+  if (!RT)
+    return false;
 
   // Ignore records with flexible arrays.
   const RecordDecl *RD = RT->getDecl();
@@ -557,8 +568,8 @@ ABIArgInfo ARMABIInfo::classifyReturnType(QualType RetTy, bool isVariadic,
                                           unsigned functionCallConv) const {
 
   // Variadic functions should always marshal to the base standard.
-  bool IsAAPCS_VFP =
-      !isVariadic && isEffectivelyAAPCS_VFP(functionCallConv, /* AAPCS16 */ true);
+  bool IsAAPCS_VFP = !isVariadic && isEffectivelyAAPCS_VFP(functionCallConv,
+                                                           /* AAPCS16 */ true);
 
   if (RetTy->isVoidType())
     return ABIArgInfo::getIgnore();
@@ -570,10 +581,9 @@ ABIArgInfo ARMABIInfo::classifyReturnType(QualType RetTy, bool isVariadic,
     // TODO: FP16/BF16 vectors should be converted to integer vectors
     // This check is similar  to isIllegalVectorType - refactor?
     if ((!getTarget().hasLegalHalfType() &&
-        (VT->getElementType()->isFloat16Type() ||
-         VT->getElementType()->isHalfType())) ||
-        (IsFloatABISoftFP &&
-         VT->getElementType()->isBFloat16Type()))
+         (VT->getElementType()->isFloat16Type() ||
+          VT->getElementType()->isHalfType())) ||
+        (IsFloatABISoftFP && VT->getElementType()->isBFloat16Type()))
       return coerceIllegalVector(RetTy);
   }
 
@@ -658,7 +668,7 @@ ABIArgInfo ARMABIInfo::classifyReturnType(QualType RetTy, bool isVariadic,
 
 /// isIllegalVector - check whether Ty is an illegal vector type.
 bool ARMABIInfo::isIllegalVectorType(QualType Ty) const {
-  if (const VectorType *VT = Ty->getAs<VectorType> ()) {
+  if (const VectorType *VT = Ty->getAs<VectorType>()) {
     // On targets that don't support half, fp16 or bfloat, they are expanded
     // into float, and we don't want the ABI to depend on whether or not they
     // are supported in hardware. Thus return false to coerce vectors of these
@@ -666,10 +676,9 @@ bool ARMABIInfo::isIllegalVectorType(QualType Ty) const {
     // We do not depend on hasLegalHalfType for bfloat as it is a
     // separate IR type.
     if ((!getTarget().hasLegalHalfType() &&
-        (VT->getElementType()->isFloat16Type() ||
-         VT->getElementType()->isHalfType())) ||
-        (IsFloatABISoftFP &&
-         VT->getElementType()->isBFloat16Type()))
+         (VT->getElementType()->isFloat16Type() ||
+          VT->getElementType()->isHalfType())) ||
+        (IsFloatABISoftFP && VT->getElementType()->isBFloat16Type()))
       return true;
     if (isAndroid()) {
       // Android shipped using Clang 3.1, which supported a slightly different
@@ -800,17 +809,17 @@ RValue ARMABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
   if (TySize > CharUnits::fromQuantity(16) && isIllegalVectorType(Ty)) {
     IsIndirect = true;
 
-  // ARMv7k passes structs bigger than 16 bytes indirectly, in space
-  // allocated by the caller.
+    // ARMv7k passes structs bigger than 16 bytes indirectly, in space
+    // allocated by the caller.
   } else if (TySize > CharUnits::fromQuantity(16) &&
              getABIKind() == ARMABIKind::AAPCS16_VFP &&
              !isHomogeneousAggregate(Ty, Base, Members)) {
     IsIndirect = true;
 
-  // Otherwise, bound the type's ABI alignment.
-  // The ABI alignment for 64-bit or 128-bit vectors is 8 for AAPCS and 4 for
-  // APCS. For AAPCS, the ABI alignment is at least 4-byte and at most 8-byte.
-  // Our callers should be prepared to handle an under-aligned address.
+    // Otherwise, bound the type's ABI alignment.
+    // The ABI alignment for 64-bit or 128-bit vectors is 8 for AAPCS and 4 for
+    // APCS. For AAPCS, the ABI alignment is at least 4-byte and at most 8-byte.
+    // Our callers should be prepared to handle an under-aligned address.
   } else if (getABIKind() == ARMABIKind::AAPCS_VFP ||
              getABIKind() == ARMABIKind::AAPCS) {
     TyAlignForABI = std::max(TyAlignForABI, CharUnits::fromQuantity(4));
diff --git a/clang/lib/CodeGen/Targets/AVR.cpp b/clang/lib/CodeGen/Targets/AVR.cpp
index 50547dd6dec5..80c759d51b17 100644
--- a/clang/lib/CodeGen/Targets/AVR.cpp
+++ b/clang/lib/CodeGen/Targets/AVR.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 #include "clang/Basic/DiagnosticFrontend.h"
 
 using namespace clang;
@@ -135,7 +135,8 @@ public:
     if (GV->isDeclaration())
       return;
     const auto *FD = dyn_cast_or_null<FunctionDecl>(D);
-    if (!FD) return;
+    if (!FD)
+      return;
     auto *Fn = cast<llvm::Function>(GV);
 
     if (FD->getAttr<AVRInterruptAttr>())
@@ -145,7 +146,7 @@ public:
       Fn->addFnAttr("signal");
   }
 };
-}
+} // namespace
 
 std::unique_ptr<TargetCodeGenInfo>
 CodeGen::createAVRTargetCodeGenInfo(CodeGenModule &CGM, unsigned NPR,
diff --git a/clang/lib/CodeGen/Targets/BPF.cpp b/clang/lib/CodeGen/Targets/BPF.cpp
index 2849222f7a18..21fc99f7c5bd 100644
--- a/clang/lib/CodeGen/Targets/BPF.cpp
+++ b/clang/lib/CodeGen/Targets/BPF.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
@@ -83,7 +83,6 @@ public:
     for (auto &I : FI.arguments())
       I.info = classifyArgumentType(I.type);
   }
-
 };
 
 class BPFTargetCodeGenInfo : public TargetCodeGenInfo {
@@ -92,7 +91,7 @@ public:
       : TargetCodeGenInfo(std::make_unique<BPFABIInfo>(CGT)) {}
 };
 
-}
+} // namespace
 
 std::unique_ptr<TargetCodeGenInfo>
 CodeGen::createBPFTargetCodeGenInfo(CodeGenModule &CGM) {
diff --git a/clang/lib/CodeGen/Targets/CSKY.cpp b/clang/lib/CodeGen/Targets/CSKY.cpp
index d8720afd1a71..456cb21b7b7b 100644
--- a/clang/lib/CodeGen/Targets/CSKY.cpp
+++ b/clang/lib/CodeGen/Targets/CSKY.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
diff --git a/clang/lib/CodeGen/Targets/DirectX.cpp b/clang/lib/CodeGen/Targets/DirectX.cpp
index 7935f7ae3700..42fb46cf0a98 100644
--- a/clang/lib/CodeGen/Targets/DirectX.cpp
+++ b/clang/lib/CodeGen/Targets/DirectX.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 #include "llvm/IR/DerivedTypes.h"
 
 using namespace clang;
diff --git a/clang/lib/CodeGen/Targets/Hexagon.cpp b/clang/lib/CodeGen/Targets/Hexagon.cpp
index 8fd2a81494d9..62158280dc2a 100644
--- a/clang/lib/CodeGen/Targets/Hexagon.cpp
+++ b/clang/lib/CodeGen/Targets/Hexagon.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
@@ -145,8 +145,8 @@ ABIArgInfo HexagonABIInfo::classifyReturnType(QualType RetTy) const {
     // HVX vectors are returned in vector registers or register pairs.
     if (T.hasFeature("hvx")) {
       assert(T.hasFeature("hvx-length64b") || T.hasFeature("hvx-length128b"));
-      uint64_t VecSize = T.hasFeature("hvx-length64b") ? 64*8 : 128*8;
-      if (Size == VecSize || Size == 2*VecSize)
+      uint64_t VecSize = T.hasFeature("hvx-length64b") ? 64 * 8 : 128 * 8;
+      if (Size == VecSize || Size == 2 * VecSize)
         return ABIArgInfo::getDirectInReg();
     }
     // Large vector types should be returned via memory.
@@ -219,10 +219,10 @@ Address HexagonABIInfo::EmitVAArgFromMemory(CodeGenFunction &CGF,
   // Round up to the minimum stack alignment for varargs which is 4 bytes.
   uint64_t Offset = llvm::alignTo(CGF.getContext().getTypeSize(Ty) / 8, 4);
 
-  __overflow_area_pointer = CGF.Builder.CreateGEP(
-      CGF.Int8Ty, __overflow_area_pointer,
-      llvm::ConstantInt::get(CGF.Int32Ty, Offset),
-      "__overflow_area_pointer.next");
+  __overflow_area_pointer =
+      CGF.Builder.CreateGEP(CGF.Int8Ty, __overflow_area_pointer,
+                            llvm::ConstantInt::get(CGF.Int32Ty, Offset),
+                            "__overflow_area_pointer.next");
   CGF.Builder.CreateStore(__overflow_area_pointer, __overflow_area_pointer_p);
 
   return AddrTyped;
@@ -377,10 +377,10 @@ Address HexagonABIInfo::EmitVAArgForHexagonLinux(CodeGenFunction &CGF,
 
   // Get the pointer for next argument in overflow area and store it
   // to overflow area pointer.
-  llvm::Value *__new_overflow_area_pointer = CGF.Builder.CreateGEP(
-      CGF.Int8Ty, __overflow_area_pointer,
-      llvm::ConstantInt::get(CGF.Int32Ty, ArgSize),
-      "__overflow_area_pointer.next");
+  llvm::Value *__new_overflow_area_pointer =
+      CGF.Builder.CreateGEP(CGF.Int8Ty, __overflow_area_pointer,
+                            llvm::ConstantInt::get(CGF.Int32Ty, ArgSize),
+                            "__overflow_area_pointer.next");
 
   CGF.Builder.CreateStore(__new_overflow_area_pointer,
                           __overflow_area_pointer_p);
diff --git a/clang/lib/CodeGen/Targets/Lanai.cpp b/clang/lib/CodeGen/Targets/Lanai.cpp
index 2578fc0291e7..cecd48140477 100644
--- a/clang/lib/CodeGen/Targets/Lanai.cpp
+++ b/clang/lib/CodeGen/Targets/Lanai.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
@@ -146,7 +146,7 @@ public:
   LanaiTargetCodeGenInfo(CodeGen::CodeGenTypes &CGT)
       : TargetCodeGenInfo(std::make_unique<LanaiABIInfo>(CGT)) {}
 };
-}
+} // namespace
 
 std::unique_ptr<TargetCodeGenInfo>
 CodeGen::createLanaiTargetCodeGenInfo(CodeGenModule &CGM) {
diff --git a/clang/lib/CodeGen/Targets/LoongArch.cpp b/clang/lib/CodeGen/Targets/LoongArch.cpp
index 6c90e48a5ea4..f15d9bf24fdf 100644
--- a/clang/lib/CodeGen/Targets/LoongArch.cpp
+++ b/clang/lib/CodeGen/Targets/LoongArch.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
diff --git a/clang/lib/CodeGen/Targets/M68k.cpp b/clang/lib/CodeGen/Targets/M68k.cpp
index 120022105f34..e2ddac9799d8 100644
--- a/clang/lib/CodeGen/Targets/M68k.cpp
+++ b/clang/lib/CodeGen/Targets/M68k.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
diff --git a/clang/lib/CodeGen/Targets/MSP430.cpp b/clang/lib/CodeGen/Targets/MSP430.cpp
index 8ce70e2111cc..11578a39b9a2 100644
--- a/clang/lib/CodeGen/Targets/MSP430.cpp
+++ b/clang/lib/CodeGen/Targets/MSP430.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
@@ -68,7 +68,7 @@ public:
                            CodeGen::CodeGenModule &M) const override;
 };
 
-}
+} // namespace
 
 void MSP430TargetCodeGenInfo::setTargetAttributes(
     const Decl *D, llvm::GlobalValue *GV, CodeGen::CodeGenModule &M) const {
diff --git a/clang/lib/CodeGen/Targets/Mips.cpp b/clang/lib/CodeGen/Targets/Mips.cpp
index 771a85c84b35..03632e83db31 100644
--- a/clang/lib/CodeGen/Targets/Mips.cpp
+++ b/clang/lib/CodeGen/Targets/Mips.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
@@ -23,13 +23,14 @@ class MipsABIInfo : public ABIInfo {
   const unsigned MinABIStackAlignInBytes, StackAlignInBytes;
   void CoerceToIntArgs(uint64_t TySize,
                        SmallVectorImpl<llvm::Type *> &ArgList) const;
-  llvm::Type* HandleAggregates(QualType Ty, uint64_t TySize) const;
-  llvm::Type* returnAggregateInRegs(QualType RetTy, uint64_t Size) const;
-  llvm::Type* getPaddingType(uint64_t Align, uint64_t Offset) const;
+  llvm::Type *HandleAggregates(QualType Ty, uint64_t TySize) const;
+  llvm::Type *returnAggregateInRegs(QualType RetTy, uint64_t Size) const;
+  llvm::Type *getPaddingType(uint64_t Align, uint64_t Offset) const;
+
 public:
-  MipsABIInfo(CodeGenTypes &CGT, bool _IsO32) :
-    ABIInfo(CGT), IsO32(_IsO32), MinABIStackAlignInBytes(IsO32 ? 4 : 8),
-    StackAlignInBytes(IsO32 ? 8 : 16) {}
+  MipsABIInfo(CodeGenTypes &CGT, bool _IsO32)
+      : ABIInfo(CGT), IsO32(_IsO32), MinABIStackAlignInBytes(IsO32 ? 4 : 8),
+        StackAlignInBytes(IsO32 ? 8 : 16) {}
 
   ABIArgInfo classifyReturnType(QualType RetTy) const;
   ABIArgInfo classifyArgumentType(QualType RetTy, uint64_t &Offset) const;
@@ -41,6 +42,7 @@ public:
 
 class MIPSTargetCodeGenInfo : public TargetCodeGenInfo {
   unsigned SizeOfUnwindException;
+
 public:
   MIPSTargetCodeGenInfo(CodeGenTypes &CGT, bool IsO32)
       : TargetCodeGenInfo(std::make_unique<MipsABIInfo>(CGT, IsO32)),
@@ -53,7 +55,8 @@ public:
   void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,
                            CodeGen::CodeGenModule &CGM) const override {
     const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D);
-    if (!FD) return;
+    if (!FD)
+      return;
     llvm::Function *Fn = cast<llvm::Function>(GV);
 
     if (FD->hasAttr<MipsLongCallAttr>())
@@ -67,8 +70,7 @@ public:
 
     if (FD->hasAttr<Mips16Attr>()) {
       Fn->addFnAttr("mips16");
-    }
-    else if (FD->hasAttr<NoMips16Attr>()) {
+    } else if (FD->hasAttr<NoMips16Attr>()) {
       Fn->addFnAttr("nomips16");
     }
 
@@ -83,19 +85,36 @@ public:
 
     const char *Kind;
     switch (Attr->getInterrupt()) {
-    case MipsInterruptAttr::eic:     Kind = "eic"; break;
-    case MipsInterruptAttr::sw0:     Kind = "sw0"; break;
-    case MipsInterruptAttr::sw1:     Kind = "sw1"; break;
-    case MipsInterruptAttr::hw0:     Kind = "hw0"; break;
-    case MipsInterruptAttr::hw1:     Kind = "hw1"; break;
-    case MipsInterruptAttr::hw2:     Kind = "hw2"; break;
-    case MipsInterruptAttr::hw3:     Kind = "hw3"; break;
-    case MipsInterruptAttr::hw4:     Kind = "hw4"; break;
-    case MipsInterruptAttr::hw5:     Kind = "hw5"; break;
+    case MipsInterruptAttr::eic:
+      Kind = "eic";
+      break;
+    case MipsInterruptAttr::sw0:
+      Kind = "sw0";
+      break;
+    case MipsInterruptAttr::sw1:
+      Kind = "sw1";
+      break;
+    case MipsInterruptAttr::hw0:
+      Kind = "hw0";
+      break;
+    case MipsInterruptAttr::hw1:
+      Kind = "hw1";
+      break;
+    case MipsInterruptAttr::hw2:
+      Kind = "hw2";
+      break;
+    case MipsInterruptAttr::hw3:
+      Kind = "hw3";
+      break;
+    case MipsInterruptAttr::hw4:
+      Kind = "hw4";
+      break;
+    case MipsInterruptAttr::hw5:
+      Kind = "hw5";
+      break;
     }
 
     Fn->addFnAttr("interrupt", Kind);
-
   }
 
   bool initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,
@@ -122,12 +141,12 @@ public:
     Opt = "/FAILIFMISMATCH:\"" + Name.str() + "=" + Value.str() + "\"";
   }
 };
-}
+} // namespace
 
 void MipsABIInfo::CoerceToIntArgs(
     uint64_t TySize, SmallVectorImpl<llvm::Type *> &ArgList) const {
   llvm::IntegerType *IntTy =
-    llvm::IntegerType::get(getVMContext(), MinABIStackAlignInBytes * 8);
+      llvm::IntegerType::get(getVMContext(), MinABIStackAlignInBytes * 8);
 
   // Add (TySize / MinABIStackAlignInBytes) args of IntTy.
   for (unsigned N = TySize / (MinABIStackAlignInBytes * 8); N; --N)
@@ -142,8 +161,8 @@ void MipsABIInfo::CoerceToIntArgs(
 
 // In N32/64, an aligned double precision floating point field is passed in
 // a register.
-llvm::Type* MipsABIInfo::HandleAggregates(QualType Ty, uint64_t TySize) const {
-  SmallVector<llvm::Type*, 8> ArgList, IntArgList;
+llvm::Type *MipsABIInfo::HandleAggregates(QualType Ty, uint64_t TySize) const {
+  SmallVector<llvm::Type *, 8> ArgList, IntArgList;
 
   if (IsO32) {
     CoerceToIntArgs(TySize, ArgList);
@@ -206,8 +225,8 @@ llvm::Type *MipsABIInfo::getPaddingType(uint64_t OrigOffset,
   return llvm::IntegerType::get(getVMContext(), (Offset - OrigOffset) * 8);
 }
 
-ABIArgInfo
-MipsABIInfo::classifyArgumentType(QualType Ty, uint64_t &Offset) const {
+ABIArgInfo MipsABIInfo::classifyArgumentType(QualType Ty,
+                                             uint64_t &Offset) const {
   Ty = useFirstFieldIfTransparentUnion(Ty);
 
   uint64_t OrigOffset = Offset;
@@ -258,10 +277,10 @@ MipsABIInfo::classifyArgumentType(QualType Ty, uint64_t &Offset) const {
       nullptr, 0, IsO32 ? nullptr : getPaddingType(OrigOffset, CurrOffset));
 }
 
-llvm::Type*
-MipsABIInfo::returnAggregateInRegs(QualType RetTy, uint64_t Size) const {
+llvm::Type *MipsABIInfo::returnAggregateInRegs(QualType RetTy,
+                                               uint64_t Size) const {
   const RecordType *RT = RetTy->getAs<RecordType>();
-  SmallVector<llvm::Type*, 8> RTList;
+  SmallVector<llvm::Type *, 8> RTList;
 
   if (RT && RT->isStructureOrClassType()) {
     const RecordDecl *RD = RT->getDecl();
@@ -345,7 +364,8 @@ ABIArgInfo MipsABIInfo::classifyReturnType(QualType RetTy) const {
     return ABIArgInfo::getExtend(RetTy);
 
   if ((RetTy->isUnsignedIntegerOrEnumerationType() ||
-      RetTy->isSignedIntegerOrEnumerationType()) && Size == 32 && !IsO32)
+       RetTy->isSignedIntegerOrEnumerationType()) &&
+      Size == 32 && !IsO32)
     return ABIArgInfo::getSignExtend(RetTy);
 
   return ABIArgInfo::getDirect();
@@ -372,8 +392,7 @@ RValue MipsABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
   unsigned SlotSizeInBits = IsO32 ? 32 : 64;
   unsigned PtrWidth = getTarget().getPointerWidth(LangAS::Default);
   bool DidPromote = false;
-  if ((Ty->isIntegerType() &&
-          getContext().getIntWidth(Ty) < SlotSizeInBits) ||
+  if ((Ty->isIntegerType() && getContext().getIntWidth(Ty) < SlotSizeInBits) ||
       (Ty->isPointerType() && PtrWidth < SlotSizeInBits)) {
     DidPromote = true;
     Ty = getContext().getIntTypeForBitwidth(SlotSizeInBits,
@@ -385,7 +404,7 @@ RValue MipsABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
   // The alignment of things in the argument area is never larger than
   // StackAlignInBytes.
   TyInfo.Align =
-    std::min(TyInfo.Align, CharUnits::fromQuantity(StackAlignInBytes));
+      std::min(TyInfo.Align, CharUnits::fromQuantity(StackAlignInBytes));
 
   // MinABIStackAlignInBytes is the size of argument slots on the stack.
   CharUnits ArgSlotSize = CharUnits::fromQuantity(MinABIStackAlignInBytes);
@@ -421,9 +440,8 @@ ABIArgInfo MipsABIInfo::extendType(QualType Ty) const {
   return ABIArgInfo::getExtend(Ty);
 }
 
-bool
-MIPSTargetCodeGenInfo::initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,
-                                               llvm::Value *Address) const {
+bool MIPSTargetCodeGenInfo::initDwarfEHRegSizeTable(
+    CodeGen::CodeGenFunction &CGF, llvm::Value *Address) const {
   // This information comes from gcc's implementation, which seems to
   // as canonical as it gets.
 
diff --git a/clang/lib/CodeGen/Targets/NVPTX.cpp b/clang/lib/CodeGen/Targets/NVPTX.cpp
index b82e4ddb9f3f..99edcc3bf205 100644
--- a/clang/lib/CodeGen/Targets/NVPTX.cpp
+++ b/clang/lib/CodeGen/Targets/NVPTX.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/IR/CallingConv.h"
 #include "llvm/IR/IntrinsicsNVPTX.h"
diff --git a/clang/lib/CodeGen/Targets/PNaCl.cpp b/clang/lib/CodeGen/Targets/PNaCl.cpp
index 9b7d757df3a3..5fe099417460 100644
--- a/clang/lib/CodeGen/Targets/PNaCl.cpp
+++ b/clang/lib/CodeGen/Targets/PNaCl.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
@@ -20,7 +20,7 @@ using namespace clang::CodeGen;
 //===----------------------------------------------------------------------===//
 
 class PNaClABIInfo : public ABIInfo {
- public:
+public:
   PNaClABIInfo(CodeGen::CodeGenTypes &CGT) : ABIInfo(CGT) {}
 
   ABIArgInfo classifyReturnType(QualType RetTy) const;
@@ -32,9 +32,9 @@ class PNaClABIInfo : public ABIInfo {
 };
 
 class PNaClTargetCodeGenInfo : public TargetCodeGenInfo {
- public:
-   PNaClTargetCodeGenInfo(CodeGen::CodeGenTypes &CGT)
-       : TargetCodeGenInfo(std::make_unique<PNaClABIInfo>(CGT)) {}
+public:
+  PNaClTargetCodeGenInfo(CodeGen::CodeGenTypes &CGT)
+      : TargetCodeGenInfo(std::make_unique<PNaClABIInfo>(CGT)) {}
 };
 
 void PNaClABIInfo::computeInfo(CGFunctionInfo &FI) const {
diff --git a/clang/lib/CodeGen/Targets/PPC.cpp b/clang/lib/CodeGen/Targets/PPC.cpp
index 989e46f4b66a..4ce0ad2e41b5 100644
--- a/clang/lib/CodeGen/Targets/PPC.cpp
+++ b/clang/lib/CodeGen/Targets/PPC.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 #include "clang/Basic/DiagnosticFrontend.h"
 
 using namespace clang;
@@ -368,7 +368,7 @@ public:
   bool initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,
                                llvm::Value *Address) const override;
 };
-}
+} // namespace
 
 CharUnits PPC32_SVR4_ABIInfo::getParamTypeAlignment(QualType Ty) const {
   // Complex types are passed just like their elements.
@@ -474,7 +474,7 @@ RValue PPC32_SVR4_ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAList,
   // "Align" the register count when TY is i64.
   if (isI64 || (isF64 && IsSoftFloatABI)) {
     NumRegs = Builder.CreateAdd(NumRegs, Builder.getInt8(1));
-    NumRegs = Builder.CreateAnd(NumRegs, Builder.getInt8((uint8_t) ~1U));
+    NumRegs = Builder.CreateAnd(NumRegs, Builder.getInt8((uint8_t)~1U));
   }
 
   llvm::Value *CC =
@@ -508,7 +508,8 @@ RValue PPC32_SVR4_ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAList,
 
     // Get the address of the saved value by scaling the number of
     // registers we've used by the number of
-    CharUnits RegSize = CharUnits::fromQuantity((isInt || IsSoftFloatABI) ? 4 : 8);
+    CharUnits RegSize =
+        CharUnits::fromQuantity((isInt || IsSoftFloatABI) ? 4 : 8);
     llvm::Value *RegOffset =
         Builder.CreateMul(NumRegs, Builder.getInt8(RegSize.getQuantity()));
     RegAddr = Address(Builder.CreateInBoundsGEP(
@@ -517,9 +518,8 @@ RValue PPC32_SVR4_ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAList,
                       RegAddr.getAlignment().alignmentOfArrayElement(RegSize));
 
     // Increase the used-register count.
-    NumRegs =
-      Builder.CreateAdd(NumRegs,
-                        Builder.getInt8((isI64 || (isF64 && IsSoftFloatABI)) ? 2 : 1));
+    NumRegs = Builder.CreateAdd(
+        NumRegs, Builder.getInt8((isI64 || (isF64 && IsSoftFloatABI)) ? 2 : 1));
     Builder.CreateStore(NumRegs, NumRegsAddr);
 
     CGF.EmitBranch(Cont);
@@ -597,9 +597,8 @@ bool PPC32TargetCodeGenInfo::isStructReturnInRegABI(
   return false;
 }
 
-bool
-PPC32TargetCodeGenInfo::initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,
-                                                llvm::Value *Address) const {
+bool PPC32TargetCodeGenInfo::initDwarfEHRegSizeTable(
+    CodeGen::CodeGenFunction &CGF, llvm::Value *Address) const {
   return PPC_initDwarfEHRegSizeTable(CGF, Address, /*Is64Bit*/ false,
                                      /*IsAIX*/ false);
 }
@@ -696,12 +695,11 @@ public:
   bool initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,
                                llvm::Value *Address) const override;
 };
-}
+} // namespace
 
 // Return true if the ABI requires Ty to be passed sign- or zero-
 // extended to 64 bits.
-bool
-PPC64_SVR4_ABIInfo::isPromotableTypeForABI(QualType Ty) const {
+bool PPC64_SVR4_ABIInfo::isPromotableTypeForABI(QualType Ty) const {
   // Treat an enum type as its underlying type.
   if (const EnumType *EnumTy = Ty->getAs<EnumType>())
     Ty = EnumTy->getDecl()->getIntegerType();
@@ -735,7 +733,7 @@ CharUnits PPC64_SVR4_ABIInfo::getParamTypeAlignment(QualType Ty) const {
   if (const ComplexType *CTy = Ty->getAs<ComplexType>())
     Ty = CTy->getElementType();
 
-  auto FloatUsesVector = [this](QualType Ty){
+  auto FloatUsesVector = [this](QualType Ty) {
     return Ty->isRealFloatingType() && &getContext().getFloatTypeSemantics(
                                            Ty) == &llvm::APFloat::IEEEquad();
   };
@@ -743,7 +741,8 @@ CharUnits PPC64_SVR4_ABIInfo::getParamTypeAlignment(QualType Ty) const {
   // Only vector types of size 16 bytes need alignment (larger types are
   // passed via reference, smaller types are not aligned).
   if (Ty->isVectorType()) {
-    return CharUnits::fromQuantity(getContext().getTypeSize(Ty) == 128 ? 16 : 8);
+    return CharUnits::fromQuantity(getContext().getTypeSize(Ty) == 128 ? 16
+                                                                       : 8);
   } else if (FloatUsesVector(Ty)) {
     // According to ABI document section 'Optional Save Areas': If extended
     // precision floating-point values in IEEE BINARY 128 QUADRUPLE PRECISION
@@ -811,18 +810,17 @@ bool PPC64_SVR4_ABIInfo::isHomogeneousAggregateSmallEnough(
     const Type *Base, uint64_t Members) const {
   // Vector and fp128 types require one register, other floating point types
   // require one or two registers depending on their size.
-  uint32_t NumRegs =
-      ((getContext().getTargetInfo().hasFloat128Type() &&
-          Base->isFloat128Type()) ||
-        Base->isVectorType()) ? 1
-                              : (getContext().getTypeSize(Base) + 63) / 64;
+  uint32_t NumRegs = ((getContext().getTargetInfo().hasFloat128Type() &&
+                       Base->isFloat128Type()) ||
+                      Base->isVectorType())
+                         ? 1
+                         : (getContext().getTypeSize(Base) + 63) / 64;
 
   // Homogeneous Aggregates may occupy at most 8 registers.
   return Members * NumRegs <= 8;
 }
 
-ABIArgInfo
-PPC64_SVR4_ABIInfo::classifyArgumentType(QualType Ty) const {
+ABIArgInfo PPC64_SVR4_ABIInfo::classifyArgumentType(QualType Ty) const {
   Ty = useFirstFieldIfTransparentUnion(Ty);
 
   if (Ty->isAnyComplexType())
@@ -897,8 +895,7 @@ PPC64_SVR4_ABIInfo::classifyArgumentType(QualType Ty) const {
               : ABIArgInfo::getDirect());
 }
 
-ABIArgInfo
-PPC64_SVR4_ABIInfo::classifyReturnType(QualType RetTy) const {
+ABIArgInfo PPC64_SVR4_ABIInfo::classifyReturnType(QualType RetTy) const {
   if (RetTy->isVoidType())
     return ABIArgInfo::getIgnore();
 
@@ -994,10 +991,8 @@ RValue PPC64_SVR4_ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
                           /*ForceRightAdjust*/ true);
 }
 
-bool
-PPC64_SVR4_TargetCodeGenInfo::initDwarfEHRegSizeTable(
-  CodeGen::CodeGenFunction &CGF,
-  llvm::Value *Address) const {
+bool PPC64_SVR4_TargetCodeGenInfo::initDwarfEHRegSizeTable(
+    CodeGen::CodeGenFunction &CGF, llvm::Value *Address) const {
   return PPC_initDwarfEHRegSizeTable(CGF, Address, /*Is64Bit*/ true,
                                      /*IsAIX*/ false);
 }
@@ -1020,9 +1015,8 @@ void PPC64_SVR4_TargetCodeGenInfo::emitTargetMetadata(
   }
 }
 
-bool
-PPC64TargetCodeGenInfo::initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,
-                                                llvm::Value *Address) const {
+bool PPC64TargetCodeGenInfo::initDwarfEHRegSizeTable(
+    CodeGen::CodeGenFunction &CGF, llvm::Value *Address) const {
   return PPC_initDwarfEHRegSizeTable(CGF, Address, /*Is64Bit*/ true,
                                      /*IsAIX*/ false);
 }
diff --git a/clang/lib/CodeGen/Targets/RISCV.cpp b/clang/lib/CodeGen/Targets/RISCV.cpp
index 2c48ba37fd20..5e9a90a9d55d 100644
--- a/clang/lib/CodeGen/Targets/RISCV.cpp
+++ b/clang/lib/CodeGen/Targets/RISCV.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
@@ -332,7 +332,8 @@ ABIArgInfo RISCVABIInfo::coerceAndExpandFPCCEligibleStruct(
 
   CharUnits Field2Align =
       CharUnits::fromQuantity(getDataLayout().getABITypeAlign(Field2Ty));
-  CharUnits Field1End = Field1Off +
+  CharUnits Field1End =
+      Field1Off +
       CharUnits::fromQuantity(getDataLayout().getTypeStoreSize(Field1Ty));
   CharUnits Field2OffNoPadNoPack = Field1End.alignTo(Field2Align);
 
@@ -422,8 +423,8 @@ ABIArgInfo RISCVABIInfo::classifyArgumentType(QualType Ty, bool IsFixed,
     return ABIArgInfo::getIgnore();
 
   // Pass floating point values via FPRs if possible.
-  if (IsFixed && Ty->isFloatingType() && !Ty->isComplexType() &&
-      FLen >= Size && ArgFPRsLeft) {
+  if (IsFixed && Ty->isFloatingType() && !Ty->isComplexType() && FLen >= Size &&
+      ArgFPRsLeft) {
     ArgFPRsLeft--;
     return ABIArgInfo::getDirect();
   }
@@ -586,7 +587,8 @@ public:
   void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,
                            CodeGen::CodeGenModule &CGM) const override {
     const auto *FD = dyn_cast_or_null<FunctionDecl>(D);
-    if (!FD) return;
+    if (!FD)
+      return;
 
     auto *Fn = cast<llvm::Function>(GV);
 
@@ -599,8 +601,12 @@ public:
 
     const char *Kind;
     switch (Attr->getInterrupt()) {
-    case RISCVInterruptAttr::supervisor: Kind = "supervisor"; break;
-    case RISCVInterruptAttr::machine: Kind = "machine"; break;
+    case RISCVInterruptAttr::supervisor:
+      Kind = "supervisor";
+      break;
+    case RISCVInterruptAttr::machine:
+      Kind = "machine";
+      break;
     }
 
     Fn->addFnAttr("interrupt", Kind);
diff --git a/clang/lib/CodeGen/Targets/SPIR.cpp b/clang/lib/CodeGen/Targets/SPIR.cpp
index 5c75e985e953..b5edeef07bed 100644
--- a/clang/lib/CodeGen/Targets/SPIR.cpp
+++ b/clang/lib/CodeGen/Targets/SPIR.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
@@ -208,8 +208,8 @@ void computeSPIRKernelABIInfo(CodeGenModule &CGM, CGFunctionInfo &FI) {
   else
     CommonSPIRABIInfo(CGM.getTypes()).computeInfo(FI);
 }
-}
-}
+} // namespace CodeGen
+} // namespace clang
 
 unsigned CommonSPIRTargetCodeGenInfo::getOpenCLKernelCallingConv() const {
   return llvm::CallingConv::SPIR_KERNEL;
@@ -339,8 +339,8 @@ llvm::Type *CommonSPIRTargetCodeGenInfo::getOpenCLType(CodeGenModule &CGM,
     enum AccessQualifier : unsigned { AQ_ro = 0, AQ_wo = 1, AQ_rw = 2 };
     switch (BuiltinTy->getKind()) {
 #define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix)                   \
-    case BuiltinType::Id:                                                      \
-      return getSPIRVImageType(Ctx, "spirv.Image", #ImgType, AQ_##Suffix);
+  case BuiltinType::Id:                                                        \
+    return getSPIRVImageType(Ctx, "spirv.Image", #ImgType, AQ_##Suffix);
 #include "clang/Basic/OpenCLImageTypes.def"
     case BuiltinType::OCLSampler:
       return llvm::TargetExtType::get(Ctx, "spirv.Sampler");
@@ -353,8 +353,8 @@ llvm::Type *CommonSPIRTargetCodeGenInfo::getOpenCLType(CodeGenModule &CGM,
     case BuiltinType::OCLReserveID:
       return llvm::TargetExtType::get(Ctx, "spirv.ReserveId");
 #define INTEL_SUBGROUP_AVC_TYPE(Name, Id)                                      \
-    case BuiltinType::OCLIntelSubgroupAVC##Id:                                 \
-      return llvm::TargetExtType::get(Ctx, "spirv.Avc" #Id "INTEL");
+  case BuiltinType::OCLIntelSubgroupAVC##Id:                                   \
+    return llvm::TargetExtType::get(Ctx, "spirv.Avc" #Id "INTEL");
 #include "clang/Basic/OpenCLExtensionTypes.def"
     default:
       return nullptr;
diff --git a/clang/lib/CodeGen/Targets/Sparc.cpp b/clang/lib/CodeGen/Targets/Sparc.cpp
index da8c7219be26..5b663eb831d2 100644
--- a/clang/lib/CodeGen/Targets/Sparc.cpp
+++ b/clang/lib/CodeGen/Targets/Sparc.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
@@ -29,13 +29,10 @@ private:
 };
 } // end anonymous namespace
 
-
-ABIArgInfo
-SparcV8ABIInfo::classifyReturnType(QualType Ty) const {
+ABIArgInfo SparcV8ABIInfo::classifyReturnType(QualType Ty) const {
   if (Ty->isAnyComplexType()) {
     return ABIArgInfo::getDirect();
-  }
-  else {
+  } else {
     return DefaultABIInfo::classifyReturnType(Ty);
   }
 }
@@ -128,12 +125,12 @@ private:
   struct CoerceBuilder {
     llvm::LLVMContext &Context;
     const llvm::DataLayout &DL;
-    SmallVector<llvm::Type*, 8> Elems;
+    SmallVector<llvm::Type *, 8> Elems;
     uint64_t Size;
     bool InReg;
 
     CoerceBuilder(llvm::LLVMContext &c, const llvm::DataLayout &dl)
-      : Context(c), DL(dl), Size(0), InReg(false) {}
+        : Context(c), DL(dl), Size(0), InReg(false) {}
 
     // Pad Elems with integers until Size is ToSize.
     void pad(uint64_t ToSize) {
@@ -222,8 +219,7 @@ private:
 };
 } // end anonymous namespace
 
-ABIArgInfo
-SparcV9ABIInfo::classifyType(QualType Ty, unsigned SizeLimit) const {
+ABIArgInfo SparcV9ABIInfo::classifyType(QualType Ty, unsigned SizeLimit) const {
   if (Ty->isVoidType())
     return ABIArgInfo::getIgnore();
 
@@ -369,9 +365,8 @@ public:
 };
 } // end anonymous namespace
 
-bool
-SparcV9TargetCodeGenInfo::initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,
-                                                llvm::Value *Address) const {
+bool SparcV9TargetCodeGenInfo::initDwarfEHRegSizeTable(
+    CodeGen::CodeGenFunction &CGF, llvm::Value *Address) const {
   // This is calculated from the LLVM and GCC tables and verified
   // against gcc output.  AFAIK all ABIs use the same encoding.
 
diff --git a/clang/lib/CodeGen/Targets/SystemZ.cpp b/clang/lib/CodeGen/Targets/SystemZ.cpp
index 23c96fa5cf98..26bdd2bfa8e6 100644
--- a/clang/lib/CodeGen/Targets/SystemZ.cpp
+++ b/clang/lib/CodeGen/Targets/SystemZ.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 #include "clang/Basic/Builtins.h"
 #include "llvm/IR/IntrinsicsS390.h"
 
@@ -60,7 +60,7 @@ public:
   SystemZTargetCodeGenInfo(CodeGenTypes &CGT, bool HasVector, bool SoftFloatABI)
       : TargetCodeGenInfo(
             std::make_unique<SystemZABIInfo>(CGT, HasVector, SoftFloatABI)),
-            Ctx(CGT.getContext()) {
+        Ctx(CGT.getContext()) {
     SwiftInfo =
         std::make_unique<SwiftABIInfo>(CGT, /*SwiftErrorInRegister=*/false);
   }
@@ -89,12 +89,11 @@ public:
     if (const auto *VD = dyn_cast<VarDecl>(D)) {
       if (VD->isExternallyVisible())
         handleExternallyVisibleObjABI(VD->getType().getTypePtr(), M,
-                                      /*IsParam*/false);
-    }
-    else if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {
+                                      /*IsParam*/ false);
+    } else if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {
       if (FD->isExternallyVisible())
         handleExternallyVisibleObjABI(FD->getType().getTypePtr(), M,
-                                      /*IsParam*/false);
+                                      /*IsParam*/ false);
     }
   }
 
@@ -140,7 +139,7 @@ public:
     return nullptr;
   }
 };
-}
+} // namespace
 
 bool SystemZABIInfo::isPromotableIntegerTypeForABI(QualType Ty) const {
   // Treat an enum type as its underlying type.
@@ -168,14 +167,12 @@ bool SystemZABIInfo::isPromotableIntegerTypeForABI(QualType Ty) const {
 }
 
 bool SystemZABIInfo::isCompoundType(QualType Ty) const {
-  return (Ty->isAnyComplexType() ||
-          Ty->isVectorType() ||
+  return (Ty->isAnyComplexType() || Ty->isVectorType() ||
           isAggregateTypeForABI(Ty));
 }
 
 bool SystemZABIInfo::isVectorArgumentType(QualType Ty) const {
-  return (HasVector &&
-          Ty->isVectorType() &&
+  return (HasVector && Ty->isVectorType() &&
           getContext().getTypeSize(Ty) <= 128);
 }
 
@@ -270,7 +267,7 @@ RValue SystemZABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
   CharUnits UnpaddedSize;
   CharUnits DirectAlign;
   SZCGI.handleExternallyVisibleObjABI(Ty.getTypePtr(), CGT.getCGM(),
-                                      /*IsParam*/true);
+                                      /*IsParam*/ true);
   if (IsIndirect) {
     DirectTy = llvm::PointerType::getUnqual(DirectTy);
     UnpaddedSize = DirectAlign = CharUnits::fromQuantity(8);
@@ -291,7 +288,7 @@ RValue SystemZABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
 
   llvm::Type *IndexTy = CGF.Int64Ty;
   llvm::Value *PaddedSizeV =
-    llvm::ConstantInt::get(IndexTy, PaddedSize.getQuantity());
+      llvm::ConstantInt::get(IndexTy, PaddedSize.getQuantity());
 
   if (IsVector) {
     // Work out the address of a vector argument on the stack.
@@ -318,14 +315,14 @@ RValue SystemZABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
   unsigned MaxRegs, RegCountField, RegSaveIndex;
   CharUnits RegPadding;
   if (InFPRs) {
-    MaxRegs = 4; // Maximum of 4 FPR arguments
-    RegCountField = 1; // __fpr
-    RegSaveIndex = 16; // save offset for f0
+    MaxRegs = 4;              // Maximum of 4 FPR arguments
+    RegCountField = 1;        // __fpr
+    RegSaveIndex = 16;        // save offset for f0
     RegPadding = CharUnits(); // floats are passed in the high bits of an FPR
   } else {
-    MaxRegs = 5; // Maximum of 5 GPR arguments
-    RegCountField = 0; // __gpr
-    RegSaveIndex = 2; // save offset for r2
+    MaxRegs = 5;          // Maximum of 5 GPR arguments
+    RegCountField = 0;    // __gpr
+    RegSaveIndex = 2;     // save offset for r2
     RegPadding = Padding; // values are passed in the low bits of a GPR
   }
 
@@ -333,8 +330,8 @@ RValue SystemZABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
       CGF.Builder.CreateStructGEP(VAListAddr, RegCountField, "reg_count_ptr");
   llvm::Value *RegCount = CGF.Builder.CreateLoad(RegCountPtr, "reg_count");
   llvm::Value *MaxRegsV = llvm::ConstantInt::get(IndexTy, MaxRegs);
-  llvm::Value *InRegs = CGF.Builder.CreateICmpULT(RegCount, MaxRegsV,
-                                                 "fits_in_regs");
+  llvm::Value *InRegs =
+      CGF.Builder.CreateICmpULT(RegCount, MaxRegsV, "fits_in_regs");
 
   llvm::BasicBlock *InRegBlock = CGF.createBasicBlock("vaarg.in_reg");
   llvm::BasicBlock *InMemBlock = CGF.createBasicBlock("vaarg.in_mem");
@@ -346,12 +343,12 @@ RValue SystemZABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
 
   // Work out the address of an argument register.
   llvm::Value *ScaledRegCount =
-    CGF.Builder.CreateMul(RegCount, PaddedSizeV, "scaled_reg_count");
+      CGF.Builder.CreateMul(RegCount, PaddedSizeV, "scaled_reg_count");
   llvm::Value *RegBase =
-    llvm::ConstantInt::get(IndexTy, RegSaveIndex * PaddedSize.getQuantity()
-                                      + RegPadding.getQuantity());
+      llvm::ConstantInt::get(IndexTy, RegSaveIndex * PaddedSize.getQuantity() +
+                                          RegPadding.getQuantity());
   llvm::Value *RegOffset =
-    CGF.Builder.CreateAdd(ScaledRegCount, RegBase, "reg_offset");
+      CGF.Builder.CreateAdd(ScaledRegCount, RegBase, "reg_offset");
   Address RegSaveAreaPtr =
       CGF.Builder.CreateStructGEP(VAListAddr, 3, "reg_save_area_ptr");
   llvm::Value *RegSaveArea =
@@ -363,8 +360,7 @@ RValue SystemZABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
 
   // Update the register count
   llvm::Value *One = llvm::ConstantInt::get(IndexTy, 1);
-  llvm::Value *NewRegCount =
-    CGF.Builder.CreateAdd(RegCount, One, "reg_count");
+  llvm::Value *NewRegCount = CGF.Builder.CreateAdd(RegCount, One, "reg_count");
   CGF.Builder.CreateStore(NewRegCount, RegCountPtr);
   CGF.EmitBranch(ContBlock);
 
@@ -478,7 +474,7 @@ void SystemZABIInfo::computeInfo(CGFunctionInfo &FI) const {
       // vector ABI becomes visible as the va_list could be passed on to
       // other functions.
       SZCGI.handleExternallyVisibleObjABI(I.type.getTypePtr(), CGT.getCGM(),
-                                          /*IsParam*/true);
+                                          /*IsParam*/ true);
   }
 }
 
@@ -495,8 +491,9 @@ bool SystemZTargetCodeGenInfo::isVectorTypeBased(const Type *Ty,
     const Type *SingleEltTy = getABIInfo<SystemZABIInfo>()
                                   .GetSingleElementType(QualType(Ty, 0))
                                   .getTypePtr();
-    bool SingleVecEltStruct = SingleEltTy != Ty && SingleEltTy->isVectorType() &&
-      Ctx.getTypeSize(SingleEltTy) == Ctx.getTypeSize(Ty);
+    bool SingleVecEltStruct =
+        SingleEltTy != Ty && SingleEltTy->isVectorType() &&
+        Ctx.getTypeSize(SingleEltTy) == Ctx.getTypeSize(Ty);
     if (Ty->isVectorType() || SingleVecEltStruct)
       return Ctx.getTypeSize(Ty) / 8 <= 16;
   }
@@ -507,26 +504,26 @@ bool SystemZTargetCodeGenInfo::isVectorTypeBased(const Type *Ty,
 
   // Vectors >= 16 bytes expose the ABI through alignment requirements.
   if (Ty->isVectorType() && Ctx.getTypeSize(Ty) / 8 >= 16)
-      return true;
+    return true;
 
   if (const auto *RecordTy = Ty->getAs<RecordType>()) {
     const RecordDecl *RD = RecordTy->getDecl();
     if (const CXXRecordDecl *CXXRD = dyn_cast<CXXRecordDecl>(RD))
       if (CXXRD->hasDefinition())
         for (const auto &I : CXXRD->bases())
-          if (isVectorTypeBased(I.getType().getTypePtr(), /*IsParam*/false))
+          if (isVectorTypeBased(I.getType().getTypePtr(), /*IsParam*/ false))
             return true;
     for (const auto *FD : RD->fields())
-      if (isVectorTypeBased(FD->getType().getTypePtr(), /*IsParam*/false))
+      if (isVectorTypeBased(FD->getType().getTypePtr(), /*IsParam*/ false))
         return true;
   }
 
   if (const auto *FT = Ty->getAs<FunctionType>())
-    if (isVectorTypeBased(FT->getReturnType().getTypePtr(), /*IsParam*/true))
+    if (isVectorTypeBased(FT->getReturnType().getTypePtr(), /*IsParam*/ true))
       return true;
   if (const FunctionProtoType *Proto = Ty->getAs<FunctionProtoType>())
     for (const auto &ParamType : Proto->getParamTypes())
-      if (isVectorTypeBased(ParamType.getTypePtr(), /*IsParam*/true))
+      if (isVectorTypeBased(ParamType.getTypePtr(), /*IsParam*/ true))
         return true;
 
   return false;
diff --git a/clang/lib/CodeGen/Targets/TCE.cpp b/clang/lib/CodeGen/Targets/TCE.cpp
index d7178b4b8a94..a994a8fda2a8 100644
--- a/clang/lib/CodeGen/Targets/TCE.cpp
+++ b/clang/lib/CodeGen/Targets/TCE.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
@@ -34,7 +34,8 @@ void TCETargetCodeGenInfo::setTargetAttributes(
   if (GV->isDeclaration())
     return;
   const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D);
-  if (!FD) return;
+  if (!FD)
+    return;
 
   llvm::Function *F = cast<llvm::Function>(GV);
 
@@ -74,7 +75,7 @@ void TCETargetCodeGenInfo::setTargetAttributes(
   }
 }
 
-}
+} // namespace
 
 std::unique_ptr<TargetCodeGenInfo>
 CodeGen::createTCETargetCodeGenInfo(CodeGenModule &CGM) {
diff --git a/clang/lib/CodeGen/Targets/VE.cpp b/clang/lib/CodeGen/Targets/VE.cpp
index a7acc249cc2b..558fee3ee942 100644
--- a/clang/lib/CodeGen/Targets/VE.cpp
+++ b/clang/lib/CodeGen/Targets/VE.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
diff --git a/clang/lib/CodeGen/Targets/WebAssembly.cpp b/clang/lib/CodeGen/Targets/WebAssembly.cpp
index 70a968fe93ca..71d13dde724e 100644
--- a/clang/lib/CodeGen/Targets/WebAssembly.cpp
+++ b/clang/lib/CodeGen/Targets/WebAssembly.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
diff --git a/clang/lib/CodeGen/Targets/X86.cpp b/clang/lib/CodeGen/Targets/X86.cpp
index 5ee5179dd0f3..0ba5b344912a 100644
--- a/clang/lib/CodeGen/Targets/X86.cpp
+++ b/clang/lib/CodeGen/Targets/X86.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 #include "clang/Basic/DiagnosticFrontend.h"
 #include "llvm/ADT/SmallBitVector.h"
 
@@ -20,8 +20,8 @@ namespace {
 bool IsX86_MMXType(llvm::Type *IRType) {
   // Return true if the type is an MMX type <2 x i32>, <4 x i16>, or <8 x i8>.
   return IRType->isVectorTy() && IRType->getPrimitiveSizeInBits() == 64 &&
-    cast<llvm::VectorType>(IRType)->getElementType()->isIntegerTy() &&
-    IRType->getScalarSizeInBits() != 64;
+         cast<llvm::VectorType>(IRType)->getElementType()->isIntegerTy() &&
+         IRType->getScalarSizeInBits() != 64;
 }
 
 static llvm::Type *X86AdjustInlineAsmType(CodeGen::CodeGenFunction &CGF,
@@ -65,7 +65,7 @@ static bool isX86VectorCallAggregateSmallEnough(uint64_t NumMembers) {
 }
 
 /// Returns a Homogeneous Vector Aggregate ABIArgInfo, used in X86.
-static ABIArgInfo getDirectX86Hva(llvm::Type* T = nullptr) {
+static ABIArgInfo getDirectX86Hva(llvm::Type *T = nullptr) {
   auto AI = ABIArgInfo::getDirect(T);
   AI.setInReg(true);
   AI.setCanBeFlattened(false);
@@ -80,7 +80,7 @@ static ABIArgInfo getDirectX86Hva(llvm::Type* T = nullptr) {
 struct CCState {
   CCState(CGFunctionInfo &FI)
       : IsPreassigned(FI.arg_size()), CC(FI.getCallingConvention()),
-	Required(FI.getRequiredArgs()), IsDelegateCall(FI.isDelegateCall()) {}
+        Required(FI.getRequiredArgs()), IsDelegateCall(FI.isDelegateCall()) {}
 
   llvm::SmallBitVector IsPreassigned;
   unsigned CC = CallingConv::CC_C;
@@ -92,10 +92,7 @@ struct CCState {
 
 /// X86_32ABIInfo - The X86-32 ABI information.
 class X86_32ABIInfo : public ABIInfo {
-  enum Class {
-    Integer,
-    Float
-  };
+  enum Class { Integer, Float };
 
   static const unsigned MinABIStackAlignInBytes = 4;
 
@@ -158,7 +155,6 @@ class X86_32ABIInfo : public ABIInfo {
   void runVectorCallFirstPass(CGFunctionInfo &FI, CCState &State) const;
 
 public:
-
   void computeInfo(CGFunctionInfo &FI) const override;
   RValue EmitVAArg(CodeGenFunction &CGF, Address VAListAddr, QualType Ty,
                    AggValueSlot Slot) const override;
@@ -201,24 +197,25 @@ public:
     SwiftInfo = std::make_unique<X86_32SwiftABIInfo>(CGT);
   }
 
-  static bool isStructReturnInRegABI(
-      const llvm::Triple &Triple, const CodeGenOptions &Opts);
+  static bool isStructReturnInRegABI(const llvm::Triple &Triple,
+                                     const CodeGenOptions &Opts);
 
   void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,
                            CodeGen::CodeGenModule &CGM) const override;
 
   int getDwarfEHStackPointer(CodeGen::CodeGenModule &CGM) const override {
     // Darwin uses different dwarf register numbers for EH.
-    if (CGM.getTarget().getTriple().isOSDarwin()) return 5;
+    if (CGM.getTarget().getTriple().isOSDarwin())
+      return 5;
     return 4;
   }
 
   bool initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,
                                llvm::Value *Address) const override;
 
-  llvm::Type* adjustInlineAsmType(CodeGen::CodeGenFunction &CGF,
+  llvm::Type *adjustInlineAsmType(CodeGen::CodeGenFunction &CGF,
                                   StringRef Constraint,
-                                  llvm::Type* Ty) const override {
+                                  llvm::Type *Ty) const override {
     return X86AdjustInlineAsmType(CGF, Constraint, Ty);
   }
 
@@ -236,7 +233,7 @@ public:
   }
 };
 
-}
+} // namespace
 
 /// Rewrite input constraint references after adding some output constraints.
 /// In the case where there is one output and one input and we add one output,
@@ -329,7 +326,7 @@ bool X86_32ABIInfo::shouldReturnTypeInRegister(QualType Ty,
   // For i386, type must be register sized.
   // For the MCU ABI, it only needs to be <= 8-byte
   if ((IsMCUABI && Size > 64) || (!IsMCUABI && !isRegisterSize(Size)))
-   return false;
+    return false;
 
   if (Ty->isVectorType()) {
     // 64- and 128- bit vectors inside structures are not returned in
@@ -353,7 +350,8 @@ bool X86_32ABIInfo::shouldReturnTypeInRegister(QualType Ty,
 
   // Otherwise, it must be a record type.
   const RecordType *RT = Ty->getAs<RecordType>();
-  if (!RT) return false;
+  if (!RT)
+    return false;
 
   // FIXME: Traverse bases here too.
 
@@ -453,7 +451,8 @@ bool X86_32ABIInfo::canExpandIndirectArgument(QualType Ty) const {
   return Size == getContext().getTypeSize(Ty);
 }
 
-ABIArgInfo X86_32ABIInfo::getIndirectReturnResult(QualType RetTy, CCState &State) const {
+ABIArgInfo X86_32ABIInfo::getIndirectReturnResult(QualType RetTy,
+                                                  CCState &State) const {
   // If the return value is indirect, then the hidden argument is consuming one
   // integer register.
   if (State.CC != llvm::CallingConv::X86_FastCall &&
@@ -495,8 +494,8 @@ ABIArgInfo X86_32ABIInfo::classifyReturnType(QualType RetTy,
       // register, or if it is 64 bits and has a single element.
       if ((Size == 8 || Size == 16 || Size == 32) ||
           (Size == 64 && VT->getNumElements() == 1))
-        return ABIArgInfo::getDirect(llvm::IntegerType::get(getVMContext(),
-                                                            Size));
+        return ABIArgInfo::getDirect(
+            llvm::IntegerType::get(getVMContext(), Size));
 
       return getIndirectReturnResult(RetTy, State);
     }
@@ -538,13 +537,14 @@ ABIArgInfo X86_32ABIInfo::classifyReturnType(QualType RetTy,
       // We apply a similar transformation for pointer types to improve the
       // quality of the generated IR.
       if (const Type *SeltTy = isSingleElementStruct(RetTy, getContext()))
-        if ((!IsWin32StructABI && SeltTy->isRealFloatingType())
-            || SeltTy->hasPointerRepresentation())
+        if ((!IsWin32StructABI && SeltTy->isRealFloatingType()) ||
+            SeltTy->hasPointerRepresentation())
           return ABIArgInfo::getDirect(CGT.ConvertType(QualType(SeltTy, 0)));
 
       // FIXME: We should be able to narrow this integer in cases with dead
       // padding.
-      return ABIArgInfo::getDirect(llvm::IntegerType::get(getVMContext(),Size));
+      return ABIArgInfo::getDirect(
+          llvm::IntegerType::get(getVMContext(), Size));
     }
 
     return getIndirectReturnResult(RetTy, State);
@@ -708,7 +708,8 @@ bool X86_32ABIInfo::shouldPrimitiveUseInReg(QualType Ty, CCState &State) const {
   return !IsMCUABI;
 }
 
-void X86_32ABIInfo::runVectorCallFirstPass(CGFunctionInfo &FI, CCState &State) const {
+void X86_32ABIInfo::runVectorCallFirstPass(CGFunctionInfo &FI,
+                                           CCState &State) const {
   // Vectorcall x86 works subtly different than in x64, so the format is
   // a bit different than the x64 version.  First, all vector types (not HVAs)
   // are assigned, with the first 6 ending up in the [XYZ]MM0-5 registers.
@@ -805,7 +806,7 @@ ABIArgInfo X86_32ABIInfo::classifyArgumentType(QualType Ty, CCState &State,
     bool InReg;
     if (shouldAggregateUseDirect(Ty, State, InReg, NeedsPadding)) {
       unsigned SizeInRegs = (TI.Width + 31) / 32;
-      SmallVector<llvm::Type*, 3> Elements(SizeInRegs, Int32);
+      SmallVector<llvm::Type *, 3> Elements(SizeInRegs, Int32);
       llvm::Type *Result = llvm::StructType::get(LLVMContext, Elements);
       if (InReg)
         return ABIArgInfo::getDirectInReg(Result);
@@ -823,7 +824,7 @@ ABIArgInfo X86_32ABIInfo::classifyArgumentType(QualType Ty, CCState &State,
       unsigned AlignInBits = 0;
       if (RT) {
         const ASTRecordLayout &Layout =
-          getContext().getASTRecordLayout(RT->getDecl());
+            getContext().getASTRecordLayout(RT->getDecl());
         AlignInBits = getContext().toBits(Layout.getRequiredAlignment());
       } else if (TI.isAlignRequired()) {
         AlignInBits = TI.Align;
@@ -873,7 +874,6 @@ ABIArgInfo X86_32ABIInfo::classifyArgumentType(QualType Ty, CCState &State,
     return ABIArgInfo::getDirect();
   }
 
-
   if (const EnumType *EnumTy = Ty->getAs<EnumType>())
     Ty = EnumTy->getDecl()->getIntegerType();
 
@@ -928,7 +928,7 @@ void X86_32ABIInfo::computeInfo(CGFunctionInfo &FI) const {
     // The C++ ABI is not aware of register usage, so we have to check if the
     // return value was sret and put it in a register ourselves if appropriate.
     if (State.FreeRegs) {
-      --State.FreeRegs;  // The sret parameter consumes a register.
+      --State.FreeRegs; // The sret parameter consumes a register.
       if (!IsMCUABI)
         FI.getReturnInfo().setInReg(true);
     }
@@ -950,8 +950,7 @@ void X86_32ABIInfo::computeInfo(CGFunctionInfo &FI) const {
     if (State.IsPreassigned.test(I))
       continue;
 
-    Args[I].info =
-        classifyArgumentType(Args[I].type, State, I);
+    Args[I].info = classifyArgumentType(Args[I].type, State, I);
     UsedInAlloca |= (Args[I].info.getKind() == ABIArgInfo::InAlloca);
   }
 
@@ -961,10 +960,9 @@ void X86_32ABIInfo::computeInfo(CGFunctionInfo &FI) const {
     rewriteWithInAlloca(FI);
 }
 
-void
-X86_32ABIInfo::addFieldToArgStruct(SmallVector<llvm::Type *, 6> &FrameFields,
-                                   CharUnits &StackOffset, ABIArgInfo &Info,
-                                   QualType Type) const {
+void X86_32ABIInfo::addFieldToArgStruct(
+    SmallVector<llvm::Type *, 6> &FrameFields, CharUnits &StackOffset,
+    ABIArgInfo &Info, QualType Type) const {
   // Arguments are always 4-byte-aligned.
   CharUnits WordSize = CharUnits::fromQuantity(4);
   assert(StackOffset.isMultipleOf(WordSize) && "unaligned inalloca struct");
@@ -1074,7 +1072,7 @@ RValue X86_32ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
   // Just messing with TypeInfo like this works because we never pass
   // anything indirectly.
   TypeInfo.Align = CharUnits::fromQuantity(
-                getTypeStackAlignInBytes(Ty, TypeInfo.Align.getQuantity()));
+      getTypeStackAlignInBytes(Ty, TypeInfo.Align.getQuantity()));
 
   return emitVoidPtrVAArg(CGF, VAListAddr, Ty, /*Indirect*/ false, TypeInfo,
                           CharUnits::fromQuantity(4),
@@ -1088,9 +1086,9 @@ bool X86_32TargetCodeGenInfo::isStructReturnInRegABI(
   switch (Opts.getStructReturnConvention()) {
   case CodeGenOptions::SRCK_Default:
     break;
-  case CodeGenOptions::SRCK_OnStack:  // -fpcc-struct-return
+  case CodeGenOptions::SRCK_OnStack: // -fpcc-struct-return
     return false;
-  case CodeGenOptions::SRCK_InRegs:  // -freg-struct-return
+  case CodeGenOptions::SRCK_InRegs: // -freg-struct-return
     return true;
   }
 
@@ -1120,8 +1118,8 @@ static void addX86InterruptAttrs(const FunctionDecl *FD, llvm::GlobalValue *GV,
 
   auto PtrTy = cast<PointerType>(FD->getParamDecl(0)->getType());
   llvm::Type *ByValTy = CGM.getTypes().ConvertType(PtrTy->getPointeeType());
-  llvm::Attribute NewAttr = llvm::Attribute::getWithByValType(
-    Fn->getContext(), ByValTy);
+  llvm::Attribute NewAttr =
+      llvm::Attribute::getWithByValType(Fn->getContext(), ByValTy);
   Fn->addParamAttr(0, NewAttr);
 }
 
@@ -1140,8 +1138,7 @@ void X86_32TargetCodeGenInfo::setTargetAttributes(
 }
 
 bool X86_32TargetCodeGenInfo::initDwarfEHRegSizeTable(
-                                               CodeGen::CodeGenFunction &CGF,
-                                               llvm::Value *Address) const {
+    CodeGen::CodeGenFunction &CGF, llvm::Value *Address) const {
   CodeGen::CGBuilderTy &Builder = CGF.Builder;
 
   llvm::Value *Four8 = llvm::ConstantInt::get(CGF.Int8Ty, 4);
@@ -1163,7 +1160,7 @@ bool X86_32TargetCodeGenInfo::initDwarfEHRegSizeTable(
     // reason.
     Builder.CreateAlignedStore(
         Four8, Builder.CreateConstInBoundsGEP1_32(CGF.Int8Ty, Address, 9),
-                               CharUnits::One());
+        CharUnits::One());
 
     // 11-16 are st(0..5).  Not sure why we stop at 5.
     // These have size 12, which is sizeof(long double) on
@@ -1179,7 +1176,6 @@ bool X86_32TargetCodeGenInfo::initDwarfEHRegSizeTable(
 // X86-64 ABI Implementation
 //===----------------------------------------------------------------------===//
 
-
 namespace {
 
 /// \p returns the size in bits of the largest (native) vector for \p AVXLevel.
@@ -1265,11 +1261,11 @@ class X86_64ABIInfo : public ABIInfo {
                 bool isNamedArg, bool IsRegCall = false) const;
 
   llvm::Type *GetByteVectorType(QualType Ty) const;
-  llvm::Type *GetSSETypeAtOffset(llvm::Type *IRType,
-                                 unsigned IROffset, QualType SourceTy,
+  llvm::Type *GetSSETypeAtOffset(llvm::Type *IRType, unsigned IROffset,
+                                 QualType SourceTy,
                                  unsigned SourceOffset) const;
-  llvm::Type *GetINTEGERTypeAtOffset(llvm::Type *IRType,
-                                     unsigned IROffset, QualType SourceTy,
+  llvm::Type *GetINTEGERTypeAtOffset(llvm::Type *IRType, unsigned IROffset,
+                                     QualType SourceTy,
                                      unsigned SourceOffset) const;
 
   /// getIndirectResult - Give a source type \arg Ty, return a suitable result
@@ -1348,7 +1344,7 @@ public:
     unsigned neededInt, neededSSE;
     // The freeIntRegs argument doesn't matter here.
     ABIArgInfo info = classifyArgumentType(type, 0, neededInt, neededSSE,
-                                           /*isNamedArg*/true);
+                                           /*isNamedArg*/ true);
     if (info.isDirect()) {
       llvm::Type *ty = info.getCoerceToType();
       if (llvm::VectorType *vectorTy = dyn_cast_or_null<llvm::VectorType>(ty))
@@ -1364,9 +1360,7 @@ public:
   RValue EmitMSVAArg(CodeGenFunction &CGF, Address VAListAddr, QualType Ty,
                      AggValueSlot Slot) const override;
 
-  bool has64BitPointers() const {
-    return Has64BitPointers;
-  }
+  bool has64BitPointers() const { return Has64BitPointers; }
 };
 
 /// WinX86_64ABIInfo - The Windows X86_64 ABI information.
@@ -1429,9 +1423,9 @@ public:
     return false;
   }
 
-  llvm::Type* adjustInlineAsmType(CodeGen::CodeGenFunction &CGF,
+  llvm::Type *adjustInlineAsmType(CodeGen::CodeGenFunction &CGF,
                                   StringRef Constraint,
-                                  llvm::Type* Ty) const override {
+                                  llvm::Type *Ty) const override {
     return X86AdjustInlineAsmType(CGF, Constraint, Ty);
   }
 
@@ -1445,8 +1439,8 @@ public:
     // defines varargs anyway.
     if (fnType->getCallConv() == CC_C) {
       bool HasAVXType = false;
-      for (CallArgList::const_iterator
-             it = args.begin(), ie = args.end(); it != ie; ++it) {
+      for (CallArgList::const_iterator it = args.begin(), ie = args.end();
+           it != ie; ++it) {
         if (getABIInfo<X86_64ABIInfo>().isPassedUsingAVXType(it->Ty)) {
           HasAVXType = true;
           break;
@@ -1618,11 +1612,11 @@ std::string TargetCodeGenInfo::qualifyWindowsLibrary(StringRef Lib) {
 namespace {
 class WinX86_32TargetCodeGenInfo : public X86_32TargetCodeGenInfo {
 public:
-  WinX86_32TargetCodeGenInfo(CodeGen::CodeGenTypes &CGT,
-        bool DarwinVectorABI, bool RetSmallStructInRegABI, bool Win32StructABI,
-        unsigned NumRegisterParameters)
-    : X86_32TargetCodeGenInfo(CGT, DarwinVectorABI, RetSmallStructInRegABI,
-        Win32StructABI, NumRegisterParameters, false) {}
+  WinX86_32TargetCodeGenInfo(CodeGen::CodeGenTypes &CGT, bool DarwinVectorABI,
+                             bool RetSmallStructInRegABI, bool Win32StructABI,
+                             unsigned NumRegisterParameters)
+      : X86_32TargetCodeGenInfo(CGT, DarwinVectorABI, RetSmallStructInRegABI,
+                                Win32StructABI, NumRegisterParameters, false) {}
 
   void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,
                            CodeGen::CodeGenModule &CGM) const override;
@@ -1633,8 +1627,7 @@ public:
     Opt += qualifyWindowsLibrary(Lib);
   }
 
-  void getDetectMismatchOption(llvm::StringRef Name,
-                               llvm::StringRef Value,
+  void getDetectMismatchOption(llvm::StringRef Name, llvm::StringRef Value,
                                llvm::SmallString<32> &Opt) const override {
     Opt = "/FAILIFMISMATCH:\"" + Name.str() + "=" + Value.str() + "\"";
   }
@@ -1682,8 +1675,7 @@ public:
     Opt += qualifyWindowsLibrary(Lib);
   }
 
-  void getDetectMismatchOption(llvm::StringRef Name,
-                               llvm::StringRef Value,
+  void getDetectMismatchOption(llvm::StringRef Name, llvm::StringRef Value,
                                llvm::SmallString<32> &Opt) const override {
     Opt = "/FAILIFMISMATCH:\"" + Name.str() + "=" + Value.str() + "\"";
   }
@@ -1774,8 +1766,8 @@ X86_64ABIInfo::Class X86_64ABIInfo::merge(Class Accum, Class Field) {
     return Field;
   if (Accum == Integer || Field == Integer)
     return Integer;
-  if (Field == X87 || Field == X87Up || Field == ComplexX87 ||
-      Accum == X87 || Accum == X87Up)
+  if (Field == X87 || Field == X87Up || Field == ComplexX87 || Accum == X87 ||
+      Accum == X87Up)
     return Memory;
   return SSE;
 }
@@ -2009,7 +2001,8 @@ void X86_64ABIInfo::classify(QualType Ty, uint64_t OffsetBase, Class &Lo,
         (Size != EltSize || Size > getNativeVectorSizeForAVXABI(AVXLevel)))
       return;
 
-    for (uint64_t i=0, Offset=OffsetBase; i<ArraySize; ++i, Offset += EltSize) {
+    for (uint64_t i = 0, Offset = OffsetBase; i < ArraySize;
+         ++i, Offset += EltSize) {
       Class FieldLo, FieldHi;
       classify(AT->getElementType(), Offset, FieldLo, FieldHi, isNamedArg);
       Lo = merge(Lo, FieldLo);
@@ -2063,7 +2056,7 @@ void X86_64ABIInfo::classify(QualType Ty, uint64_t OffsetBase, Class &Lo,
         // initialized to class NO_CLASS.
         Class FieldLo, FieldHi;
         uint64_t Offset =
-          OffsetBase + getContext().toBits(Layout.getBaseClassOffset(Base));
+            OffsetBase + getContext().toBits(Layout.getBaseClassOffset(Base));
         classify(I.getType(), Offset, FieldLo, FieldHi, isNamedArg);
         Lo = merge(Lo, FieldLo);
         Hi = merge(Hi, FieldHi);
@@ -2082,7 +2075,7 @@ void X86_64ABIInfo::classify(QualType Ty, uint64_t OffsetBase, Class &Lo,
     bool IsUnion = RT->isUnionType() && !UseClang11Compat;
 
     for (RecordDecl::field_iterator i = RD->field_begin(), e = RD->field_end();
-           i != e; ++i, ++idx) {
+         i != e; ++i, ++idx) {
       uint64_t Offset = OffsetBase + Layout.getFieldOffset(idx);
       bool BitField = i->isBitField();
 
@@ -2243,8 +2236,8 @@ ABIArgInfo X86_64ABIInfo::getIndirectResult(QualType Ty,
     // If this type fits in an eightbyte, coerce it into the matching integral
     // type, which will end up on the stack (with alignment 8).
     if (Align == 8 && Size <= 64)
-      return ABIArgInfo::getDirect(llvm::IntegerType::get(getVMContext(),
-                                                          Size));
+      return ABIArgInfo::getDirect(
+          llvm::IntegerType::get(getVMContext(), Size));
   }
 
   return ABIArgInfo::getIndirect(CharUnits::fromQuantity(Align));
@@ -2280,7 +2273,6 @@ llvm::Type *X86_64ABIInfo::GetByteVectorType(QualType Ty) const {
   uint64_t Size = getContext().getTypeSize(Ty);
   assert((Size == 128 || Size == 256 || Size == 512) && "Invalid type found!");
 
-
   // Return a LLVM IR vector type based on the size of 'Ty'.
   return llvm::FixedVectorType::get(llvm::Type::getDoubleTy(getVMContext()),
                                     Size / 64);
@@ -2309,12 +2301,13 @@ static bool BitsContainNoUserData(QualType Ty, unsigned StartBit,
     // Check each element to see if the element overlaps with the queried range.
     for (unsigned i = 0; i != NumElts; ++i) {
       // If the element is after the span we care about, then we're done..
-      unsigned EltOffset = i*EltSize;
-      if (EltOffset >= EndBit) break;
+      unsigned EltOffset = i * EltSize;
+      if (EltOffset >= EndBit)
+        break;
 
-      unsigned EltStart = EltOffset < StartBit ? StartBit-EltOffset :0;
+      unsigned EltStart = EltOffset < StartBit ? StartBit - EltOffset : 0;
       if (!BitsContainNoUserData(AT->getElementType(), EltStart,
-                                 EndBit-EltOffset, Context))
+                                 EndBit - EltOffset, Context))
         return false;
     }
     // If it overlaps no elements, then it is safe to process as padding.
@@ -2335,11 +2328,12 @@ static bool BitsContainNoUserData(QualType Ty, unsigned StartBit,
 
         // If the base is after the span we care about, ignore it.
         unsigned BaseOffset = Context.toBits(Layout.getBaseClassOffset(Base));
-        if (BaseOffset >= EndBit) continue;
+        if (BaseOffset >= EndBit)
+          continue;
 
-        unsigned BaseStart = BaseOffset < StartBit ? StartBit-BaseOffset :0;
-        if (!BitsContainNoUserData(I.getType(), BaseStart,
-                                   EndBit-BaseOffset, Context))
+        unsigned BaseStart = BaseOffset < StartBit ? StartBit - BaseOffset : 0;
+        if (!BitsContainNoUserData(I.getType(), BaseStart, EndBit - BaseOffset,
+                                   Context))
           return false;
       }
     }
@@ -2354,10 +2348,11 @@ static bool BitsContainNoUserData(QualType Ty, unsigned StartBit,
       unsigned FieldOffset = (unsigned)Layout.getFieldOffset(idx);
 
       // If we found a field after the region we care about, then we're done.
-      if (FieldOffset >= EndBit) break;
+      if (FieldOffset >= EndBit)
+        break;
 
-      unsigned FieldStart = FieldOffset < StartBit ? StartBit-FieldOffset :0;
-      if (!BitsContainNoUserData(i->getType(), FieldStart, EndBit-FieldOffset,
+      unsigned FieldStart = FieldOffset < StartBit ? StartBit - FieldOffset : 0;
+      if (!BitsContainNoUserData(i->getType(), FieldStart, EndBit - FieldOffset,
                                  Context))
         return false;
     }
@@ -2400,9 +2395,10 @@ static llvm::Type *getFPTypeAtOffset(llvm::Type *IRType, unsigned IROffset,
 
 /// GetSSETypeAtOffset - Return a type that will be passed by the backend in the
 /// low 8 bytes of an XMM register, corresponding to the SSE class.
-llvm::Type *X86_64ABIInfo::
-GetSSETypeAtOffset(llvm::Type *IRType, unsigned IROffset,
-                   QualType SourceTy, unsigned SourceOffset) const {
+llvm::Type *X86_64ABIInfo::GetSSETypeAtOffset(llvm::Type *IRType,
+                                              unsigned IROffset,
+                                              QualType SourceTy,
+                                              unsigned SourceOffset) const {
   const llvm::DataLayout &TD = getDataLayout();
   unsigned SourceSize =
       (unsigned)getContext().getTypeSize(SourceTy) / 8 - SourceOffset;
@@ -2414,10 +2410,10 @@ GetSSETypeAtOffset(llvm::Type *IRType, unsigned IROffset,
   llvm::Type *T1 = nullptr;
   unsigned T0Size = TD.getTypeAllocSize(T0);
   if (SourceSize > T0Size)
-      T1 = getFPTypeAtOffset(IRType, IROffset + T0Size, TD);
+    T1 = getFPTypeAtOffset(IRType, IROffset + T0Size, TD);
   if (T1 == nullptr) {
-    // Check if IRType is a half/bfloat + float. float type will be in IROffset+4 due
-    // to its alignment.
+    // Check if IRType is a half/bfloat + float. float type will be in
+    // IROffset+4 due to its alignment.
     if (T0->is16bitFPTy() && SourceSize > 4)
       T1 = getFPTypeAtOffset(IRType, IROffset + 4, TD);
     // If we can't get a second FP type, return a simple half or float.
@@ -2445,7 +2441,6 @@ GetSSETypeAtOffset(llvm::Type *IRType, unsigned IROffset,
   return llvm::Type::getDoubleTy(getVMContext());
 }
 
-
 /// GetINTEGERTypeAtOffset - The ABI specifies that a value should be passed in
 /// an 8-byte GPR.  This means that we either have a scalar or we are talking
 /// about the high or low part of an up-to-16-byte struct.  This routine picks
@@ -2460,9 +2455,10 @@ GetSSETypeAtOffset(llvm::Type *IRType, unsigned IROffset,
 /// SourceTy is the source-level type for the entire argument.  SourceOffset is
 /// an offset into this that we're processing (which is always either 0 or 8).
 ///
-llvm::Type *X86_64ABIInfo::
-GetINTEGERTypeAtOffset(llvm::Type *IRType, unsigned IROffset,
-                       QualType SourceTy, unsigned SourceOffset) const {
+llvm::Type *X86_64ABIInfo::GetINTEGERTypeAtOffset(llvm::Type *IRType,
+                                                  unsigned IROffset,
+                                                  QualType SourceTy,
+                                                  unsigned SourceOffset) const {
   // If we're dealing with an un-offset LLVM IR type, then it means that we're
   // returning an 8-byte unit starting with it.  See if we can safely use it.
   if (IROffset == 0) {
@@ -2480,11 +2476,12 @@ GetINTEGERTypeAtOffset(llvm::Type *IRType, unsigned IROffset,
     if (IRType->isIntegerTy(8) || IRType->isIntegerTy(16) ||
         IRType->isIntegerTy(32) ||
         (isa<llvm::PointerType>(IRType) && !Has64BitPointers)) {
-      unsigned BitWidth = isa<llvm::PointerType>(IRType) ? 32 :
-          cast<llvm::IntegerType>(IRType)->getBitWidth();
+      unsigned BitWidth = isa<llvm::PointerType>(IRType)
+                              ? 32
+                              : cast<llvm::IntegerType>(IRType)->getBitWidth();
 
-      if (BitsContainNoUserData(SourceTy, SourceOffset*8+BitWidth,
-                                SourceOffset*8+64, getContext()))
+      if (BitsContainNoUserData(SourceTy, SourceOffset * 8 + BitWidth,
+                                SourceOffset * 8 + 64, getContext()))
         return IRType;
     }
   }
@@ -2504,33 +2501,31 @@ GetINTEGERTypeAtOffset(llvm::Type *IRType, unsigned IROffset,
   if (llvm::ArrayType *ATy = dyn_cast<llvm::ArrayType>(IRType)) {
     llvm::Type *EltTy = ATy->getElementType();
     unsigned EltSize = getDataLayout().getTypeAllocSize(EltTy);
-    unsigned EltOffset = IROffset/EltSize*EltSize;
-    return GetINTEGERTypeAtOffset(EltTy, IROffset-EltOffset, SourceTy,
+    unsigned EltOffset = IROffset / EltSize * EltSize;
+    return GetINTEGERTypeAtOffset(EltTy, IROffset - EltOffset, SourceTy,
                                   SourceOffset);
   }
 
   // Okay, we don't have any better idea of what to pass, so we pass this in an
   // integer register that isn't too big to fit the rest of the struct.
   unsigned TySizeInBytes =
-    (unsigned)getContext().getTypeSizeInChars(SourceTy).getQuantity();
+      (unsigned)getContext().getTypeSizeInChars(SourceTy).getQuantity();
 
   assert(TySizeInBytes != SourceOffset && "Empty field?");
 
   // It is always safe to classify this as an integer type up to i64 that
   // isn't larger than the structure.
   return llvm::IntegerType::get(getVMContext(),
-                                std::min(TySizeInBytes-SourceOffset, 8U)*8);
+                                std::min(TySizeInBytes - SourceOffset, 8U) * 8);
 }
 
-
 /// GetX86_64ByValArgumentPair - Given a high and low type that can ideally
 /// be used as elements of a two register pair to pass or return, return a
 /// first class aggregate to represent them.  For example, if the low part of
 /// a by-value argument should be passed as i32* and the high part as float,
 /// return {i32*, float}.
-static llvm::Type *
-GetX86_64ByValArgumentPair(llvm::Type *Lo, llvm::Type *Hi,
-                           const llvm::DataLayout &TD) {
+static llvm::Type *GetX86_64ByValArgumentPair(llvm::Type *Lo, llvm::Type *Hi,
+                                              const llvm::DataLayout &TD) {
   // In order to correctly satisfy the ABI, we need to the high part to start
   // at offset 8.  If the high and low parts we inferred are both 4-byte types
   // (e.g. i32 and i32) then the resultant struct type ({i32,i32}) won't have
@@ -2553,8 +2548,8 @@ GetX86_64ByValArgumentPair(llvm::Type *Lo, llvm::Type *Hi,
     if (Lo->isHalfTy() || Lo->isFloatTy())
       Lo = llvm::Type::getDoubleTy(Lo->getContext());
     else {
-      assert((Lo->isIntegerTy() || Lo->isPointerTy())
-             && "Invalid/unknown lo type");
+      assert((Lo->isIntegerTy() || Lo->isPointerTy()) &&
+             "Invalid/unknown lo type");
       Lo = llvm::Type::getInt64Ty(Lo->getContext());
     }
   }
@@ -2567,8 +2562,7 @@ GetX86_64ByValArgumentPair(llvm::Type *Lo, llvm::Type *Hi,
   return Result;
 }
 
-ABIArgInfo X86_64ABIInfo::
-classifyReturnType(QualType RetTy) const {
+ABIArgInfo X86_64ABIInfo::classifyReturnType(QualType RetTy) const {
   // AMD64-ABI 3.2.3p4: Rule 1. Classify the return type with the
   // classification algorithm.
   X86_64ABIInfo::Class Lo, Hi;
@@ -2652,12 +2646,12 @@ classifyReturnType(QualType RetTy) const {
 
   case Integer:
     HighPart = GetINTEGERTypeAtOffset(CGT.ConvertType(RetTy), 8, RetTy, 8);
-    if (Lo == NoClass)  // Return HighPart at offset 8 in memory.
+    if (Lo == NoClass) // Return HighPart at offset 8 in memory.
       return ABIArgInfo::getDirect(HighPart, 8);
     break;
   case SSE:
     HighPart = GetSSETypeAtOffset(CGT.ConvertType(RetTy), 8, RetTy, 8);
-    if (Lo == NoClass)  // Return HighPart at offset 8 in memory.
+    if (Lo == NoClass) // Return HighPart at offset 8 in memory.
       return ABIArgInfo::getDirect(HighPart, 8);
     break;
 
@@ -2680,7 +2674,7 @@ classifyReturnType(QualType RetTy) const {
     // extra bits in an SSE reg.
     if (Lo != X87) {
       HighPart = GetSSETypeAtOffset(CGT.ConvertType(RetTy), 8, RetTy, 8);
-      if (Lo == NoClass)  // Return HighPart at offset 8 in memory.
+      if (Lo == NoClass) // Return HighPart at offset 8 in memory.
         return ABIArgInfo::getDirect(HighPart, 8);
     }
     break;
@@ -2782,14 +2776,15 @@ X86_64ABIInfo::classifyArgumentType(QualType Ty, unsigned freeIntRegs,
   case ComplexX87:
     llvm_unreachable("Invalid classification for hi word.");
 
-  case NoClass: break;
+  case NoClass:
+    break;
 
   case Integer:
     ++neededInt;
     // Pick an 8-byte type based on the preferred type.
     HighPart = GetINTEGERTypeAtOffset(CGT.ConvertType(Ty), 8, Ty, 8);
 
-    if (Lo == NoClass)  // Pass HighPart at offset 8 in memory.
+    if (Lo == NoClass) // Pass HighPart at offset 8 in memory.
       return ABIArgInfo::getDirect(HighPart, 8);
     break;
 
@@ -2800,7 +2795,7 @@ X86_64ABIInfo::classifyArgumentType(QualType Ty, unsigned freeIntRegs,
     ++neededSSE;
     HighPart = GetSSETypeAtOffset(CGT.ConvertType(Ty), 8, Ty, 8);
 
-    if (Lo == NoClass)  // Pass HighPart at offset 8 in memory.
+    if (Lo == NoClass) // Pass HighPart at offset 8 in memory.
       return ABIArgInfo::getDirect(HighPart, 8);
     break;
 
@@ -2980,7 +2975,7 @@ static Address EmitX86_64VAArgFromMemory(CodeGenFunction &CGF,
   Address overflow_arg_area_p =
       CGF.Builder.CreateStructGEP(VAListAddr, 2, "overflow_arg_area_p");
   llvm::Value *overflow_arg_area =
-    CGF.Builder.CreateLoad(overflow_arg_area_p, "overflow_arg_area");
+      CGF.Builder.CreateLoad(overflow_arg_area_p, "overflow_arg_area");
 
   // AMD64-ABI 3.5.7p5: Step 7. Align l->overflow_arg_area upwards to a 16
   // byte boundary if alignment needed by type exceeds 8 byte boundary.
@@ -2988,8 +2983,8 @@ static Address EmitX86_64VAArgFromMemory(CodeGenFunction &CGF,
   // alignment greater than 16 where necessary.
   CharUnits Align = CGF.getContext().getTypeAlignInChars(Ty);
   if (Align > CharUnits::fromQuantity(8)) {
-    overflow_arg_area = emitRoundPointerUpToAlignment(CGF, overflow_arg_area,
-                                                      Align);
+    overflow_arg_area =
+        emitRoundPointerUpToAlignment(CGF, overflow_arg_area, Align);
   }
 
   // AMD64-ABI 3.5.7p5: Step 8. Fetch type from l->overflow_arg_area.
@@ -3003,7 +2998,7 @@ static Address EmitX86_64VAArgFromMemory(CodeGenFunction &CGF,
 
   uint64_t SizeInBytes = (CGF.getContext().getTypeSize(Ty) + 7) / 8;
   llvm::Value *Offset =
-      llvm::ConstantInt::get(CGF.Int32Ty, (SizeInBytes + 7)  & ~7);
+      llvm::ConstantInt::get(CGF.Int32Ty, (SizeInBytes + 7) & ~7);
   overflow_arg_area = CGF.Builder.CreateGEP(CGF.Int8Ty, overflow_arg_area,
                                             Offset, "overflow_arg_area.next");
   CGF.Builder.CreateStore(overflow_arg_area, overflow_arg_area_p);
@@ -3025,7 +3020,7 @@ RValue X86_64ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
 
   Ty = getContext().getCanonicalType(Ty);
   ABIArgInfo AI = classifyArgumentType(Ty, 0, neededInt, neededSSE,
-                                       /*isNamedArg*/false);
+                                       /*isNamedArg*/ false);
 
   // Empty records are ignored for parameter passing purposes.
   if (AI.isIgnore())
@@ -3063,7 +3058,7 @@ RValue X86_64ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
     fp_offset_p = CGF.Builder.CreateStructGEP(VAListAddr, 1, "fp_offset_p");
     fp_offset = CGF.Builder.CreateLoad(fp_offset_p, "fp_offset");
     llvm::Value *FitsInFP =
-      llvm::ConstantInt::get(CGF.Int32Ty, 176 - neededSSE * 16);
+        llvm::ConstantInt::get(CGF.Int32Ty, 176 - neededSSE * 16);
     FitsInFP = CGF.Builder.CreateICmpULE(fp_offset, FitsInFP, "fits_in_fp");
     InRegs = InRegs ? CGF.Builder.CreateAnd(InRegs, FitsInFP) : FitsInFP;
   }
@@ -3189,12 +3184,11 @@ RValue X86_64ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
     // to assume that the slots are 16-byte aligned, since the stack is
     // naturally 16-byte aligned and the prologue is expected to store
     // all the SSE registers to the RSA.
-    Address RegAddrLo = Address(CGF.Builder.CreateGEP(CGF.Int8Ty, RegSaveArea,
-                                                      fp_offset),
-                                CGF.Int8Ty, CharUnits::fromQuantity(16));
-    Address RegAddrHi =
-      CGF.Builder.CreateConstInBoundsByteGEP(RegAddrLo,
-                                             CharUnits::fromQuantity(16));
+    Address RegAddrLo =
+        Address(CGF.Builder.CreateGEP(CGF.Int8Ty, RegSaveArea, fp_offset),
+                CGF.Int8Ty, CharUnits::fromQuantity(16));
+    Address RegAddrHi = CGF.Builder.CreateConstInBoundsByteGEP(
+        RegAddrLo, CharUnits::fromQuantity(16));
     llvm::Type *ST = AI.canHaveCoerceToType()
                          ? AI.getCoerceToType()
                          : llvm::StructType::get(CGF.DoubleTy, CGF.DoubleTy);
@@ -3234,8 +3228,8 @@ RValue X86_64ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
   // Return the appropriate result.
 
   CGF.EmitBlock(ContBlock);
-  Address ResAddr = emitMergePHI(CGF, RegAddr, InRegBlock, MemAddr, InMemBlock,
-                                 "vaarg.addr");
+  Address ResAddr =
+      emitMergePHI(CGF, RegAddr, InRegBlock, MemAddr, InMemBlock, "vaarg.addr");
   return CGF.EmitLoadOfAnyValue(CGF.MakeAddrLValue(ResAddr, Ty), Slot);
 }
 
@@ -3288,7 +3282,6 @@ ABIArgInfo WinX86_64ABIInfo::classify(QualType Ty, unsigned &FreeSSERegs,
 
     if (RT->getDecl()->hasFlexibleArrayMember())
       return getNaturalAlignIndirect(Ty, /*ByVal=*/false);
-
   }
 
   const Type *Base = nullptr;
diff --git a/clang/lib/CodeGen/Targets/XCore.cpp b/clang/lib/CodeGen/Targets/XCore.cpp
index ced4981fd124..76a383fdea81 100644
--- a/clang/lib/CodeGen/Targets/XCore.cpp
+++ b/clang/lib/CodeGen/Targets/XCore.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ABIInfoImpl.h"
-#include "TargetInfo.h"
+#include "../ABIInfoImpl.h"
+#include "../TargetInfo.h"
 
 using namespace clang;
 using namespace clang::CodeGen;
@@ -77,7 +77,7 @@ typedef llvm::SmallString<128> SmallStringEnc;
 ///   been exited too soon for the encoding to be correct for the member.
 ///
 class TypeStringCache {
-  enum Status {NonRecursive, Recursive, Incomplete, IncompleteUsed};
+  enum Status { NonRecursive, Recursive, Incomplete, IncompleteUsed };
   struct Entry {
     std::string Str;     // The encoded TypeString for the type.
     enum Status State;   // Information about the encoding in 'Str'.
@@ -91,8 +91,7 @@ public:
   TypeStringCache() : IncompleteCount(0), IncompleteUsedCount(0) {}
   void addIncomplete(const IdentifierInfo *ID, std::string StubEnc);
   bool removeIncomplete(const IdentifierInfo *ID);
-  void addIfComplete(const IdentifierInfo *ID, StringRef Str,
-                     bool IsRecursive);
+  void addIfComplete(const IdentifierInfo *ID, StringRef Str, bool IsRecursive);
   StringRef lookupStr(const IdentifierInfo *ID);
 };
 
@@ -101,11 +100,13 @@ public:
 class FieldEncoding {
   bool HasName;
   std::string Enc;
+
 public:
   FieldEncoding(bool b, SmallStringEnc &e) : HasName(b), Enc(e.c_str()) {}
   StringRef str() { return Enc; }
   bool operator<(const FieldEncoding &rhs) const {
-    if (HasName != rhs.HasName) return HasName;
+    if (HasName != rhs.HasName)
+      return HasName;
     return Enc < rhs.Enc;
   }
 };
@@ -196,7 +197,7 @@ void TypeStringCache::addIncomplete(const IdentifierInfo *ID,
   if (!ID)
     return;
   Entry &E = Map[ID];
-  assert( (E.Str.empty() || E.State == Recursive) &&
+  assert((E.Str.empty() || E.State == Recursive) &&
          "Incorrectly use of addIncomplete");
   assert(!StubEnc.empty() && "Passing an empty string to addIncomplete()");
   E.Swapped.swap(E.Str); // swap out the Recursive
@@ -215,8 +216,7 @@ bool TypeStringCache::removeIncomplete(const IdentifierInfo *ID) {
   auto I = Map.find(ID);
   assert(I != Map.end() && "Entry not present");
   Entry &E = I->second;
-  assert( (E.State == Incomplete ||
-           E.State == IncompleteUsed) &&
+  assert((E.State == Incomplete || E.State == IncompleteUsed) &&
          "Entry must be an incomplete type");
   bool IsRecursive = false;
   if (E.State == IncompleteUsed) {
@@ -244,7 +244,7 @@ void TypeStringCache::addIfComplete(const IdentifierInfo *ID, StringRef Str,
     return; // No key or it is an incomplete sub-type so don't add.
   Entry &E = Map[ID];
   if (IsRecursive && !E.Str.empty()) {
-    assert(E.State==Recursive && E.Str.size() == Str.size() &&
+    assert(E.State == Recursive && E.Str.size() == Str.size() &&
            "This is not the same Recursive entry");
     // The parent container was not recursive after all, so we could have used
     // this Recursive sub-member entry after all, but we assumed the worse when
@@ -253,7 +253,7 @@ void TypeStringCache::addIfComplete(const IdentifierInfo *ID, StringRef Str,
   }
   assert(E.Str.empty() && "Entry already present");
   E.Str = Str.str();
-  E.State = IsRecursive? Recursive : NonRecursive;
+  E.State = IsRecursive ? Recursive : NonRecursive;
 }
 
 /// Return a cached TypeString encoding for the ID. If there isn't one, or we
@@ -261,13 +261,13 @@ void TypeStringCache::addIfComplete(const IdentifierInfo *ID, StringRef Str,
 /// encoding is Recursive, return an empty StringRef.
 StringRef TypeStringCache::lookupStr(const IdentifierInfo *ID) {
   if (!ID)
-    return StringRef();   // We have no key.
+    return StringRef(); // We have no key.
   auto I = Map.find(ID);
   if (I == Map.end())
-    return StringRef();   // We have no encoding.
+    return StringRef(); // We have no encoding.
   Entry &E = I->second;
   if (E.State == Recursive && IncompleteCount)
-    return StringRef();   // We don't use Recursive encodings for member types.
+    return StringRef(); // We don't use Recursive encodings for member types.
 
   if (E.State == Incomplete) {
     // The incomplete type is being used to break out of recursion.
@@ -303,7 +303,7 @@ void XCoreTargetCodeGenInfo::emitTargetMD(
     llvm::Metadata *MDVals[] = {llvm::ConstantAsMetadata::get(GV),
                                 llvm::MDString::get(Ctx, Enc.str())};
     llvm::NamedMDNode *MD =
-      CGM.getModule().getOrInsertNamedMetadata("xcore.typestrings");
+        CGM.getModule().getOrInsertNamedMetadata("xcore.typestrings");
     MD->addOperand(llvm::MDNode::get(Ctx, MDVals));
   }
 }
@@ -325,8 +325,7 @@ void XCoreTargetCodeGenInfo::emitTargetMetadata(
 }
 
 static bool appendType(SmallStringEnc &Enc, QualType QType,
-                       const CodeGen::CodeGenModule &CGM,
-                       TypeStringCache &TSC);
+                       const CodeGen::CodeGenModule &CGM, TypeStringCache &TSC);
 
 /// Helper function for appendRecordType().
 /// Builds a SmallVector containing the encoded field types in declaration
@@ -371,7 +370,7 @@ static bool appendRecordType(SmallStringEnc &Enc, const RecordType *RT,
 
   // Start to emit an incomplete TypeString.
   size_t Start = Enc.size();
-  Enc += (RT->isUnionType()? 'u' : 's');
+  Enc += (RT->isUnionType() ? 'u' : 's');
   Enc += '(';
   if (ID)
     Enc += ID->getName();
@@ -386,10 +385,10 @@ static bool appendRecordType(SmallStringEnc &Enc, const RecordType *RT,
     // complete TypeString for this RecordType.
     SmallVector<FieldEncoding, 16> FE;
     std::string StubEnc(Enc.substr(Start).str());
-    StubEnc += '}';  // StubEnc now holds a valid incomplete TypeString.
+    StubEnc += '}'; // StubEnc now holds a valid incomplete TypeString.
     TSC.addIncomplete(ID, std::move(StubEnc));
     if (!extractFieldType(FE, RD, CGM, TSC)) {
-      (void) TSC.removeIncomplete(ID);
+      (void)TSC.removeIncomplete(ID);
       return false;
     }
     IsRecursive = TSC.removeIncomplete(ID);
@@ -412,8 +411,7 @@ static bool appendRecordType(SmallStringEnc &Enc, const RecordType *RT,
 
 /// Appends enum types to Enc and adds the encoding to the cache.
 static bool appendEnumType(SmallStringEnc &Enc, const EnumType *ET,
-                           TypeStringCache &TSC,
-                           const IdentifierInfo *ID) {
+                           TypeStringCache &TSC, const IdentifierInfo *ID) {
   // Append the cached TypeString if we have one.
   StringRef TypeString = TSC.lookupStr(ID);
   if (!TypeString.empty()) {
@@ -457,14 +455,15 @@ static bool appendEnumType(SmallStringEnc &Enc, const EnumType *ET,
 /// This is done prior to appending the type's encoding.
 static void appendQualifier(SmallStringEnc &Enc, QualType QT) {
   // Qualifiers are emitted in alphabetical order.
-  static const char *const Table[]={"","c:","r:","cr:","v:","cv:","rv:","crv:"};
+  static const char *const Table[] = {
+      "", "c:", "r:", "cr:", "v:", "cv:", "rv:", "crv:"};
   int Lookup = 0;
   if (QT.isConstQualified())
-    Lookup += 1<<0;
+    Lookup += 1 << 0;
   if (QT.isRestrictQualified())
-    Lookup += 1<<1;
+    Lookup += 1 << 1;
   if (QT.isVolatileQualified())
-    Lookup += 1<<2;
+    Lookup += 1 << 2;
   Enc += Table[Lookup];
 }
 
@@ -472,56 +471,56 @@ static void appendQualifier(SmallStringEnc &Enc, QualType QT) {
 static bool appendBuiltinType(SmallStringEnc &Enc, const BuiltinType *BT) {
   const char *EncType;
   switch (BT->getKind()) {
-    case BuiltinType::Void:
-      EncType = "0";
-      break;
-    case BuiltinType::Bool:
-      EncType = "b";
-      break;
-    case BuiltinType::Char_U:
-      EncType = "uc";
-      break;
-    case BuiltinType::UChar:
-      EncType = "uc";
-      break;
-    case BuiltinType::SChar:
-      EncType = "sc";
-      break;
-    case BuiltinType::UShort:
-      EncType = "us";
-      break;
-    case BuiltinType::Short:
-      EncType = "ss";
-      break;
-    case BuiltinType::UInt:
-      EncType = "ui";
-      break;
-    case BuiltinType::Int:
-      EncType = "si";
-      break;
-    case BuiltinType::ULong:
-      EncType = "ul";
-      break;
-    case BuiltinType::Long:
-      EncType = "sl";
-      break;
-    case BuiltinType::ULongLong:
-      EncType = "ull";
-      break;
-    case BuiltinType::LongLong:
-      EncType = "sll";
-      break;
-    case BuiltinType::Float:
-      EncType = "ft";
-      break;
-    case BuiltinType::Double:
-      EncType = "d";
-      break;
-    case BuiltinType::LongDouble:
-      EncType = "ld";
-      break;
-    default:
-      return false;
+  case BuiltinType::Void:
+    EncType = "0";
+    break;
+  case BuiltinType::Bool:
+    EncType = "b";
+    break;
+  case BuiltinType::Char_U:
+    EncType = "uc";
+    break;
+  case BuiltinType::UChar:
+    EncType = "uc";
+    break;
+  case BuiltinType::SChar:
+    EncType = "sc";
+    break;
+  case BuiltinType::UShort:
+    EncType = "us";
+    break;
+  case BuiltinType::Short:
+    EncType = "ss";
+    break;
+  case BuiltinType::UInt:
+    EncType = "ui";
+    break;
+  case BuiltinType::Int:
+    EncType = "si";
+    break;
+  case BuiltinType::ULong:
+    EncType = "ul";
+    break;
+  case BuiltinType::Long:
+    EncType = "sl";
+    break;
+  case BuiltinType::ULongLong:
+    EncType = "ull";
+    break;
+  case BuiltinType::LongLong:
+    EncType = "sll";
+    break;
+  case BuiltinType::Float:
+    EncType = "ft";
+    break;
+  case BuiltinType::Double:
+    EncType = "d";
+    break;
+  case BuiltinType::LongDouble:
+    EncType = "ld";
+    break;
+  default:
+    return false;
   }
   Enc += EncType;
   return true;
@@ -562,8 +561,8 @@ static bool appendArrayType(SmallStringEnc &Enc, QualType QT,
 /// Appends a function encoding to Enc, calling appendType for the return type
 /// and the arguments.
 static bool appendFunctionType(SmallStringEnc &Enc, const FunctionType *FT,
-                             const CodeGen::CodeGenModule &CGM,
-                             TypeStringCache &TSC) {
+                               const CodeGen::CodeGenModule &CGM,
+                               TypeStringCache &TSC) {
   Enc += "f{";
   if (!appendType(Enc, FT->getReturnType(), CGM, TSC))
     return false;
diff --git a/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp b/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp
index 2ffbc1a22695..0e06d21cc56f 100644
--- a/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp
+++ b/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "DirectoryScanner.h"
+#include "../DirectoryScanner.h"
 #include "clang/DirectoryWatcher/DirectoryWatcher.h"
 
 #include "llvm/ADT/STLExtras.h"
diff --git a/clang/lib/DirectoryWatcher/mac/DirectoryWatcher-mac.cpp b/clang/lib/DirectoryWatcher/mac/DirectoryWatcher-mac.cpp
index b8788bae8171..07e9ecbe5c65 100644
--- a/clang/lib/DirectoryWatcher/mac/DirectoryWatcher-mac.cpp
+++ b/clang/lib/DirectoryWatcher/mac/DirectoryWatcher-mac.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "DirectoryScanner.h"
+#include "../DirectoryScanner.h"
 #include "clang/DirectoryWatcher/DirectoryWatcher.h"
 
 #include "llvm/ADT/STLExtras.h"
diff --git a/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp b/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp
index 110d402436ee..1b6a3e54d95c 100644
--- a/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp
+++ b/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "DirectoryScanner.h"
+#include "../DirectoryScanner.h"
 #include "clang/DirectoryWatcher/DirectoryWatcher.h"
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/Support/ConvertUTF.h"
diff --git a/clang/lib/Driver/ToolChains/AMDGPUOpenMP.cpp b/clang/lib/Driver/ToolChains/AMDGPUOpenMP.cpp
index 3f0b3f2d86b3..37625b9d6b1a 100644
--- a/clang/lib/Driver/ToolChains/AMDGPUOpenMP.cpp
+++ b/clang/lib/Driver/ToolChains/AMDGPUOpenMP.cpp
@@ -9,7 +9,7 @@
 #include "AMDGPUOpenMP.h"
 #include "AMDGPU.h"
 #include "CommonArgs.h"
-#include "ToolChains/ROCm.h"
+#include "ROCm.h"
 #include "clang/Basic/DiagnosticDriver.h"
 #include "clang/Driver/Compilation.h"
 #include "clang/Driver/Driver.h"
diff --git a/clang/lib/Driver/ToolChains/Arch/CSKY.cpp b/clang/lib/Driver/ToolChains/Arch/CSKY.cpp
index e94ea12f46dc..2b318305a4eb 100644
--- a/clang/lib/Driver/ToolChains/Arch/CSKY.cpp
+++ b/clang/lib/Driver/ToolChains/Arch/CSKY.cpp
@@ -7,7 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "CSKY.h"
-#include "ToolChains/CommonArgs.h"
+#include "../CommonArgs.h"
 #include "clang/Basic/CharInfo.h"
 #include "clang/Driver/Driver.h"
 #include "clang/Driver/DriverDiagnostic.h"
diff --git a/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp b/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp
index 0575a1ebef3a..d558db3e5039 100644
--- a/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp
+++ b/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp
@@ -8,7 +8,7 @@
 
 #include "LoongArch.h"
 #include "../Clang.h"
-#include "ToolChains/CommonArgs.h"
+#include "../CommonArgs.h"
 #include "clang/Basic/DiagnosticDriver.h"
 #include "clang/Driver/Driver.h"
 #include "clang/Driver/DriverDiagnostic.h"
@@ -284,8 +284,8 @@ void loongarch::getLoongArchTargetFeatures(const Driver &D,
                    options::OPT_mno_lamcas, "lamcas");
   AddTargetFeature(Args, Features, options::OPT_mld_seq_sa,
                    options::OPT_mno_ld_seq_sa, "ld-seq-sa");
-  AddTargetFeature(Args, Features, options::OPT_mdiv32,
-                   options::OPT_mno_div32, "div32");
+  AddTargetFeature(Args, Features, options::OPT_mdiv32, options::OPT_mno_div32,
+                   "div32");
   AddTargetFeature(Args, Features, options::OPT_mscq, options::OPT_mno_scq,
                    "scq");
 }
diff --git a/clang/lib/Driver/ToolChains/Arch/M68k.cpp b/clang/lib/Driver/ToolChains/Arch/M68k.cpp
index 963f7a187d63..f71cdbf1cf18 100644
--- a/clang/lib/Driver/ToolChains/Arch/M68k.cpp
+++ b/clang/lib/Driver/ToolChains/Arch/M68k.cpp
@@ -7,7 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "M68k.h"
-#include "ToolChains/CommonArgs.h"
+#include "../CommonArgs.h"
 #include "clang/Driver/Driver.h"
 #include "clang/Driver/DriverDiagnostic.h"
 #include "clang/Driver/Options.h"
diff --git a/clang/lib/Driver/ToolChains/Arch/Mips.cpp b/clang/lib/Driver/ToolChains/Arch/Mips.cpp
index ca0745fc2b32..abdf962157df 100644
--- a/clang/lib/Driver/ToolChains/Arch/Mips.cpp
+++ b/clang/lib/Driver/ToolChains/Arch/Mips.cpp
@@ -7,7 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "Mips.h"
-#include "ToolChains/CommonArgs.h"
+#include "../CommonArgs.h"
 #include "clang/Driver/Driver.h"
 #include "clang/Driver/DriverDiagnostic.h"
 #include "clang/Driver/Options.h"
@@ -232,9 +232,8 @@ void mips::getMIPSTargetFeatures(const Driver &D, const llvm::Triple &Triple,
     NonPIC =
         (O.matches(options::OPT_fno_PIC) || O.matches(options::OPT_fno_pic) ||
          O.matches(options::OPT_fno_PIE) || O.matches(options::OPT_fno_pie));
-    IsPIC =
-        (O.matches(options::OPT_fPIC) || O.matches(options::OPT_fpic) ||
-         O.matches(options::OPT_fPIE) || O.matches(options::OPT_fpie));
+    IsPIC = (O.matches(options::OPT_fPIC) || O.matches(options::OPT_fpic) ||
+             O.matches(options::OPT_fPIE) || O.matches(options::OPT_fpie));
   }
 
   bool UseAbiCalls = false;
diff --git a/clang/lib/Driver/ToolChains/Arch/PPC.cpp b/clang/lib/Driver/ToolChains/Arch/PPC.cpp
index 57baa186a9eb..ad914d4c96eb 100644
--- a/clang/lib/Driver/ToolChains/Arch/PPC.cpp
+++ b/clang/lib/Driver/ToolChains/Arch/PPC.cpp
@@ -7,7 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "PPC.h"
-#include "ToolChains/CommonArgs.h"
+#include "../CommonArgs.h"
 #include "clang/Driver/Driver.h"
 #include "clang/Driver/DriverDiagnostic.h"
 #include "clang/Driver/Options.h"
@@ -74,7 +74,8 @@ void ppc::getPPCTargetFeatures(const Driver &D, const llvm::Triple &Triple,
   }
 }
 
-ppc::ReadGOTPtrMode ppc::getPPCReadGOTPtrMode(const Driver &D, const llvm::Triple &Triple,
+ppc::ReadGOTPtrMode ppc::getPPCReadGOTPtrMode(const Driver &D,
+                                              const llvm::Triple &Triple,
                                               const ArgList &Args) {
   if (Args.getLastArg(options::OPT_msecure_plt))
     return ppc::ReadGOTPtrMode::SecurePlt;
diff --git a/clang/lib/Driver/ToolChains/Arch/RISCV.cpp b/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
index 6935904a24ed..344f8f6834c0 100644
--- a/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
+++ b/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
@@ -8,7 +8,7 @@
 
 #include "RISCV.h"
 #include "../Clang.h"
-#include "ToolChains/CommonArgs.h"
+#include "../CommonArgs.h"
 #include "clang/Basic/CharInfo.h"
 #include "clang/Driver/Driver.h"
 #include "clang/Driver/DriverDiagnostic.h"
@@ -54,8 +54,7 @@ static bool getArchFeatures(const Driver &D, StringRef Arch,
 
 // Get features except standard extension feature
 static void getRISCFeaturesFromMcpu(const Driver &D, const Arg *A,
-                                    const llvm::Triple &Triple,
-                                    StringRef Mcpu,
+                                    const llvm::Triple &Triple, StringRef Mcpu,
                                     std::vector<StringRef> &Features) {
   bool Is64Bit = Triple.isRISCV64();
   if (!llvm::RISCV::parseCPU(Mcpu, Is64Bit)) {
diff --git a/clang/lib/Driver/ToolChains/Arch/X86.cpp b/clang/lib/Driver/ToolChains/Arch/X86.cpp
index 47c2c3e23f9f..2afff722d01a 100644
--- a/clang/lib/Driver/ToolChains/Arch/X86.cpp
+++ b/clang/lib/Driver/ToolChains/Arch/X86.cpp
@@ -7,7 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "X86.h"
-#include "ToolChains/CommonArgs.h"
+#include "../CommonArgs.h"
 #include "clang/Driver/Driver.h"
 #include "clang/Driver/DriverDiagnostic.h"
 #include "clang/Driver/Options.h"
diff --git a/clang/lib/Sema/SemaDeclAttr.cpp b/clang/lib/Sema/SemaDeclAttr.cpp
index f351663c6824..e74ff535aab7 100644
--- a/clang/lib/Sema/SemaDeclAttr.cpp
+++ b/clang/lib/Sema/SemaDeclAttr.cpp
@@ -73,11 +73,7 @@ using namespace clang;
 using namespace sema;
 
 namespace AttributeLangSupport {
-  enum LANG {
-    C,
-    Cpp,
-    ObjC
-  };
+enum LANG { C, Cpp, ObjC };
 } // end namespace AttributeLangSupport
 
 static unsigned getNumAttributeArgs(const ParsedAttr &AL) {
@@ -91,8 +87,9 @@ SourceLocation Sema::getAttrLoc(const ParsedAttr &AL) { return AL.getLoc(); }
 /// that the result will fit into a regular (signed) int. All args have the same
 /// purpose as they do in checkUInt32Argument.
 template <typename AttrInfo>
-static bool checkPositiveIntArgument(Sema &S, const AttrInfo &AI, const Expr *Expr,
-                                     int &Val, unsigned Idx = UINT_MAX) {
+static bool checkPositiveIntArgument(Sema &S, const AttrInfo &AI,
+                                     const Expr *Expr, int &Val,
+                                     unsigned Idx = UINT_MAX) {
   uint32_t UVal;
   if (!S.checkUInt32Argument(AI, Expr, UVal, Idx))
     return false;
@@ -163,10 +160,9 @@ static bool isIntOrBool(Expr *Exp) {
   return QT->isBooleanType() || QT->isIntegerType();
 }
 
-
 // Check to see if the type is a smart pointer of some kind.  We assume
 // it's a smart pointer if it defines both operator-> and operator*.
-static bool threadSafetyCheckIsSmartPointer(Sema &S, const RecordType* RT) {
+static bool threadSafetyCheckIsSmartPointer(Sema &S, const RecordType *RT) {
   auto IsOverloadedOperatorPresent = [&S](const RecordDecl *Record,
                                           OverloadedOperatorKind Op) {
     DeclContextLookupResult Result =
@@ -399,10 +395,10 @@ static void checkAttrArgsAreCapabilityObjs(Sema &S, Decl *D,
     const RecordType *RT = getRecordType(ArgTy);
 
     // Now check if we index into a record type function param.
-    if(!RT && ParamIdxOk) {
+    if (!RT && ParamIdxOk) {
       const auto *FD = dyn_cast<FunctionDecl>(D);
       const auto *IL = dyn_cast<IntegerLiteral>(ArgExp);
-      if(FD && IL) {
+      if (FD && IL) {
         unsigned int NumParams = FD->getNumParams();
         llvm::APInt ArgValue = IL->getValue();
         uint64_t ParamIdxFromOne = ArgValue.getZExtValue();
@@ -639,7 +635,7 @@ static bool checkTryLockFunAttrCommon(Sema &S, Decl *D, const ParsedAttr &AL,
 
 static void handleSharedTrylockFunctionAttr(Sema &S, Decl *D,
                                             const ParsedAttr &AL) {
-  SmallVector<Expr*, 2> Args;
+  SmallVector<Expr *, 2> Args;
   if (!checkTryLockFunAttrCommon(S, D, AL, Args))
     return;
 
@@ -649,7 +645,7 @@ static void handleSharedTrylockFunctionAttr(Sema &S, Decl *D,
 
 static void handleExclusiveTrylockFunctionAttr(Sema &S, Decl *D,
                                                const ParsedAttr &AL) {
-  SmallVector<Expr*, 2> Args;
+  SmallVector<Expr *, 2> Args;
   if (!checkTryLockFunAttrCommon(S, D, AL, Args))
     return;
 
@@ -659,7 +655,7 @@ static void handleExclusiveTrylockFunctionAttr(Sema &S, Decl *D,
 
 static void handleLockReturnedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   // check that the argument is lockable object
-  SmallVector<Expr*, 1> Args;
+  SmallVector<Expr *, 1> Args;
   checkAttrArgsAreCapabilityObjs(S, D, AL, Args);
   unsigned Size = Args.size();
   if (Size == 0)
@@ -677,7 +673,7 @@ static void handleLocksExcludedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
     return;
 
   // check that all arguments are lockable objects
-  SmallVector<Expr*, 1> Args;
+  SmallVector<Expr *, 1> Args;
   checkAttrArgsAreCapabilityObjs(S, D, AL, Args);
   unsigned Size = Args.size();
   if (Size == 0)
@@ -791,7 +787,7 @@ public:
     return true;
   }
 };
-}
+} // namespace
 
 static void handleDiagnoseAsBuiltinAttr(Sema &S, Decl *D,
                                         const ParsedAttr &AL) {
@@ -1002,8 +998,8 @@ static void handleConsumableAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
     IdentifierLoc *IL = AL.getArgAsIdent(0);
     if (!ConsumableAttr::ConvertStrToConsumedState(IL->Ident->getName(),
                                                    DefaultState)) {
-      S.Diag(IL->Loc, diag::warn_attribute_type_not_supported) << AL
-                                                               << IL->Ident;
+      S.Diag(IL->Loc, diag::warn_attribute_type_not_supported)
+          << AL << IL->Ident;
       return;
     }
   } else {
@@ -1087,10 +1083,10 @@ static void handleParamTypestateAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   // FIXME: This check is currently being done in the analysis.  It can be
   //        enabled here only after the parser propagates attributes at
   //        template specialization definition, not declaration.
-  //QualType ReturnType = cast<ParmVarDecl>(D)->getType();
-  //const CXXRecordDecl *RD = ReturnType->getAsCXXRecordDecl();
+  // QualType ReturnType = cast<ParmVarDecl>(D)->getType();
+  // const CXXRecordDecl *RD = ReturnType->getAsCXXRecordDecl();
   //
-  //if (!RD || !RD->hasAttr<ConsumableAttr>()) {
+  // if (!RD || !RD->hasAttr<ConsumableAttr>()) {
   //    S.Diag(AL.getLoc(), diag::warn_return_state_for_unconsumable_type) <<
   //      ReturnType.getAsString();
   //    return;
@@ -1106,8 +1102,8 @@ static void handleReturnTypestateAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
     IdentifierLoc *IL = AL.getArgAsIdent(0);
     if (!ReturnTypestateAttr::ConvertStrToConsumedState(IL->Ident->getName(),
                                                         ReturnState)) {
-      S.Diag(IL->Loc, diag::warn_attribute_type_not_supported) << AL
-                                                               << IL->Ident;
+      S.Diag(IL->Loc, diag::warn_attribute_type_not_supported)
+          << AL << IL->Ident;
       return;
     }
   } else {
@@ -1153,8 +1149,8 @@ static void handleSetTypestateAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
     IdentifierLoc *Ident = AL.getArgAsIdent(0);
     StringRef Param = Ident->Ident->getName();
     if (!SetTypestateAttr::ConvertStrToConsumedState(Param, NewState)) {
-      S.Diag(Ident->Loc, diag::warn_attribute_type_not_supported) << AL
-                                                                  << Param;
+      S.Diag(Ident->Loc, diag::warn_attribute_type_not_supported)
+          << AL << Param;
       return;
     }
   } else {
@@ -1175,8 +1171,8 @@ static void handleTestTypestateAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
     IdentifierLoc *Ident = AL.getArgAsIdent(0);
     StringRef Param = Ident->Ident->getName();
     if (!TestTypestateAttr::ConvertStrToConsumedState(Param, TestState)) {
-      S.Diag(Ident->Loc, diag::warn_attribute_type_not_supported) << AL
-                                                                  << Param;
+      S.Diag(Ident->Loc, diag::warn_attribute_type_not_supported)
+          << AL << Param;
       return;
     }
   } else {
@@ -1197,10 +1193,10 @@ static void handlePackedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   if (auto *TD = dyn_cast<TagDecl>(D))
     TD->addAttr(::new (S.Context) PackedAttr(S.Context, AL));
   else if (auto *FD = dyn_cast<FieldDecl>(D)) {
-    bool BitfieldByteAligned = (!FD->getType()->isDependentType() &&
-                                !FD->getType()->isIncompleteType() &&
-                                FD->isBitField() &&
-                                S.Context.getTypeAlign(FD->getType()) <= 8);
+    bool BitfieldByteAligned =
+        (!FD->getType()->isDependentType() &&
+         !FD->getType()->isIncompleteType() && FD->isBitField() &&
+         S.Context.getTypeAlign(FD->getType()) <= 8);
 
     if (S.getASTContext().getTargetInfo().getTriple().isPS()) {
       if (BitfieldByteAligned)
@@ -1358,7 +1354,7 @@ static void handleNonNullAttrParameter(Sema &S, ParmVarDecl *D,
       handleNonNullAttr(S, D, AL);
     } else {
       S.Diag(AL.getLoc(), diag::warn_attribute_nonnull_parm_no_args)
-        << D->getSourceRange();
+          << D->getSourceRange();
     }
     return;
   }
@@ -1425,18 +1421,17 @@ void Sema::AddAssumeAlignedAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E,
     if (!(I = E->getIntegerConstantExpr(Context))) {
       if (OE)
         Diag(AttrLoc, diag::err_attribute_argument_n_type)
-          << &TmpAttr << 1 << AANT_ArgumentIntegerConstant
-          << E->getSourceRange();
+            << &TmpAttr << 1 << AANT_ArgumentIntegerConstant
+            << E->getSourceRange();
       else
         Diag(AttrLoc, diag::err_attribute_argument_type)
-          << &TmpAttr << AANT_ArgumentIntegerConstant
-          << E->getSourceRange();
+            << &TmpAttr << AANT_ArgumentIntegerConstant << E->getSourceRange();
       return;
     }
 
     if (!I->isPowerOf2()) {
       Diag(AttrLoc, diag::err_alignment_not_power_of_two)
-        << E->getSourceRange();
+          << E->getSourceRange();
       return;
     }
 
@@ -1557,21 +1552,21 @@ static void handleOwnershipAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
 
     // Is the function argument a pointer type?
     QualType T = getFunctionOrMethodParamType(D, Idx.getASTIndex());
-    int Err = -1;  // No error
+    int Err = -1; // No error
     switch (K) {
-      case OwnershipAttr::Takes:
-      case OwnershipAttr::Holds:
-        if (!T->isAnyPointerType() && !T->isBlockPointerType())
-          Err = 0;
-        break;
-      case OwnershipAttr::Returns:
-        if (!T->isIntegerType())
-          Err = 1;
-        break;
+    case OwnershipAttr::Takes:
+    case OwnershipAttr::Holds:
+      if (!T->isAnyPointerType() && !T->isBlockPointerType())
+        Err = 0;
+      break;
+    case OwnershipAttr::Returns:
+      if (!T->isIntegerType())
+        Err = 1;
+      break;
     }
     if (-1 != Err) {
-      S.Diag(AL.getLoc(), diag::err_ownership_type) << AL << Err
-                                                    << Ex->getSourceRange();
+      S.Diag(AL.getLoc(), diag::err_ownership_type)
+          << AL << Err << Ex->getSourceRange();
       return;
     }
 
@@ -1580,11 +1575,11 @@ static void handleOwnershipAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
       // Cannot have two ownership attributes of different kinds for the same
       // index.
       if (I->getOwnKind() != K && llvm::is_contained(I->args(), Idx)) {
-          S.Diag(AL.getLoc(), diag::err_attributes_are_not_compatible)
-              << AL << I
-              << (AL.isRegularKeywordAttribute() ||
-                  I->isRegularKeywordAttribute());
-          return;
+        S.Diag(AL.getLoc(), diag::err_attributes_are_not_compatible)
+            << AL << I
+            << (AL.isRegularKeywordAttribute() ||
+                I->isRegularKeywordAttribute());
+        return;
       } else if (K == OwnershipAttr::Returns &&
                  I->getOwnKind() == OwnershipAttr::Returns) {
         // A returns attribute conflicts with any other returns attribute using
@@ -1768,8 +1763,8 @@ static void handleTLSModelAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
     return;
 
   // Check that the value.
-  if (Model != "global-dynamic" && Model != "local-dynamic"
-      && Model != "initial-exec" && Model != "local-exec") {
+  if (Model != "global-dynamic" && Model != "local-dynamic" &&
+      Model != "initial-exec" && Model != "local-exec") {
     S.Diag(LiteralLoc, diag::err_attr_tlsmodel_arg);
     return;
   }
@@ -1894,7 +1889,8 @@ static void handleNakedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
 }
 
 static void handleNoReturnAttr(Sema &S, Decl *D, const ParsedAttr &Attrs) {
-  if (hasDeclarator(D)) return;
+  if (hasDeclarator(D))
+    return;
 
   if (!isa<ObjCMethodDecl>(D)) {
     S.Diag(Attrs.getLoc(), diag::warn_attribute_wrong_decl_type)
@@ -2032,8 +2028,7 @@ static void handleDependencyAttr(Sema &S, Scope *Scope, Decl *D,
     // [[carries_dependency]] can only be applied to a parameter if it is a
     // parameter of a function declaration or lambda.
     if (!(Scope->getFlags() & clang::Scope::FunctionDeclarationScope)) {
-      S.Diag(AL.getLoc(),
-             diag::err_carries_dependency_param_not_function_decl);
+      S.Diag(AL.getLoc(), diag::err_carries_dependency_param_not_function_decl);
       return;
     }
   }
@@ -2089,8 +2084,8 @@ static bool checkAvailabilityAttr(Sema &S, SourceRange Range,
                                   VersionTuple Introduced,
                                   VersionTuple Deprecated,
                                   VersionTuple Obsoleted) {
-  StringRef PlatformName
-    = AvailabilityAttr::getPrettyPlatformName(Platform->getName());
+  StringRef PlatformName =
+      AvailabilityAttr::getPrettyPlatformName(Platform->getName());
   if (PlatformName.empty())
     PlatformName = Platform->getName();
 
@@ -2099,24 +2094,22 @@ static bool checkAvailabilityAttr(Sema &S, SourceRange Range,
   if (!Introduced.empty() && !Deprecated.empty() &&
       !(Introduced <= Deprecated)) {
     S.Diag(Range.getBegin(), diag::warn_availability_version_ordering)
-      << 1 << PlatformName << Deprecated.getAsString()
-      << 0 << Introduced.getAsString();
+        << 1 << PlatformName << Deprecated.getAsString() << 0
+        << Introduced.getAsString();
     return true;
   }
 
-  if (!Introduced.empty() && !Obsoleted.empty() &&
-      !(Introduced <= Obsoleted)) {
+  if (!Introduced.empty() && !Obsoleted.empty() && !(Introduced <= Obsoleted)) {
     S.Diag(Range.getBegin(), diag::warn_availability_version_ordering)
-      << 2 << PlatformName << Obsoleted.getAsString()
-      << 0 << Introduced.getAsString();
+        << 2 << PlatformName << Obsoleted.getAsString() << 0
+        << Introduced.getAsString();
     return true;
   }
 
-  if (!Deprecated.empty() && !Obsoleted.empty() &&
-      !(Deprecated <= Obsoleted)) {
+  if (!Deprecated.empty() && !Obsoleted.empty() && !(Deprecated <= Obsoleted)) {
     S.Diag(Range.getBegin(), diag::warn_availability_version_ordering)
-      << 2 << PlatformName << Obsoleted.getAsString()
-      << 1 << Deprecated.getAsString();
+        << 2 << PlatformName << Obsoleted.getAsString() << 1
+        << Deprecated.getAsString();
     return true;
   }
 
@@ -2220,7 +2213,8 @@ AvailabilityAttr *Sema::mergeAvailabilityAttr(
             Which = 0;
             FirstVersion = OldIntroduced;
             SecondVersion = Introduced;
-          } else if (!versionsMatch(Deprecated, OldDeprecated, OverrideOrImpl)) {
+          } else if (!versionsMatch(Deprecated, OldDeprecated,
+                                    OverrideOrImpl)) {
             Which = 1;
             FirstVersion = Deprecated;
             SecondVersion = OldDeprecated;
@@ -2233,8 +2227,8 @@ AvailabilityAttr *Sema::mergeAvailabilityAttr(
           if (Which == -1) {
             Diag(OldAA->getLocation(),
                  diag::warn_mismatched_availability_override_unavail)
-              << AvailabilityAttr::getPrettyPlatformName(Platform->getName())
-              << (AMK == AMK_Override);
+                << AvailabilityAttr::getPrettyPlatformName(Platform->getName())
+                << (AMK == AMK_Override);
           } else if (Which != 1 && AMK == AMK_OptionalProtocolImplementation) {
             // Allow different 'introduced' / 'obsoleted' availability versions
             // on a method that implements an optional protocol requirement. It
@@ -2246,10 +2240,10 @@ AvailabilityAttr *Sema::mergeAvailabilityAttr(
           } else {
             Diag(OldAA->getLocation(),
                  diag::warn_mismatched_availability_override)
-              << Which
-              << AvailabilityAttr::getPrettyPlatformName(Platform->getName())
-              << FirstVersion.getAsString() << SecondVersion.getAsString()
-              << (AMK == AMK_Override);
+                << Which
+                << AvailabilityAttr::getPrettyPlatformName(Platform->getName())
+                << FirstVersion.getAsString() << SecondVersion.getAsString()
+                << (AMK == AMK_Override);
           }
           if (AMK == AMK_Override)
             Diag(CI.getLoc(), diag::note_overridden_method);
@@ -2291,10 +2285,8 @@ AvailabilityAttr *Sema::mergeAvailabilityAttr(
     }
   }
 
-  if (FoundAny &&
-      MergedIntroduced == Introduced &&
-      MergedDeprecated == Deprecated &&
-      MergedObsoleted == Obsoleted)
+  if (FoundAny && MergedIntroduced == Introduced &&
+      MergedDeprecated == Deprecated && MergedObsoleted == Obsoleted)
     return nullptr;
 
   // Only create a new attribute if !OverrideOrImpl, but we want to do
@@ -2326,7 +2318,7 @@ static void handleAvailabilityAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   IdentifierInfo *II = Platform->Ident;
   if (AvailabilityAttr::getPrettyPlatformName(II->getName()).empty())
     S.Diag(Platform->Loc, diag::warn_availability_unknown_platform)
-      << Platform->Ident;
+        << Platform->Ident;
 
   auto *ND = dyn_cast<NamedDecl>(D);
   if (!ND) // We warned about this already, so just return.
@@ -2646,8 +2638,8 @@ static void handleVisibilityAttr(Sema &S, Decl *D, const ParsedAttr &AL,
 
   VisibilityAttr::VisibilityType type;
   if (!VisibilityAttr::ConvertStrToVisibilityType(TypeStr, type)) {
-    S.Diag(LiteralLoc, diag::warn_attribute_type_not_supported) << AL
-                                                                << TypeStr;
+    S.Diag(LiteralLoc, diag::warn_attribute_type_not_supported)
+        << AL << TypeStr;
     return;
   }
 
@@ -2683,7 +2675,7 @@ static void handleSentinelAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
 
     if (Idx->isSigned() && Idx->isNegative()) {
       S.Diag(AL.getLoc(), diag::err_attribute_sentinel_less_than_zero)
-        << E->getSourceRange();
+          << E->getSourceRange();
       return;
     }
 
@@ -2705,7 +2697,7 @@ static void handleSentinelAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
       // FIXME: This error message could be improved, it would be nice
       // to say what the bounds actually are.
       S.Diag(AL.getLoc(), diag::err_attribute_sentinel_not_zero_or_one)
-        << E->getSourceRange();
+          << E->getSourceRange();
       return;
     }
   }
@@ -2818,7 +2810,7 @@ static void handleWeakImportAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   if (!D->canBeWeakImported(isDef)) {
     if (isDef)
       S.Diag(AL.getLoc(), diag::warn_attribute_invalid_on_definition)
-        << "weak_import";
+          << "weak_import";
     else if (isa<ObjCPropertyDecl>(D) || isa<ObjCMethodDecl>(D) ||
              (S.Context.getTargetInfo().getTriple().isOSDarwin() &&
               (isa<ObjCInterfaceDecl>(D) || isa<EnumDecl>(D)))) {
@@ -2850,9 +2842,9 @@ static void handleWorkGroupSize(Sema &S, Decl *D, const ParsedAttr &AL) {
   }
 
   WorkGroupAttr *Existing = D->getAttr<WorkGroupAttr>();
-  if (Existing && !(Existing->getXDim() == WGSize[0] &&
-                    Existing->getYDim() == WGSize[1] &&
-                    Existing->getZDim() == WGSize[2]))
+  if (Existing &&
+      !(Existing->getXDim() == WGSize[0] && Existing->getYDim() == WGSize[1] &&
+        Existing->getZDim() == WGSize[2]))
     S.Diag(AL.getLoc(), diag::warn_duplicate_attribute) << AL;
 
   D->addAttr(::new (S.Context)
@@ -2899,7 +2891,7 @@ SectionAttr *Sema::mergeSectionAttr(Decl *D, const AttributeCommonInfo &CI,
     if (ExistingAttr->getName() == Name)
       return nullptr;
     Diag(ExistingAttr->getLocation(), diag::warn_mismatched_section)
-         << 1 /*section*/;
+        << 1 /*section*/;
     Diag(CI.getLoc(), diag::note_previous_attribute);
     return nullptr;
   }
@@ -2990,7 +2982,7 @@ CodeSegAttr *Sema::mergeCodeSegAttr(Decl *D, const AttributeCommonInfo &CI,
     if (ExistingAttr->getName() == Name)
       return nullptr;
     Diag(ExistingAttr->getLocation(), diag::warn_mismatched_section)
-         << 0 /*codeseg*/;
+        << 0 /*codeseg*/;
     Diag(CI.getLoc(), diag::note_previous_attribute);
     return nullptr;
   }
@@ -3006,10 +2998,9 @@ static void handleCodeSegAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
     return;
   if (const auto *ExistingAttr = D->getAttr<CodeSegAttr>()) {
     if (!ExistingAttr->isImplicit()) {
-      S.Diag(AL.getLoc(),
-             ExistingAttr->getName() == Str
-             ? diag::warn_duplicate_codeseg_attribute
-             : diag::err_conflicting_codeseg_attribute);
+      S.Diag(AL.getLoc(), ExistingAttr->getName() == Str
+                              ? diag::warn_duplicate_codeseg_attribute
+                              : diag::err_conflicting_codeseg_attribute);
       return;
     }
     D->dropAttr<CodeSegAttr>();
@@ -3420,8 +3411,8 @@ static void handleCleanupAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
     FD = dyn_cast<FunctionDecl>(DRE->getDecl());
     NI = DRE->getNameInfo();
     if (!FD) {
-      S.Diag(Loc, diag::err_attribute_cleanup_arg_not_function) << 1
-        << NI.getName();
+      S.Diag(Loc, diag::err_attribute_cleanup_arg_not_function)
+          << 1 << NI.getName();
       return;
     }
   } else if (auto *ULE = dyn_cast<UnresolvedLookupExpr>(E)) {
@@ -3430,8 +3421,8 @@ static void handleCleanupAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
     FD = S.ResolveSingleFunctionTemplateSpecialization(ULE, true);
     NI = ULE->getNameInfo();
     if (!FD) {
-      S.Diag(Loc, diag::err_attribute_cleanup_arg_not_function) << 2
-        << NI.getName();
+      S.Diag(Loc, diag::err_attribute_cleanup_arg_not_function)
+          << 2 << NI.getName();
       if (ULE->getType() == S.Context.OverloadTy)
         S.NoteAllOverloadCandidates(ULE);
       return;
@@ -3443,7 +3434,7 @@ static void handleCleanupAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
 
   if (FD->getNumParams() != 1) {
     S.Diag(Loc, diag::err_attribute_cleanup_func_must_take_one_arg)
-      << NI.getName();
+        << NI.getName();
     return;
   }
 
@@ -3451,10 +3442,10 @@ static void handleCleanupAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   // If this ever proves to be a problem it should be easy to fix.
   QualType Ty = S.Context.getPointerType(cast<VarDecl>(D)->getType());
   QualType ParamTy = FD->getParamDecl(0)->getType();
-  if (S.CheckAssignmentConstraints(FD->getParamDecl(0)->getLocation(),
-                                   ParamTy, Ty) != Sema::Compatible) {
+  if (S.CheckAssignmentConstraints(FD->getParamDecl(0)->getLocation(), ParamTy,
+                                   Ty) != Sema::Compatible) {
     S.Diag(Loc, diag::err_attribute_cleanup_func_arg_incompatible_type)
-      << NI.getName() << ParamTy << Ty;
+        << NI.getName() << ParamTy << Ty;
     return;
   }
   VarDecl *VD = cast<VarDecl>(D);
@@ -3652,8 +3643,7 @@ FormatAttr *Sema::mergeFormatAttr(Decl *D, const AttributeCommonInfo &CI,
                                   int FirstArg) {
   // Check whether we already have an equivalent format attribute.
   for (auto *F : D->specific_attrs<FormatAttr>()) {
-    if (F->getType() == Format &&
-        F->getFormatIdx() == FormatIdx &&
+    if (F->getType() == Format && F->getFormatIdx() == FormatIdx &&
         F->getFirstArg() == FirstArg) {
       // If we don't have a valid location for this attribute, adopt the
       // location.
@@ -3719,7 +3709,7 @@ static void handleFormatAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
     if (ArgIdx == 0) {
       S.Diag(AL.getLoc(),
              diag::err_format_attribute_implicit_this_format_string)
-        << IdxExpr->getSourceRange();
+          << IdxExpr->getSourceRange();
       return;
     }
     ArgIdx--;
@@ -3732,7 +3722,8 @@ static void handleFormatAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
       (!Ty->isPointerType() ||
        !Ty->castAs<PointerType>()->getPointeeType()->isCharType())) {
     S.Diag(AL.getLoc(), diag::err_format_attribute_not)
-      << IdxExpr->getSourceRange() << getFunctionOrMethodParamRange(D, ArgIdx);
+        << IdxExpr->getSourceRange()
+        << getFunctionOrMethodParamRange(D, ArgIdx);
     return;
   }
 
@@ -4076,7 +4067,7 @@ static void handleTransparentUnionAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   }
 
   RecordDecl::field_iterator Field = RD->field_begin(),
-                          FieldEnd = RD->field_end();
+                             FieldEnd = RD->field_end();
   if (Field == FieldEnd) {
     S.Diag(AL.getLoc(), diag::warn_transparent_union_attribute_zero_fields);
     return;
@@ -4087,7 +4078,7 @@ static void handleTransparentUnionAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   if (FirstType->hasFloatingRepresentation() || FirstType->isVectorType()) {
     S.Diag(FirstField->getLocation(),
            diag::warn_transparent_union_attribute_floating)
-      << FirstType->isVectorType() << FirstType;
+        << FirstType->isVectorType() << FirstType;
     return;
   }
 
@@ -4150,7 +4141,7 @@ void Sema::AddAlignValueAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E) {
   if (!T->isDependentType() && !T->isAnyPointerType() &&
       !T->isReferenceType() && !T->isMemberPointerType()) {
     Diag(AttrLoc, diag::warn_attribute_pointer_or_reference_only)
-      << &TmpAttr << T << D->getSourceRange();
+        << &TmpAttr << T << D->getSourceRange();
     return;
   }
 
@@ -4163,7 +4154,7 @@ void Sema::AddAlignValueAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E) {
 
     if (!Alignment.isPowerOf2()) {
       Diag(AttrLoc, diag::err_alignment_not_power_of_two)
-        << E->getSourceRange();
+          << E->getSourceRange();
       return;
     }
 
@@ -4321,7 +4312,7 @@ void Sema::AddAlignedAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E,
   if (!(TmpAttr.isAlignas() && !Alignment)) {
     if (!llvm::isPowerOf2_64(AlignVal)) {
       Diag(AttrLoc, diag::err_alignment_not_power_of_two)
-        << E->getSourceRange();
+          << E->getSourceRange();
       return;
     }
   }
@@ -4443,7 +4434,7 @@ void Sema::CheckAlignasUnderalignment(Decl *D) {
     CharUnits NaturalAlign = Context.getTypeAlignInChars(UnderlyingTy);
     if (NaturalAlign > RequestedAlign)
       Diag(AlignasAttr->getLocation(), diag::err_alignas_underaligned)
-        << DiagTy << (unsigned)NaturalAlign.getQuantity();
+          << DiagTy << (unsigned)NaturalAlign.getQuantity();
   }
 }
 
@@ -4937,7 +4928,8 @@ static void handleGNUInlineAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
 }
 
 static void handleCallConvAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
-  if (hasDeclarator(D)) return;
+  if (hasDeclarator(D))
+    return;
 
   // Diagnostic is emitted elsewhere: here we store the (valid) AL
   // in the Decl node for syntactic reasoning, e.g., pretty-printing.
@@ -5145,7 +5137,7 @@ bool Sema::CheckCallingConvAttr(const ParsedAttr &Attrs, CallingConv &CC,
     return true;
 
   if (Attrs.hasProcessingCache()) {
-    CC = (CallingConv) Attrs.getProcessingCache();
+    CC = (CallingConv)Attrs.getProcessingCache();
     return false;
   }
 
@@ -5194,12 +5186,11 @@ bool Sema::CheckCallingConvAttr(const ParsedAttr &Attrs, CallingConv &CC,
     CC = CC_X86RegCall;
     break;
   case ParsedAttr::AT_MSABI:
-    CC = Context.getTargetInfo().getTriple().isOSWindows() ? CC_C :
-                                                             CC_Win64;
+    CC = Context.getTargetInfo().getTriple().isOSWindows() ? CC_C : CC_Win64;
     break;
   case ParsedAttr::AT_SysVABI:
-    CC = Context.getTargetInfo().getTriple().isOSWindows() ? CC_X86_64SysV :
-                                                             CC_C;
+    CC = Context.getTargetInfo().getTriple().isOSWindows() ? CC_X86_64SysV
+                                                           : CC_C;
     break;
   case ParsedAttr::AT_Pcs: {
     StringRef StrRef;
@@ -5237,7 +5228,8 @@ bool Sema::CheckCallingConvAttr(const ParsedAttr &Attrs, CallingConv &CC,
   case ParsedAttr::AT_RISCVVectorCC:
     CC = CC_RISCVVectorCall;
     break;
-  default: llvm_unreachable("unexpected attribute kind");
+  default:
+    llvm_unreachable("unexpected attribute kind");
   }
 
   TargetInfo::CallingConvCheckResult A = TargetInfo::CCCR_OK;
@@ -5309,7 +5301,7 @@ bool Sema::CheckCallingConvAttr(const ParsedAttr &Attrs, CallingConv &CC,
   }
   }
 
-  Attrs.setProcessingCache((unsigned) CC);
+  Attrs.setProcessingCache((unsigned)CC);
   return false;
 }
 
@@ -5331,7 +5323,7 @@ bool Sema::CheckRegparmAttr(const ParsedAttr &AL, unsigned &numParams) {
 
   if (Context.getTargetInfo().getRegParmMax() == 0) {
     Diag(AL.getLoc(), diag::err_attribute_regparm_wrong_platform)
-      << NumParamsExpr->getSourceRange();
+        << NumParamsExpr->getSourceRange();
     AL.setInvalid();
     return true;
   }
@@ -5339,7 +5331,8 @@ bool Sema::CheckRegparmAttr(const ParsedAttr &AL, unsigned &numParams) {
   numParams = NP;
   if (numParams > Context.getTargetInfo().getRegParmMax()) {
     Diag(AL.getLoc(), diag::err_attribute_regparm_invalid_number)
-      << Context.getTargetInfo().getRegParmMax() << NumParamsExpr->getSourceRange();
+        << Context.getTargetInfo().getRegParmMax()
+        << NumParamsExpr->getSourceRange();
     AL.setInvalid();
     return true;
   }
@@ -5892,10 +5885,10 @@ static void handleDLLAttr(Sema &S, Decl *D, const ParsedAttr &A) {
     D->addAttr(NewAttr);
 }
 
-MSInheritanceAttr *
-Sema::mergeMSInheritanceAttr(Decl *D, const AttributeCommonInfo &CI,
-                             bool BestCase,
-                             MSInheritanceModel Model) {
+MSInheritanceAttr *Sema::mergeMSInheritanceAttr(Decl *D,
+                                                const AttributeCommonInfo &CI,
+                                                bool BestCase,
+                                                MSInheritanceModel Model) {
   if (MSInheritanceAttr *IA = D->getAttr<MSInheritanceAttr>()) {
     if (IA->getInheritanceModel() == Model)
       return nullptr;
@@ -5946,7 +5939,7 @@ static void handleCapabilityAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
 }
 
 static void handleAssertCapabilityAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
-  SmallVector<Expr*, 1> Args;
+  SmallVector<Expr *, 1> Args;
   if (!checkLockFunAttrCommon(S, D, AL, Args))
     return;
 
@@ -5960,7 +5953,7 @@ static void handleAcquireCapabilityAttr(Sema &S, Decl *D,
       ParmDecl && !checkFunParamsAreScopedLockable(S, ParmDecl, AL))
     return;
 
-  SmallVector<Expr*, 1> Args;
+  SmallVector<Expr *, 1> Args;
   if (!checkLockFunAttrCommon(S, D, AL, Args))
     return;
 
@@ -5970,7 +5963,7 @@ static void handleAcquireCapabilityAttr(Sema &S, Decl *D,
 
 static void handleTryAcquireCapabilityAttr(Sema &S, Decl *D,
                                            const ParsedAttr &AL) {
-  SmallVector<Expr*, 2> Args;
+  SmallVector<Expr *, 2> Args;
   if (!checkTryLockFunAttrCommon(S, D, AL, Args))
     return;
 
@@ -6001,7 +5994,7 @@ static void handleRequiresCapabilityAttr(Sema &S, Decl *D,
     return;
 
   // check that all arguments are lockable objects
-  SmallVector<Expr*, 1> Args;
+  SmallVector<Expr *, 1> Args;
   checkAttrArgsAreCapabilityObjs(S, D, AL, Args);
   if (Args.empty())
     return;
@@ -6075,7 +6068,8 @@ static void handleNoSanitizeAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
             SanitizerMask() &&
         SanitizerName != "coverage")
       S.Diag(LiteralLoc, diag::warn_unknown_sanitizer_ignored) << SanitizerName;
-    else if (isGlobalVar(D) && !isSanitizerAttributeAllowedOnGlobals(SanitizerName))
+    else if (isGlobalVar(D) &&
+             !isSanitizerAttributeAllowedOnGlobals(SanitizerName))
       S.Diag(D->getLocation(), diag::warn_attribute_type_not_supported_global)
           << AL << SanitizerName;
     Sanitizers.push_back(SanitizerName);
@@ -6290,7 +6284,7 @@ static void handleAcquireHandleAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   D->addAttr(AcquireHandleAttr::Create(S.Context, Argument, AL));
 }
 
-template<typename Attr>
+template <typename Attr>
 static void handleHandleAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   StringRef Argument;
   if (!S.checkStringLiteralArgumentAttr(AL, 0, Argument))
@@ -6298,7 +6292,7 @@ static void handleHandleAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   D->addAttr(Attr::Create(S.Context, Argument, AL));
 }
 
-template<typename Attr>
+template <typename Attr>
 static void handleUnsafeBufferUsage(Sema &S, Decl *D, const ParsedAttr &AL) {
   D->addAttr(Attr::Create(S.Context, AL));
 }
@@ -6322,14 +6316,11 @@ static void handleCFGuardAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   D->addAttr(::new (S.Context) CFGuardAttr(S.Context, AL, Arg));
 }
 
-
 template <typename AttrTy>
 static const AttrTy *findEnforceTCBAttrByName(Decl *D, StringRef Name) {
   auto Attrs = D->specific_attrs<AttrTy>();
-  auto I = llvm::find_if(Attrs,
-                         [Name](const AttrTy *A) {
-                           return A->getTCBName() == Name;
-                         });
+  auto I = llvm::find_if(
+      Attrs, [Name](const AttrTy *A) { return A->getTCBName() == Name; });
   return I == Attrs.end() ? nullptr : *I;
 }
 
@@ -6341,12 +6332,12 @@ static void handleEnforceTCBAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
 
   // A function cannot be have both regular and leaf membership in the same TCB.
   if (const ConflictingAttrTy *ConflictingAttr =
-      findEnforceTCBAttrByName<ConflictingAttrTy>(D, Argument)) {
+          findEnforceTCBAttrByName<ConflictingAttrTy>(D, Argument)) {
     // We could attach a note to the other attribute but in this case
     // there's no need given how the two are very close to each other.
     S.Diag(AL.getLoc(), diag::err_tcb_conflicting_attributes)
-      << AL.getAttrName()->getName() << ConflictingAttr->getAttrName()->getName()
-      << Argument;
+        << AL.getAttrName()->getName()
+        << ConflictingAttr->getAttrName()->getName() << Argument;
 
     // Error recovery: drop the non-leaf attribute so that to suppress
     // all future warnings caused by erroneous attributes. The leaf attribute
@@ -6363,10 +6354,10 @@ static AttrTy *mergeEnforceTCBAttrImpl(Sema &S, Decl *D, const AttrTy &AL) {
   // Check if the new redeclaration has different leaf-ness in the same TCB.
   StringRef TCBName = AL.getTCBName();
   if (const ConflictingAttrTy *ConflictingAttr =
-      findEnforceTCBAttrByName<ConflictingAttrTy>(D, TCBName)) {
+          findEnforceTCBAttrByName<ConflictingAttrTy>(D, TCBName)) {
     S.Diag(ConflictingAttr->getLoc(), diag::err_tcb_conflicting_attributes)
-      << ConflictingAttr->getAttrName()->getName()
-      << AL.getAttrName()->getName() << TCBName;
+        << ConflictingAttr->getAttrName()->getName()
+        << AL.getAttrName()->getName() << TCBName;
 
     // Add a note so that the user could easily find the conflicting attribute.
     S.Diag(AL.getLoc(), diag::note_conflicting_attribute);
@@ -6377,18 +6368,51 @@ static AttrTy *mergeEnforceTCBAttrImpl(Sema &S, Decl *D, const AttrTy &AL) {
   }
 
   ASTContext &Context = S.getASTContext();
-  return ::new(Context) AttrTy(Context, AL, AL.getTCBName());
+  return ::new (Context) AttrTy(Context, AL, AL.getTCBName());
 }
 
 EnforceTCBAttr *Sema::mergeEnforceTCBAttr(Decl *D, const EnforceTCBAttr &AL) {
-  return mergeEnforceTCBAttrImpl<EnforceTCBAttr, EnforceTCBLeafAttr>(
-      *this, D, AL);
+  return mergeEnforceTCBAttrImpl<EnforceTCBAttr, EnforceTCBLeafAttr>(*this, D,
+                                                                     AL);
+}
+
+EnforceTCBLeafAttr *
+Sema::mergeEnforceTCBLeafAttr(Decl *D, const EnforceTCBLeafAttr &AL) {
+  return mergeEnforceTCBAttrImpl<EnforceTCBLeafAttr, EnforceTCBAttr>(*this, D,
+                                                                     AL);
+}
+
+/// Handle Easy Reflection main 'reflect' attribute.
+static void handleErReflect(Sema &S, Decl *D, const ParsedAttr &AL) {
+  SmallVector<ErReflectAttr::Option, 4> Options;
+
+  for (unsigned I = 0, E = AL.getNumArgs(); I != E; ++I) {
+    StringRef OptStr;
+    if (!S.checkStringLiteralArgumentAttr(AL, I, OptStr))
+      continue;
+
+    ErReflectAttr::Option Option;
+    if (!ErReflectAttr::ConvertStrToOption(OptStr, Option)) {
+      S.Diag(AL.getLoc(), diag::warn_attribute_type_not_supported)
+          << AL << "'" + std::string(OptStr) + "'";
+      continue;
+    }
+
+    Options.push_back(Option);
+  }
+
+  D->addAttr(::new (S.Context)
+                 ErReflectAttr(S.Context, AL, Options.data(), Options.size()));
 }
 
-EnforceTCBLeafAttr *Sema::mergeEnforceTCBLeafAttr(
-    Decl *D, const EnforceTCBLeafAttr &AL) {
-  return mergeEnforceTCBAttrImpl<EnforceTCBLeafAttr, EnforceTCBAttr>(
-      *this, D, AL);
+/// Handle Easy Reflection 'alias' attribute.
+static void handleErAlias(Sema &S, Decl *D, const ParsedAttr &AL) {
+  StringRef Name;
+
+  if (!S.checkStringLiteralArgumentAttr(AL, 0, Name))
+    return;
+
+  D->addAttr(::new (S.Context) ErAliasAttr(S.Context, AL, Name));
 }
 
 static void handleVTablePointerAuthentication(Sema &S, Decl *D,
@@ -6585,7 +6609,8 @@ ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D, const ParsedAttr &AL,
 
   switch (AL.getKind()) {
   default:
-    if (AL.getInfo().handleDeclAttribute(S, D, AL) != ParsedAttrInfo::NotHandled)
+    if (AL.getInfo().handleDeclAttribute(S, D, AL) !=
+        ParsedAttrInfo::NotHandled)
       break;
     if (!AL.isStmtAttr()) {
       assert(AL.isTypeAttr() && "Non-type attribute not handled");
@@ -6762,13 +6787,13 @@ ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D, const ParsedAttr &AL,
     handlePassObjectSizeAttr(S, D, AL);
     break;
   case ParsedAttr::AT_Constructor:
-      handleConstructorAttr(S, D, AL);
+    handleConstructorAttr(S, D, AL);
     break;
   case ParsedAttr::AT_Deprecated:
     handleDeprecatedAttr(S, D, AL);
     break;
   case ParsedAttr::AT_Destructor:
-      handleDestructorAttr(S, D, AL);
+    handleDestructorAttr(S, D, AL);
     break;
   case ParsedAttr::AT_EnableIf:
     handleEnableIfAttr(S, D, AL);
@@ -6972,7 +6997,7 @@ ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D, const ParsedAttr &AL,
     handleVecTypeHint(S, D, AL);
     break;
   case ParsedAttr::AT_InitPriority:
-      handleInitPriorityAttr(S, D, AL);
+    handleInitPriorityAttr(S, D, AL);
     break;
   case ParsedAttr::AT_Packed:
     handlePackedAttr(S, D, AL);
@@ -7410,6 +7435,18 @@ ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D, const ParsedAttr &AL,
   case ParsedAttr::AT_VTablePointerAuthentication:
     handleVTablePointerAuthentication(S, D, AL);
     break;
+
+  case ParsedAttr::AT_ErReflect:
+    handleErReflect(S, D, AL);
+    break;
+
+  case ParsedAttr::AT_ErAlias:
+    handleErAlias(S, D, AL);
+    break;
+
+  case ParsedAttr::AT_ErIgnore:
+    handleSimpleAttribute<ErIgnoreAttr>(S, D, AL);
+    break;
   }
 }
 
@@ -7538,8 +7575,8 @@ static void checkUnusedDeclAttributes(Sema &S, const ParsedAttributesView &A) {
       S.Diag(AL.getLoc(), diag::warn_unknown_attribute_ignored)
           << AL << AL.getRange();
     } else {
-      S.Diag(AL.getLoc(), diag::warn_attribute_not_on_decl) << AL
-                                                            << AL.getRange();
+      S.Diag(AL.getLoc(), diag::warn_attribute_not_on_decl)
+          << AL << AL.getRange();
     }
   }
 }
@@ -7577,7 +7614,7 @@ NamedDecl *Sema::DeclClonePragmaWeak(NamedDecl *ND, const IdentifierInfo *II,
     // a typedef.
     QualType FDTy = FD->getType();
     if (const auto *FT = FDTy->getAs<FunctionProtoType>()) {
-      SmallVector<ParmVarDecl*, 16> Params;
+      SmallVector<ParmVarDecl *, 16> Params;
       for (const auto &AI : FT->param_types()) {
         ParmVarDecl *Param = BuildParmVarDeclForTypedef(NewFD, Loc, AI);
         Param->setScopeInfo(0, Params.size());
@@ -7713,8 +7750,7 @@ static bool isForbiddenTypeAllowed(Sema &S, Decl *D,
   // Private ivars are always okay.  Unfortunately, people don't
   // always properly make their ivars private, even in system headers.
   // Plus we need to make fields okay, too.
-  if (!isa<FieldDecl>(D) && !isa<ObjCPropertyDecl>(D) &&
-      !isa<FunctionDecl>(D))
+  if (!isa<FieldDecl>(D) && !isa<ObjCPropertyDecl>(D) && !isa<FunctionDecl>(D))
     return false;
 
   // Silently accept unsupported uses of __weak in both user and system
@@ -7767,7 +7803,6 @@ static void handleDelayedForbiddenType(Sema &S, DelayedDiagnostic &DD,
   DD.Triggered = true;
 }
 
-
 void Sema::PopParsingDeclaration(ParsingDeclState state, Decl *decl) {
   assert(DelayedDiagnostics.getCurrentPool());
   DelayedDiagnosticPool &poppedPool = *DelayedDiagnostics.getCurrentPool();
@@ -7776,7 +7811,8 @@ void Sema::PopParsingDeclaration(ParsingDeclState state, Decl *decl) {
   // When delaying diagnostics to run in the context of a parsed
   // declaration, we only want to actually emit anything if parsing
   // succeeds.
-  if (!decl) return;
+  if (!decl)
+    return;
 
   // We emit all the active diagnostics in this pool or any of its
   // parents.  In general, we'll get one pool for the decl spec
@@ -7788,10 +7824,11 @@ void Sema::PopParsingDeclaration(ParsingDeclState state, Decl *decl) {
   const DelayedDiagnosticPool *pool = &poppedPool;
   do {
     bool AnyAccessFailures = false;
-    for (DelayedDiagnosticPool::pool_iterator
-           i = pool->pool_begin(), e = pool->pool_end(); i != e; ++i) {
+    for (DelayedDiagnosticPool::pool_iterator i = pool->pool_begin(),
+                                              e = pool->pool_end();
+         i != e; ++i) {
       // This const_cast is a bit lame.  Really, Triggered should be mutable.
-      DelayedDiagnostic &diag = const_cast<DelayedDiagnostic&>(*i);
+      DelayedDiagnostic &diag = const_cast<DelayedDiagnostic &>(*i);
       if (diag.Triggered)
         continue;
 
diff --git a/clang/lib/Support/CMakeLists.txt b/clang/lib/Support/CMakeLists.txt
index de06271e914a..3d0a7c8614f6 100644
--- a/clang/lib/Support/CMakeLists.txt
+++ b/clang/lib/Support/CMakeLists.txt
@@ -15,9 +15,7 @@ set(clangSupport_sources
 
 add_clang_library(clangSupport ${clangSupport_sources})
 
-if (TARGET obj.clangSupport)
-  add_library(clangSupport_tablegen ALIAS obj.clangSupport)
-elseif (NOT LLVM_LINK_LLVM_DYLIB)
+if (NOT LLVM_LINK_LLVM_DYLIB)
   add_library(clangSupport_tablegen ALIAS clangSupport)
 else()
   # Build a version of the support library that does not link against
diff --git a/clang/tools/CMakeLists.txt b/clang/tools/CMakeLists.txt
index 98c018e96848..917a47588cf0 100644
--- a/clang/tools/CMakeLists.txt
+++ b/clang/tools/CMakeLists.txt
@@ -1,45 +1,5 @@
 create_subdirectory_options(CLANG TOOL)
 
-add_clang_subdirectory(diagtool)
-add_clang_subdirectory(driver)
-add_clang_subdirectory(apinotes-test)
-add_clang_subdirectory(clang-diff)
-add_clang_subdirectory(clang-format)
-add_clang_subdirectory(clang-fuzzer)
-add_clang_subdirectory(clang-import-test)
-add_clang_subdirectory(clang-linker-wrapper)
-add_clang_subdirectory(clang-nvlink-wrapper)
-add_clang_subdirectory(clang-offload-packager)
-add_clang_subdirectory(clang-offload-bundler)
-add_clang_subdirectory(clang-scan-deps)
-add_clang_subdirectory(clang-sycl-linker)
-add_clang_subdirectory(clang-installapi)
-if(HAVE_CLANG_REPL_SUPPORT)
-  add_clang_subdirectory(clang-repl)
-endif()
-
-add_clang_subdirectory(c-index-test)
-
-add_clang_subdirectory(clang-refactor)
-# For MinGW we only enable shared library if LLVM_LINK_LLVM_DYLIB=ON.
-# Without that option resulting library is too close to 2^16 DLL exports limit.
-if(UNIX OR (MSVC AND LLVM_BUILD_LLVM_DYLIB_VIS) OR (MINGW AND LLVM_LINK_LLVM_DYLIB))
-  add_clang_subdirectory(clang-shlib)
-endif()
-
-if(CLANG_ENABLE_ARCMT)
-  add_clang_subdirectory(arcmt-test)
-  add_clang_subdirectory(c-arcmt-test)
-endif()
-
-if(CLANG_ENABLE_STATIC_ANALYZER)
-  add_clang_subdirectory(clang-check)
-  add_clang_subdirectory(clang-extdef-mapping)
-  add_clang_subdirectory(scan-build)
-  add_clang_subdirectory(scan-build-py)
-  add_clang_subdirectory(scan-view)
-endif()
-
 # We support checking out the clang-tools-extra repository into the 'extra'
 # subdirectory. It contains tools developed as part of the Clang/LLVM project
 # on top of the Clang tooling platform. We keep them in a separate repository
diff --git a/clang/tools/libclang/CMakeLists.txt b/clang/tools/libclang/CMakeLists.txt
index 00a1223c0831..b7a02410fe2d 100644
--- a/clang/tools/libclang/CMakeLists.txt
+++ b/clang/tools/libclang/CMakeLists.txt
@@ -135,7 +135,7 @@ if (UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES "AIX")
     remove_definitions("-D_XOPEN_SOURCE=700")
 endif()
 
-add_clang_library(libclang ${ENABLE_SHARED} ${ENABLE_STATIC} INSTALL_WITH_TOOLCHAIN
+add_clang_library(libclang ${ENABLE_STATIC} INSTALL_WITH_TOOLCHAIN
   OUTPUT_NAME ${output_name}
   ${SOURCES}
 
@@ -154,7 +154,7 @@ add_clang_library(libclang ${ENABLE_SHARED} ${ENABLE_STATIC} INSTALL_WITH_TOOLCH
   )
 
 if(ENABLE_STATIC)
-  foreach(name libclang obj.libclang libclang_static)
+  foreach(name libclang libclang_static)
     if (TARGET ${name})
       target_compile_definitions(${name} PUBLIC CINDEX_NO_EXPORTS)
     endif()
diff --git a/llvm/CMakeLists.txt b/llvm/CMakeLists.txt
index f5293e866324..f54cb5db42c6 100644
--- a/llvm/CMakeLists.txt
+++ b/llvm/CMakeLists.txt
@@ -512,7 +512,7 @@ set(LLVM_ALL_EXPERIMENTAL_TARGETS
 # List of targets with JIT support:
 set(LLVM_TARGETS_WITH_JIT X86 PowerPC AArch64 ARM Mips SystemZ)
 
-set(LLVM_TARGETS_TO_BUILD "all"
+set(LLVM_TARGETS_TO_BUILD ""
     CACHE STRING "Semicolon-separated list of targets to build, or \"all\".")
 
 set(LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ""
diff --git a/llvm/cmake/modules/AddLLVM.cmake b/llvm/cmake/modules/AddLLVM.cmake
index d3e9377c8d2f..5c2b1ef8b43e 100644
--- a/llvm/cmake/modules/AddLLVM.cmake
+++ b/llvm/cmake/modules/AddLLVM.cmake
@@ -850,35 +850,6 @@ function(add_llvm_install_targets target)
       list(APPEND file_dependencies ${dependency})
     endif()
   endforeach()
-
-  get_subproject_title(subproject_title)
-
-  add_custom_target(${target}
-                    DEPENDS ${file_dependencies}
-                    COMMAND "${CMAKE_COMMAND}"
-                            ${component_option}
-                            ${prefix_option}
-                            -P "${CMAKE_BINARY_DIR}/cmake_install.cmake"
-                    USES_TERMINAL)
-  set_target_properties(${target} PROPERTIES FOLDER "${subproject_title}/Installation")
-  add_custom_target(${target}-stripped
-                    DEPENDS ${file_dependencies}
-                    COMMAND "${CMAKE_COMMAND}"
-                            ${component_option}
-                            ${prefix_option}
-                            -DCMAKE_INSTALL_DO_STRIP=1
-                            -P "${CMAKE_BINARY_DIR}/cmake_install.cmake"
-                    USES_TERMINAL)
-  set_target_properties(${target}-stripped PROPERTIES FOLDER "${subproject_title}/Installation")
-  if(target_dependencies)
-    add_dependencies(${target} ${target_dependencies})
-    add_dependencies(${target}-stripped ${target_dependencies})
-  endif()
-
-  if(ARG_SYMLINK)
-    add_dependencies(${target} install-${ARG_SYMLINK})
-    add_dependencies(${target}-stripped install-${ARG_SYMLINK}-stripped)
-  endif()
 endfunction()
 
 # Define special targets that behave like a component group. They don't have any
diff --git a/llvm/lib/CMakeLists.txt b/llvm/lib/CMakeLists.txt
index d0a2bc929438..3ec909d951bb 100644
--- a/llvm/lib/CMakeLists.txt
+++ b/llvm/lib/CMakeLists.txt
@@ -24,7 +24,6 @@ add_subdirectory(Analysis)
 add_subdirectory(LTO)
 add_subdirectory(MC)
 add_subdirectory(MCA)
-add_subdirectory(ObjCopy)
 add_subdirectory(Object)
 add_subdirectory(ObjectYAML)
 add_subdirectory(Option)
@@ -44,7 +43,6 @@ add_subdirectory(TextAPI)
 if (LLVM_BUILD_TELEMETRY)
   add_subdirectory(Telemetry)
 endif()
-add_subdirectory(ToolDrivers)
 add_subdirectory(XRay)
 if (LLVM_INCLUDE_TESTS)
   add_subdirectory(Testing)
diff --git a/llvm/lib/Support/BLAKE3/CMakeLists.txt b/llvm/lib/Support/BLAKE3/CMakeLists.txt
index 99cb78881ec4..d5916bd587dc 100644
--- a/llvm/lib/Support/BLAKE3/CMakeLists.txt
+++ b/llvm/lib/Support/BLAKE3/CMakeLists.txt
@@ -82,6 +82,6 @@ else()
   disable_blake3_x86_simd()
 endif()
 
-add_library(LLVMSupportBlake3 OBJECT EXCLUDE_FROM_ALL ${LLVM_BLAKE3_FILES})
+add_library(LLVMSupportBlake3 STATIC EXCLUDE_FROM_ALL ${LLVM_BLAKE3_FILES})
 set_target_properties(LLVMSupportBlake3 PROPERTIES FOLDER "LLVM/Libraries")
 llvm_update_compile_flags(LLVMSupportBlake3)
diff --git a/llvm/projects/CMakeLists.txt b/llvm/projects/CMakeLists.txt
index 08f2fa522420..8b3e38b187e2 100644
--- a/llvm/projects/CMakeLists.txt
+++ b/llvm/projects/CMakeLists.txt
@@ -41,6 +41,7 @@ endif()
 
 add_llvm_external_project(dragonegg)
 add_llvm_external_project(openmp)
+add_llvm_external_project(clang)
 
 if(LLVM_INCLUDE_TESTS)
   add_llvm_external_project(cross-project-tests)
diff --git a/llvm/utils/TableGen/Basic/CMakeLists.txt b/llvm/utils/TableGen/Basic/CMakeLists.txt
index b058fba78eb0..a7541d4ee972 100644
--- a/llvm/utils/TableGen/Basic/CMakeLists.txt
+++ b/llvm/utils/TableGen/Basic/CMakeLists.txt
@@ -8,7 +8,7 @@ set(LLVM_LINK_COMPONENTS
   TableGen
   )
 
-add_llvm_library(LLVMTableGenBasic OBJECT EXCLUDE_FROM_ALL DISABLE_LLVM_LINK_LLVM_DYLIB
+add_llvm_library(LLVMTableGenBasic STATIC EXCLUDE_FROM_ALL DISABLE_LLVM_LINK_LLVM_DYLIB
   ARMTargetDefEmitter.cpp
   Attributes.cpp
   CodeGenIntrinsics.cpp
diff --git a/llvm/utils/TableGen/CMakeLists.txt b/llvm/utils/TableGen/CMakeLists.txt
index 67291214c14e..2d4f664897e9 100644
--- a/llvm/utils/TableGen/CMakeLists.txt
+++ b/llvm/utils/TableGen/CMakeLists.txt
@@ -18,7 +18,15 @@ set(LLVM_LINK_COMPONENTS Support)
 # E.g. CMake derives which linker to use from the types of sources added.
 add_tablegen(llvm-min-tblgen LLVM_HEADERS
   llvm-min-tblgen.cpp
-  $<TARGET_OBJECTS:obj.LLVMTableGenBasic>
+  Basic/ARMTargetDefEmitter.cpp
+  Basic/Attributes.cpp
+  Basic/CodeGenIntrinsics.cpp
+  Basic/DirectiveEmitter.cpp
+  Basic/IntrinsicEmitter.cpp
+  Basic/RISCVTargetDefEmitter.cpp
+  Basic/SDNodeProperties.cpp
+  Basic/TableGen.cpp
+  Basic/VTEmitter.cpp
 
   PARTIAL_SOURCES_INTENDED
   )
@@ -70,11 +78,42 @@ add_tablegen(llvm-tblgen LLVM
   X86MnemonicTables.cpp
   X86ModRMFilters.cpp
   X86RecognizableInstr.cpp
-  $<TARGET_OBJECTS:obj.LLVMTableGenBasic>
-  $<TARGET_OBJECTS:obj.LLVMTableGenCommon>
+  Basic/ARMTargetDefEmitter.cpp
+  Basic/Attributes.cpp
+  Basic/CodeGenIntrinsics.cpp
+  Basic/DirectiveEmitter.cpp
+  Basic/IntrinsicEmitter.cpp
+  Basic/RISCVTargetDefEmitter.cpp
+  Basic/SDNodeProperties.cpp
+  Basic/TableGen.cpp
+  Basic/VTEmitter.cpp
+  Common/GlobalISel/CodeExpander.cpp
+  Common/GlobalISel/CombinerUtils.cpp
+  Common/GlobalISel/CXXPredicates.cpp
+  Common/GlobalISel/GlobalISelMatchTable.cpp
+  Common/GlobalISel/GlobalISelMatchTableExecutorEmitter.cpp
+  Common/GlobalISel/PatternParser.cpp
+  Common/GlobalISel/Patterns.cpp
+  Common/AsmWriterInst.cpp
+  Common/CodeGenDAGPatterns.cpp
+  Common/CodeGenHwModes.cpp
+  Common/CodeGenInstAlias.cpp
+  Common/CodeGenInstruction.cpp
+  Common/CodeGenRegisters.cpp
+  Common/CodeGenSchedule.cpp
+  Common/CodeGenTarget.cpp
+  Common/DAGISelMatcher.cpp
+  Common/InfoByHwMode.cpp
+  Common/OptEmitter.cpp
+  Common/PredicateExpander.cpp
+  Common/SubtargetFeatureInfo.cpp
+  Common/Types.cpp
+  Common/Utils.cpp
+  Common/VarLenCodeEmitterGen.cpp
 
   PARTIAL_SOURCES_INTENDED
 
   DEPENDS
+  vt_gen
   intrinsics_gen # via llvm-min-tablegen
   )
diff --git a/llvm/utils/TableGen/Common/CMakeLists.txt b/llvm/utils/TableGen/Common/CMakeLists.txt
index 7342156980f3..604627587a06 100644
--- a/llvm/utils/TableGen/Common/CMakeLists.txt
+++ b/llvm/utils/TableGen/Common/CMakeLists.txt
@@ -10,7 +10,7 @@ set(LLVM_LINK_COMPONENTS
   TableGen
   )
 
-add_llvm_library(LLVMTableGenCommon STATIC OBJECT EXCLUDE_FROM_ALL DISABLE_LLVM_LINK_LLVM_DYLIB
+add_llvm_library(LLVMTableGenCommon STATIC EXCLUDE_FROM_ALL DISABLE_LLVM_LINK_LLVM_DYLIB
   GlobalISel/CodeExpander.cpp
   GlobalISel/CombinerUtils.cpp
   GlobalISel/CXXPredicates.cpp
diff --git a/llvm/utils/TableGen/Common/CodeGenDAGPatterns.h b/llvm/utils/TableGen/Common/CodeGenDAGPatterns.h
index 6a6f1a6ac437..ecdfd189aa43 100644
--- a/llvm/utils/TableGen/Common/CodeGenDAGPatterns.h
+++ b/llvm/utils/TableGen/Common/CodeGenDAGPatterns.h
@@ -14,8 +14,8 @@
 #ifndef LLVM_UTILS_TABLEGEN_COMMON_CODEGENDAGPATTERNS_H
 #define LLVM_UTILS_TABLEGEN_COMMON_CODEGENDAGPATTERNS_H
 
-#include "Basic/CodeGenIntrinsics.h"
-#include "Basic/SDNodeProperties.h"
+#include "../Basic/CodeGenIntrinsics.h"
+#include "../Basic/SDNodeProperties.h"
 #include "CodeGenTarget.h"
 #include "llvm/ADT/IntrusiveRefCntPtr.h"
 #include "llvm/ADT/MapVector.h"
diff --git a/llvm/utils/TableGen/Common/CodeGenTarget.h b/llvm/utils/TableGen/Common/CodeGenTarget.h
index 682cc4e2bc9c..2b9c7f772bf8 100644
--- a/llvm/utils/TableGen/Common/CodeGenTarget.h
+++ b/llvm/utils/TableGen/Common/CodeGenTarget.h
@@ -16,8 +16,8 @@
 #ifndef LLVM_UTILS_TABLEGEN_COMMON_CODEGENTARGET_H
 #define LLVM_UTILS_TABLEGEN_COMMON_CODEGENTARGET_H
 
-#include "Basic/CodeGenIntrinsics.h"
-#include "Basic/SDNodeProperties.h"
+#include "../Basic/CodeGenIntrinsics.h"
+#include "../Basic/SDNodeProperties.h"
 #include "CodeGenHwModes.h"
 #include "CodeGenInstruction.h"
 #include "InfoByHwMode.h"
diff --git a/llvm/utils/TableGen/Common/GlobalISel/GlobalISelMatchTable.cpp b/llvm/utils/TableGen/Common/GlobalISel/GlobalISelMatchTable.cpp
index 8564bf8d2d91..fd54fb606b07 100644
--- a/llvm/utils/TableGen/Common/GlobalISel/GlobalISelMatchTable.cpp
+++ b/llvm/utils/TableGen/Common/GlobalISel/GlobalISelMatchTable.cpp
@@ -7,8 +7,8 @@
 //===----------------------------------------------------------------------===//
 
 #include "GlobalISelMatchTable.h"
-#include "Common/CodeGenInstruction.h"
-#include "Common/CodeGenRegisters.h"
+#include "../CodeGenInstruction.h"
+#include "../CodeGenRegisters.h"
 #include "llvm/ADT/Statistic.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/LEB128.h"
diff --git a/llvm/utils/TableGen/Common/GlobalISel/GlobalISelMatchTable.h b/llvm/utils/TableGen/Common/GlobalISel/GlobalISelMatchTable.h
index 77c8bc290faa..b786c82819e5 100644
--- a/llvm/utils/TableGen/Common/GlobalISel/GlobalISelMatchTable.h
+++ b/llvm/utils/TableGen/Common/GlobalISel/GlobalISelMatchTable.h
@@ -16,7 +16,7 @@
 #ifndef LLVM_UTILS_TABLEGEN_COMMON_GLOBALISEL_GLOBALISELMATCHTABLE_H
 #define LLVM_UTILS_TABLEGEN_COMMON_GLOBALISEL_GLOBALISELMATCHTABLE_H
 
-#include "Common/CodeGenDAGPatterns.h"
+#include "../CodeGenDAGPatterns.h"
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/DenseMap.h"
 #include "llvm/ADT/MapVector.h"
diff --git a/llvm/utils/TableGen/Common/GlobalISel/GlobalISelMatchTableExecutorEmitter.h b/llvm/utils/TableGen/Common/GlobalISel/GlobalISelMatchTableExecutorEmitter.h
index 862f1e83c169..33ee9171b54a 100644
--- a/llvm/utils/TableGen/Common/GlobalISel/GlobalISelMatchTableExecutorEmitter.h
+++ b/llvm/utils/TableGen/Common/GlobalISel/GlobalISelMatchTableExecutorEmitter.h
@@ -15,7 +15,7 @@
 #ifndef LLVM_UTILS_TABLEGEN_COMMON_GLOBALISEL_GLOBALISELMATCHTABLEEXECUTOREMITTER_H
 #define LLVM_UTILS_TABLEGEN_COMMON_GLOBALISEL_GLOBALISELMATCHTABLEEXECUTOREMITTER_H
 
-#include "Common/SubtargetFeatureInfo.h"
+#include "../SubtargetFeatureInfo.h"
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/StringRef.h"
 #include "llvm/ADT/Twine.h"
diff --git a/llvm/utils/TableGen/Common/GlobalISel/PatternParser.cpp b/llvm/utils/TableGen/Common/GlobalISel/PatternParser.cpp
index cb423ce142fb..602846c2059c 100644
--- a/llvm/utils/TableGen/Common/GlobalISel/PatternParser.cpp
+++ b/llvm/utils/TableGen/Common/GlobalISel/PatternParser.cpp
@@ -6,11 +6,11 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "Common/GlobalISel/PatternParser.h"
-#include "Basic/CodeGenIntrinsics.h"
-#include "Common/CodeGenTarget.h"
-#include "Common/GlobalISel/CombinerUtils.h"
-#include "Common/GlobalISel/Patterns.h"
+#include "PatternParser.h"
+#include "../../Basic/CodeGenIntrinsics.h"
+#include "../CodeGenTarget.h"
+#include "../GlobalISel/CombinerUtils.h"
+#include "../GlobalISel/Patterns.h"
 #include "llvm/ADT/StringRef.h"
 #include "llvm/Support/PrettyStackTrace.h"
 #include "llvm/Support/SaveAndRestore.h"
diff --git a/llvm/utils/TableGen/Common/GlobalISel/Patterns.cpp b/llvm/utils/TableGen/Common/GlobalISel/Patterns.cpp
index 0b84a9bbe634..342c605ba387 100644
--- a/llvm/utils/TableGen/Common/GlobalISel/Patterns.cpp
+++ b/llvm/utils/TableGen/Common/GlobalISel/Patterns.cpp
@@ -7,11 +7,11 @@
 //===----------------------------------------------------------------------===//
 
 #include "Patterns.h"
-#include "Basic/CodeGenIntrinsics.h"
+#include "../../Basic/CodeGenIntrinsics.h"
+#include "../CodeGenInstruction.h"
 #include "CXXPredicates.h"
 #include "CodeExpander.h"
 #include "CodeExpansions.h"
-#include "Common/CodeGenInstruction.h"
 #include "llvm/ADT/StringSet.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/raw_ostream.h"
diff --git a/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp b/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp
index 770494405810..898d03882879 100644
--- a/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp
+++ b/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp
@@ -2649,15 +2649,15 @@ GICombinerEmitter::buildMatchTable(MutableArrayRef<RuleMatcher> Rules) {
       ++CurrentOrdering;
   }
 
-  llvm::stable_sort(InputRules, [&OpcodeOrder](const Matcher *A,
-                                               const Matcher *B) {
-    auto *L = static_cast<const RuleMatcher *>(A);
-    auto *R = static_cast<const RuleMatcher *>(B);
-    return std::tuple(OpcodeOrder[L->getOpcode()],
-                      L->insnmatchers_front().getNumOperandMatchers()) <
-           std::tuple(OpcodeOrder[R->getOpcode()],
-                      R->insnmatchers_front().getNumOperandMatchers());
-  });
+  llvm::stable_sort(
+      InputRules, [&OpcodeOrder](const Matcher *A, const Matcher *B) {
+        auto *L = static_cast<const RuleMatcher *>(A);
+        auto *R = static_cast<const RuleMatcher *>(B);
+        return std::tuple(OpcodeOrder[L->getOpcode()],
+                          L->insnmatchers_front().getNumOperandMatchers()) <
+               std::tuple(OpcodeOrder[R->getOpcode()],
+                          R->insnmatchers_front().getNumOperandMatchers());
+      });
 
   for (Matcher *Rule : InputRules)
     Rule->optimize();

diff --git a/patched b/patched
new file mode 100644
index 000000000000..27ba77ddaf61
--- /dev/null
+++ b/patched
@@ -0,0 +1 @@
+yup
